The following text is a Git repository with code. The structure of the text are sections that begin with ----, followed by a single line containing the file path and file name, followed by a variable amount of lines containing the file contents. The text representing the Git repository ends when the symbols --END-- are encounted. Any further text beyond --END-- are meant to be interpreted as instructions using the aforementioned Git repository as context.
----
developers\developers\brightscript\language-reference\brightscript-encryption.md
# BrightScript Encryption

BrightScript supports encrypted modules. In order to use encrypted BrightScript, make sure that the players are running OS 8.1.54 or newer.

To encrypt your BrightScript modules, first contact BrightSign and request an encryption key. BrightSign will generate a new unique key pair and provide `customer-pub.pem` and `customer.hdr`. Once those two items are in your possession, encrypt your BrightScript files using the following process:

```
$ encrypt-brightscript --customer-public-key=customer-pub.pem --encrypted-key-data=customer.hdr myscript.brs
```

This will generate `myscript.ebrs` which is the encrypted version of the script.

> [!NOTE]
> Any .brs file can be encrypted, including those loaded with LIBRARY. Additionally, if any encrypted file is loaded, the BrightScript debugger is disabled for security reasons.
----
developers\developers\brightscript\language-reference\brightscript-known-issues.md
# BrightScript Known Issues

## Subroutine declaration incorrectly allows return type to be defined

A subroutine is defined as a function shortcut which returns type void, by either explicitly calling, “return“ or not including a return. The BrightScript subroutine **incorrectly** allows a subroutine to declare a return type allowing the subroutine to compile. A subroutine can “return” or not include a return, but if a subroutine should return a variable, we recommend declaring a function with a return type.

See [Program Statements | ProgramStatements-Function()AsType/EndFunction](../language-reference/program-statements.md) for more information about subroutines and functions. It correctly mentions that a subroutine only returns a void type (“The `Sub` statement can be used instead of `Function` as a shortcut for creating a function with return type `Void`").
----
developers\developers\brightscript\language-reference\brightscript-versions.md
# BrightScript Versions

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

|     |     |     |     |
| --- | --- | --- | --- |
| **BrightScript Version Matrix, January 9, 2009** |     |     |     |
|     | HD20000 1.3 Branch | HD2000  <br> 2.0 Branch | Compact Main Line |
| SnapShot Date | 1/7/2008 | 7/16/2008 | 1/9/2009 |
| Defxxx, on, gosub, clear, random, data, read, restore, err, errl, let, clear, line numbers | **X** | **X** |     |
| Intrinsic Arrays | **X** | **X** |     |
| Compiler |     | **X** | **X** |
| AA & dot Op & m reference |     | **X** | **X** |
| Sub/Functions |     | **X** | **X** |
| ifEnum & For Each |     | **X** | **X** |
| For/Next Does Not Always Execute At Least Once |     | **X** | **X** |
| Exit For |     | **X** | **X** |
| Invalid Type.  Errors that used to be Int Zero are now Invalid. Added roInvalid; Invalid Autoboxing |     |     | **X** |
| Array's use roArray; Added ifArray |     |     | **X** |
| Uninit Var Usage No Longer Allowed |     |     | **X** |
| Sub can have "As" (like Function) |     |     | **X** |
| roXML Element & XML Ops dot and @ |     |     | **X** |
| Type() Change: Now matches declaration names (eg. Integer not roINT32) |     |     | **X** |
| Added roBoolean |     |     | **X** |
| Added dynamic Type; Type now optional on Sub/Functions |     |     | **X** |
| And/Or Don't Eval un-needed Terms |     |     | **X** |
| Sub/Fun Default Parameter Values (e.g. `Sub (x=5 As Integer)`) |     |     | **X** |
| AA declaration  Op { } |     |     | **X** |
| Array Declaration Op \[ \] |     |     | **X** |
| Change Array Op from ( ) to \[\] |     |     | **X** |
| Anonymous Functions |     |     | **X** |
| Added Circ. Ref. Garbage Collector |     |     | **X** |
| Add Eval(), Run(), and Box() |     |     | **X** |
----
developers\developers\brightscript\language-reference\built-in-functions.md
# Built-In Functions

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Table of Contents

*   [Type()](#type)
*   [GetGlobalAA()](#getglobalaa)
*   [Rnd()](#rnd)
*   [Box()](#box)
*   [Run()](#run)
*   [Eval()](#eval)
*   [GetLastRunCompileError()](#getlastruncompileerror)
*   [GetLastRunRuntimeError()](#getlastrunruntimeerror)

BrightScript features a set of built-in, module-scope, intrinsic functions. A number of file I/O, string, mathematics, and system functions are also available via the *roGlobal* object.

## Type()

`Type(a As Variable) As String` 

This function returns the type of the passed variable and/or object.

## GetGlobalAA()

`GetGlobalAA() As Object`

This function fetches the global associative array for the current script.

## Rnd()

`Rnd(range As Integer) As Integer`  
`Rnd(0) As Float`

If passed a positive, non-zero integer, this function returns a pseudo-random integer between 1 and the argument value. The range includes the argument value: For example, calling `Rnd(55)` will return a pseudo-random integer greater than 0 and less than 56.

If the argument is 0, this function returns a pseudo-random Float value between 0 and 1.

> [!NOTE]
> **Note**
> The `Rnd()` functions utilize a pseudo-random seed number that is generated internally and not accessible to the user.

## Box()

`Box(type As Dynamic) As Object`

This function returns an object version of the specified intrinsic type. Objects will be passed through.

##### **Example**

```
b = box("string")
b = box(b)  ' b does not change
```

## Run()

`Run(file_name As String, [optional_arg As Dynamic, …]) As Dynamic`  
`Run(file_names As roArray, [optional_arg As Dynamic, …]) As Dynamic`

This function runs one or more scripts from the current script. You may append optional arguments, which will be passed to the `Main()` function of the script(s). The called script may also return arguments to the caller script.

If a string file name is passed, the function will compile and run the corresponding file. If an array of files is passed, the function will compile each file, link them together, and run them.

##### **Example**

```
Sub Main()
       Run("test.brs")
       BreakIfRunError(LINE_NUM)
       Print Run("test2.brs", "arg 1", "arg 2")
       if Run(["file1.brs","file2.brs"])<>4 then stop
       BreakIfRunError(LINE_NUM)
       stop
End Sub


Sub BreakIfRunError(ln)
       el=GetLastRunCompileError()
       if el=invalid then
             el=GetLastRunRuntimeError()
             if el=&hFC or el=&hE2 then return  
             'FC==ERR_NORMAL_END, E2=ERR_VALUE_RETURN
             print "Runtime Error (line ";ln;"): ";el
             stop
       else
             print "compile error (line ";ln;")"
             for each e in el
                    for each i in e
                          print i;": ";e[i]
                    end for
             end for
      
             stop
       end if
End Sub
```

## Eval()

`Eval(code_snippet As String) As Dynamic`

This function runs the passed code snippet in the context of the current function. The function compiles the snippet, then executes the byte-code. If the code compiles and runs successfully, it will return zero. If the code compiles successfully, but encounters a runtime error, it will return an integer indicating the error code (using the same codes as the `GetLastRunRuntimeError()` function). If compilation fails, it will return an *roList* object; the *roList* structure is identical to that of the `GetLastRunCompileError()` function.

The `Eval()` function can be useful in two cases:

*   When you need to dynamically generate code at runtime.
    
*   When you need to execute a statement that could result in a runtime error, but you don’t want code execution to stop.
    

##### **Example**

```
PRINT Eval("1/0") 'Returns a divide by zero error.
```

## GetLastRunCompileError()

GetLastRunCompileError() As roList

This function returns an *roList* object containing compile errors (or Invalid if no errors occurred). Each *roList* entry is an *roAssociativeArray* object containing the following keys:

*   `ERRSTR`: The compile error type (as String)
    
*   `FILESPEC`: The file URI of the script containing the error (as String)
    
*   `ERRNO`: The error number (as Integer)
    
*   `LINENO`: The line number where the error occurs (as Integer)
    

The following are possible `ERRNO` values:

|     |     |     |     |
| --- | --- | --- | --- |
| **Error Code** |     | **Description** | **Expanded Description** |
| &hBF | 191 | ERR\_NW | `ENDWHILE` statement occurs without statement. |
| &hBE | 190 | ERR\_MISSING\_ENDWHILE | `WHILE` statement occurs without `ENDWHILE` statement. |
| &hBC | 188 | ERR\_MISSING\_ENDIF | End of script reached without finding an `ENDIF` statement. |
| &hBB | 187 | ERR\_NOLN | No line number found. |
| &hBA | 186 | ERR\_LNSEQ | Line number sequence error. |
| &hB9 | 185 | ERR\_LOADFILE | Error loading file. |
| &hB8 | 184 | ERR\_NOMATCH | `MATCH` statement does not match. |
| &hB7 | 183 | ERR\_UNEXPECTED\_EOF | Unexpected end of string encountered during string compilation. |
| &hB6 | 182 | ERR\_FOR\_NEXT\_MISMATCH | Variable on `NEXT` does not match `FOR`. |
| &hB5 | 181 | ERR\_NO\_BLOCK\_END |     |
| &hB4 | 180 | ERR\_LABELTWICE | Label defined more than once. |
| &hB3 | 179 | ERR\_UNTERMED\_STRING | Literal string does not have end quote. |
| &hB2 | 178 | ERR\_FUN\_NOT\_EXPECTED |     |
| &hB1 | 177 | ERR\_TOO\_MANY\_CONST |     |
| &hB0 | 176 | ERR\_TOO\_MANY\_VAR |     |
| &hAF | 175 | ERR\_EXIT\_WHILE\_NOT\_IN\_WHILE |     |
| &hAE | 174 | ERR\_INTERNAL\_LIMIT\_EXCEDED |     |
| &hAD | 173 | ERR\_SUB\_DEFINED\_TWICE |     |
| &hAC | 172 | ERR\_NOMAIN |     |
| &hAB | 171 | ERR\_FOREACH\_INDEX\_TM |     |
| &hAA | 170 | ERR\_RET\_CANNOT\_HAVE\_VALUE |     |
| &hA9 | 169 | ERR\_RET\_MUST\_HAVE\_VALUE |     |
| &hA8 | 168 | ERR\_FUN\_MUST\_HAVE\_RET\_TYPE |     |
| &hA7 | 167 | ERR\_INVALID\_TYPE |     |
| &hA6 | 166 | ERR\_NOLONGER | Feature no longer supported. |
| &hA5 | 165 | ERR\_EXIT\_FOR\_NOT\_IN\_FOR |     |
| &hA4 | 164 | ERR\_MISSING\_INITILIZER |     |
| &hA3 | 163 | ERR\_IF\_TOO\_LARGE |     |
| &hA2 | 162 | ERR\_RO\_NOT\_FOUND |     |
| &hA1 | 161 | ERR\_TOO\_MANY\_LABELS |     |
| &hA0 | 160 | ERR\_VAR\_CANNOT\_BE\_SUBNAME |     |
| &h9F | 159 | ERR\_INVALID\_CONST\_NAME |     |
| &h9E | 158 | ERR\_CONST\_FOLDING |     |

## GetLastRunRuntimeError()

`GetLastRunRuntimeError() As Integer`

This function returns the error code that resulted from the last `Run()` function.

These codes indicate a normal result:

|     |     |     |     |
| --- | --- | --- | --- |
| **Error Code** |     | **Description** | **Expanded Description** |
| &hFF | 255 | ERR\_OKAY |     |
| &hFC | 252 | ERR\_NORMAL\_END | Execution ended normally, but with termination (e.g. END, shell "exit", window closed). |
| &hE2 | 226 | ERR\_VALUE\_RETURN | Return executed with value returned on the stack. |
| &hE0 | 224 | ERR\_NO\_VALUE\_RETURN | Return executed without value returned on the stack. |

The following codes indicate runtime errors:

|     |     |     |     |
| --- | --- | --- | --- |
| **Error Code** |     | **Description** | **Expanded Description** |
| &hFE | 254 | ERR\_INTERNAL | Unexpected condition occurred. |
| &hFD | 253 | ERR\_UNDEFINED\_OPCD | Opcode could not be handled. |
| &hFB | 251 | ERR\_UNDEFINED\_OP | Expression operator could not be handled. |
| &hFA | 250 | ERR\_MISSING\_PARN |     |
| &hF9 | 249 | ERR\_STACK\_UNDER | No value to pop off the stack. |
| &hF8 | 248 | ERR\_BREAK | `scriptBreak()` function called. |
| &hF7 | 247 | ERR\_STOP | STOP statement executed. |
| &hF6 | 246 | ERR\_RO0 | bscNewComponent failed because object class not found. |
| &hF5 | 245 | ERR\_R01 | BrightScript member function call does not have right number of parameters. |
| &hF4 | 244 | ERR\_RO2 | BrightScript member function not found in object or interface. |
| &hF3 | 243 | ERR\_RO3 | BrightScript interface not a member of the object. |
| &hF2 | 242 | ERR\_TOO\_MANY\_PARAM | Too many function parameters to handle. |
| &hF1 | 241 | ERR\_WRONG\_NUM\_PARAM | Number of function parameters incorrect. |
| &hF0 | 240 | ERR\_RVIG | Function returns a value, but is ignored. |
| &hEF | 239 | ERR\_NOTPRINTABLE | Value not printable. |
| &hEE | 238 | ERR\_NOTWAITABLE | `WAIT` statement cannot be applied to object because object does not have an *roMessagePort* interface. |
| &hED | 237 | ERR\_MUST\_BE\_STATIC | Interface calls from rotINTERFACE type must be static. |
| &hEC | 236 | ERR\_RO4 | "." Dot Operator used on object that does not contain legal object or interface reference. |
| &hEB | 235 | ERR\_NOTYPEOP | Operation attempted on two type-less operands. |
| &hE9 | 233 | ERR\_USE\_OF\_UNINIT\_VAR | Uninitialized variable used illegally. |
| &hE8 | 232 | ERR\_TM2 | Non-numeric index applied to array. |
| &hE7 | 231 | ERR\_ARRAYNOTDIMMED |     |
| &hE6 | 230 | ERR\_USE\_OF\_UNINIT\_BRSUBREF | Reference to uninitialized SUB. |
| &hE5 | 229 | ERR\_MUST\_HAVE\_RETURN |     |
| &hE4 | 228 | ERR\_INVALID\_LVALUE | Left side of the expression is invalid. |
| &hE3 | 227 | ERR\_INVALID\_NUM\_ARRAY\_IDX | Number of array indexes is invalid. |
| &hE1 | 225 | ERR\_UNICODE\_NOT\_SUPPORTED |     |
| &hE0 | 224 | ERR\_NOTFUNOPABLE |     |
| &hDF | 223 | ERR\_STACK\_OVERFLOW |     |
| &h20 | 32  | ERR\_CN | Continue (`cont` or `c`) not allowed. |
| &h1C | 28  | ERR\_STRINGTOLONG |     |
| &h1A | 26  | ERR\_OS | String space has run out. |
| &h18 | 24  | ERR\_TM | A Type Mismatch (string /number operation mismatch) has occurred. |
| &h14 | 20  | ERR\_DIV\_ZERO |     |
| &h12 | 18  | ERR\_DD | Attempted to re-dimension array. |
| &h10 | 16  | ERR\_BS | Array subscript out of bounds. |
| &h0E | 14  | ERR\_MISSING\_LN |     |
| &h0C | 12  | ERR\_OUTOFMEM |     |
| &h08 | 8   | ERR\_FC | Invalid parameter passed to function/array (e.g. a negative matrix dim or square root). |
| &h06 | 6   | ERR\_OD | Out of data (READ). |
| &h04 | 4   | ERR\_RG | Return without Gosub. |
| &h02 | 2   | ERR\_SYNTAX |     |
| &h00 | 0   | ERR\_NF | `Next` without `For`. |
----
developers\developers\brightscript\language-reference\core-library-extension.md
# Core Library Extension

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

There are a number of built-in functions that are not part of the BrightScript Core Library. You can use the [LIBRARY](../language-reference/program-statements.md) statement to include this subset of functions:

```
LIBRARY "v30/bslCore.brs"
```

##### bslBrightScriptErrorCodes() As roAssociativeArray

Returns an associative array of name/value pairs corresponding to BrightScript error codes and their descriptions.

##### bslGeneralConstraints() As roAssociativeArray

Returns an associative array of name/value pairs corresponding to system constants.

##### bslUniversalControlEventCodes() As roAssociativeArray

Returns an associative array of name/value pairs corresponding to the remote key code constraints.

##### AsciiToHex(ascii As String) As String

Returns a hex-formatted version of the passed ASCII string.

##### HexToAscii(hex As String) As String

Returns an ASCII-formatted version of the passed hex string.

##### HexToInteger(hex As String) As Integer

Returns the integer value of the passed hex string.
----
developers\developers\brightscript\language-reference\events.md
# Events

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

Events in BrightScript center around an event loop and the *roMessagePort* object. Most BrightScript objects can post to a message port in the form of an event object: For example, the *roTimer* object posts events of the type *roTimerEvent* when configured intervals are reached.

The following script sets the destination message port using the `SetPort()` method, waits for an event in the form of an *roGpioButton* object, and then processes the event.

```
print "BrightSign Button-LED Test Running"
p =   CreateObject("roMessagePort")
gpio =  CreateObject("roGpioControlPort") 
gpio.SetPort(p)
 
while true
   msg=wait(0, p)
   if type(msg)="roGpioButton" then
       butn = msg.GetInt()
       if butn <=5 then
           gpio.SetOutputState(butn+17,1)
           print "Button Pressed: ";butn
           sleep(500)
           gpio.SetOutputState(butn+17,0)
        end if
    end if
 
   REM ignore buttons pressed while flashing led above
   while p.GetMessage()<>invalid
         end while
end while
```

Note that lines 6-7 can be replaced using the following (and substituting `end while` with `end for`):

```
For each msg in p
```
----
developers\developers\brightscript\language-reference\example-script.md
# Example Script

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

The following code uses GPIO buttons 1, 2, 3, 4 for controls. It will work on any BrightSign model that has a video output and a GPIO port.

```
REM
REM The game of Snake
REM demonstrates BrightScript programming concepts
REM June 22, 2008
 
REM
REM Every BrightScript program must have a single Main()
REM
 
Sub Main()
 
    game_board=newGameBoard()
 
    While true
        game_board.SetSnake(newSnake(game_board.StartX(), game_board.StartY()))
        game_board.Draw()
        game_board.EventLoop()
        if game_board.GameOver() then ExitWhile
    End While
End Sub
 
 
REM *******************************************************
REM *******************************************************
REM ***************                   *********************
REM *************** GAME BOARD OBJECT *********************
REM ***************                   *********************
REM *******************************************************
REM *******************************************************
 
 
REM
REM An example BrightScript constructor.   "newGameBoard()" is regular Function of module scope
REM BrightScript Objects are "dynamic" and created at runtime.  They have no "class". 
REM The object container is a BrightScript Component of type roAssocitiveArray (AA).  
REM The AA is used to hold member data and member functions.
REM
 
Function newGameBoard() As Object
    game_board=CreateObject("roAssociativeArray")       ' Create a BrightScript Component of type/class roAssociativeArray
    game_board.Init=gbInit                         ' Add an entry to the AA of type roFunction with value gbDraw (a sub defined in this module)
    game_board.Draw=gbDraw
    game_board.SetSnake=gbSetSnake
    game_board.EventLoop=gbEventLoop
    game_board.GameOver=gbGameOver
    game_board.StartX=gbStartX
    game_board.StartY=gbStartY
    game_board.Init()                                   ' Call the Init member function (which is gbInit)
 
    return game_board
 
End Function
 
 
REM
REM gbInit() is a member function of the game_board BrightScript Object.
REM When it is called, the "this" pointer "m" is set to the appropriate instance by
REM the BrightScript bytecode interpreter
REM   
Function gbInit() As Void
    REM
    REM button presses go to this message port
    REM
    m.buttons = CreateObject("roMessagePort")
    m.gpio =  CreateObject("roGpioControlPort") 
    m.gpio.SetPort(m.buttons)
 
    REM
    REM determine optimal size and position for the snake gameboard
    REM
    CELLWID=16     ' each cell on game in pixels width
    CELLHI=16      ' each cell in pix height
    MAXWIDE=30    ' max width (in cells) of game board
    MAXHI=30      ' max height (in cells) of game board
    vidmode=CreateObject("roVideoMode")
    w=cint(vidmode.GetResX()/CELLWID)
    if w>MAXWIDE then w = MAXWIDE
    h=cint(vidmode.GetResY()/CELLHI)
    if h>MAXHI then h=MAXHI
 
    xpix = cint((vidmode.GetResX() - w*CELLWID)/2)     ' center game board on screen
    ypix = cint((vidmode.GetResY() - h*CELLHI)/2)      ' center game board on screen
 
    REM
    REM Create Text Field with square char cell size
    REM
    meta=CreateObject("roAssociativeArray")
    meta.AddReplace("CharWidth",CELLWID)
    meta.AddReplace("CharHeight",CELLHI)
    meta.AddReplace("BackgroundColor",&H202020)   'very dark grey
    meta.AddReplace("TextColor",&H00FF00)   ' Green
    m.text_field=CreateObject("roTextField",xpix,ypix,w,h,meta)
    if type(m.text_field)<>"roTextField" then
        print "unable to create roTextField 1"
        stop
    endif
End Function
 
REM
REM As Object refers to type BrightScript Component
REM m the "this" pointer
REM
Sub gbSetSnake(snake As Object)
    m.snake=snake
End Sub
 
 
Function gbStartX() As Integer
    return cint(m.text_field.GetWidth()/2)
End Function
 
 
Function gbStartY() As Integer
    return cint(m.text_field.GetHeight()/2)
End Function
 
 
Function gbEventLoop() As Void
 
    tick_count=0
 
    while true
        msg=wait(250, m.buttons)   ' wait for a button, or 250ms (1/4 a second) timeout
        if type(msg)="roGpioButton" then
            if msg.GetInt()=1 m.snake.TurnNorth()
            if msg.GetInt()=2 m.snake.TurnSouth()
            if msg.GetInt()=3 m.snake.TurnEast()
            if msg.GetInt()=4 m.snake.TurnWest()
        else  'here if time out happened, move snake forward
            tick_count=tick_count+1
            if tick_count=6 then
                tick_count=0
                if m.snake.MakeLonger(m.text_field) then return
            else
                if m.snake.MoveForward(m.text_field) then return
            endif
        endif
    end while
 
End Function
 
 
Sub gbDraw()
    REM
    REM given a roTextField Object in "m.text_field", draw a box around its edge
    REM
 
    solid=191   ' use asc("*") if graphics not enabled
    m.text_field.Cls()
 
    for w=0 to m.text_field.GetWidth()-1
        print #m.text_field,@w,chr(solid);
        print #m.text_field,@m.text_field.GetWidth()*(m.text_field.GetHeight()-1)+w,chr(solid);
    end for
 
    for h=1 to m.text_field.GetHeight()-2
        print #m.text_field,@h*m.text_field.GetWidth(),chr(solid);
        print #m.text_field,@h*m.text_field.GetWidth()+m.text_field.GetWidth()-1,chr(solid);
    end for
 
    m.snake.Draw(m.text_field)
 
End Sub
 
Function gbGameOver() As Boolean
    msg$= " G A M E    O V E R "
    msg0$="                    "
    width = m.text_field.GetWidth()
    height = m.text_field.GetHeight()
 
    while true
        print #m.text_field,@width*(height/2-1)+(width-len(msg$))/2,msg$;
        sleep(300)
        print #m.text_field,@width*(height/2-1)+(width-len(msg$))/2,msg0$;
        sleep(150)
        REM  GetMessage returns the message object, or an int 0 if no message available
        If m.buttons.GetMessage() <> invalid Then Return False
    endwhile
 
End Function
 
 
REM *******************************************************
REM *******************************************************
REM ******************              ***********************
REM ****************** SNAKE OBJECT ***********************
REM ******************              ***********************
REM *******************************************************
REM *******************************************************
 
REM
REM construct a new snake BrightScript object
REM
Function newSnake(x As Integer, y As Integer) As Object
 
' Create AA BrightScript Component; the container for a "BrightScript Object"
    snake=CreateObject("roAssociativeArray")   
    snake.Draw=snkDraw
    snake.TurnNorth=snkTurnNorth
    snake.TurnSouth=snkTurnSouth
    snake.TurnEast=snkTurnEast
    snake.TurnWest=snkTurnWest
    snake.MoveForward=snkMoveForward
    snake.MakeLonger=snkMakeLonger
    snake.AddSegment=snkAddSegment
    snake.EraseEndBit=snkEraseEndBit
 
    REM
    REM a "snake" is a list of line segments
    REM a line segment is an roAssociativeArray that conains a length and direction (given by the x,y delta needed to move as it is drawn)
    REM
 
    snake.seg_list = CreateObject("roList")
    snake.AddSegment(1,0,3)
 
    REM
    REM The X,Y pos is the position of the head of the snake
    REM
    snake.snake_X=x
    snake.snake_Y=y
    snake.body=191   ' use asc("*") if graphics not enabled.
    snake.dx=1      ' default snake direction / move offset
    snake.dy=0      ' default snake direction / move offset
 
    return snake
 
End Function
 
 
Sub snkDraw(text_field As Object)
    x=m.snake_X
    y=m.snake_Y
    for each seg in m.seg_list
        xdelta=seg.xDelta
        ydelta=seg.yDelta
        for j=1 to seg.Len
            text_field.SetCursorPos(x, y)
            text_field.SendByte(m.body)
            x=x+xdelta
            y=y+ydelta
        end for
    end for
End Sub
 
 
Sub snkEraseEndBit(text_field As Object)
    x=m.snake_X
    y=m.snake_Y
    for each seg in m.seg_list
        x=x+seg.Len*seg.xDelta
        y=y+seg.Len*seg.yDelta
    end for
 
    text_field.SetCursorPos(x, y)
    text_field.SendByte(32)    ' 32 is ascii space, could use asc(" ")
 
End Sub
 
 
Function snkMoveForward(text_field As Object)As Boolean
    m.EraseEndBit(text_field)
    tail=m.seg_list.GetTail()
    REM
    REM the following shows how you can use an AA's member functions to perform the same
    REM functions the BrightScript . operator does behind the scenes for you (when used on an AA).
    REM there is not point to this longer method other than illustration
    REM
    len=tail.Lookup("Len")          ' same as len = tail.Len (or tail.len, BrightScript syntax is not case sensative)
    len = len-1
    if len=0 then
        m.seg_list.RemoveTail()
    else
        tail.AddReplace("Len",len)  ' same as tail.Len=len
    endif
 
    return m.MakeLonger(text_field)
 
End Function
 
Function snkMakeLonger(text_field As Object) As Boolean
    m.snake_X=m.snake_X+m.dx
    m.snake_Y=m.snake_Y+m.dy
    text_field.SetCursorPos(m.snake_X, m.snake_Y)
    if text_field.GetValue()=m.body then return true
    text_field.SendByte(m.body)
    head = m.seg_list.GetHead()
    head.Len=head.Len+1
    return false
End Function
 
Sub snkAddSegment(dx As Integer, dy As Integer, len as Integer)
 
    aa=CreateObject("roAssociativeArray")
    aa.AddReplace("xDelta",-dx)  ' line segments draw from head to tail
    aa.AddReplace("yDelta",-dy)
    aa.AddReplace("Len",len)
    m.seg_list.AddHead(aa)
 
End Sub
 
 
Sub snkTurnNorth()
    if m.dx<>0 or m.dy<>-1 then m.dx=0:m.dy=-1:m.AddSegment(m.dx, m.dy, 0)      'north
End Sub
 
Sub snkTurnSouth()
     if m.dx<>0 or m.dy<>1 then m.dx=0:m.dy=1:m.AddSegment(m.dx, m.dy, 0)       'south
End Sub
 
Sub snkTurnEast()
     if m.dx<>-1 or m.dy<>0 then m.dx=-1:m.dy=0:m.AddSegment(m.dx, m.dy, 0)     'east
End Sub
 
Sub snkTurnWest()
     if m.dx<>1 or m.dy<>0 then m.dx=1:m.dy=0:m.AddSegment(m.dx, m.dy, 0)       'west
End Sub
```
----
developers\developers\brightscript\language-reference\garbage-collection.md
# Garbage Collection

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

BrightScript automatically frees strings when they are no longer used, and it will free objects when their reference count goes to zero. This is carried out at the time the object or string is no longer used; there is no background garbage collection task. The result is a predictable garbage-collection process, with no unexpected stalls in execution. 

Objects may enter a state of circular reference counting: Objects that reference each other will never reach a reference count of zero and will need to be freed manually using the `RunGarbageCollector()` method. This method is useful when destroying old presentation data structures and creating a new presentation.
----
developers\developers\brightscript\language-reference\intrinsic-objects.md
# Intrinsic Objects

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

In general, this manual uses the term “object” to refer to “BrightScript components”, which are C or C++ components with interfaces and member functions that BrightScript uses directly. With the exception of some core objects (*roArray*, *roAssociativeArray*, *roInt*, *roMessagePort*, etc.), BrightScript objects are platform specific.

You can create intrinsic objects in BrightScript, but these objects are not BrightScript components. There is currently no way to create a BrightScript component in BrightScript or to create intrinsic objects that have interfaces (intrinsic objects can only contain member functions, properties, and other objects).

A BrightScript object is simply an *roAssociativeArray*: When a member function is called from an associative array, a “this” pointer is set to “m”, and “m” is accessible inside the Function code to access object keys. A “constructor” in BrightScript is simply a normal function at a global scope that creates an *roAssociativeArray* instance and fills in its member functions and properties 

See the “snake” game in the appendix for examples of creating intrinsic objects.
----
developers\developers\brightscript\language-reference\objects-and-interfaces.md
# Objects and Interfaces

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Table of Contents

*   [BrightScript Objects](#brightscript-objects)
*   [Wrapper Objects](#wrapper-objects)
*   [Interfaces](#interfaces)
*   [Statement and Interface Integration](#statement-and-interface-integration)
    *   [PRINT](#print)
    *   [WAIT](#wait)
    *   [Expression Parsing](#expression-parsing)
    *   [Array Operator](#array-operator)
    *   [Member Access Operator](#member-access-operator)

## BrightScript Objects

Though BrightScript operates independently of its object architecture and library, they are both required for programming BrightScript applications. The API of a BrightSign platform is exposed to BrightScript as a library objects: Platforms must register a new BrightScript object to expose some part of its API.

BrightScript objects are written in C (or a compatible language such as C++), and are robust against version changes: Scripts are generally backwards compatible with objects that have undergone revisions. 

BrightScript objects keep a reference count; they delete themselves when the reference count reaches zero.

## Wrapper Objects

All intrinsic BrightScript types (Boolean, Integer, Float, Double, String, and Invalid) have object equivalents. If one of these intrinsic types is passed to a function that expects an object, the appropriate wrapper object will be created, assigned the correct value, and passed to the function (this is sometimes referred to as "autoboxing"): This allows, for example, *roArray* objects to store values (e.g. integers and strings) as well as objects.

Any expression that expects one of the above types will work with the corresponding wrapper object as well: *roBoolean*, *roInt*, *roFloat*, *roDouble*, *roString*.

The following examples illustrate how wrapper objects work:

```
Print 5.tostr()+"th"
Print "5".toint()+5
 
-5.tostr()    'This will cause an error. Instead, use the following:
(-5).tostr()
 
if type(5.tostr())<> "String" then stop
if (-5).tostr()<>"-5" then stop
if (1+2).tostr()<>"3" then stop
i=-55
if i.tostr()<>"-55" then stop
if 100%.tostr()<>"100" then stop
if (-100%).tostr()<>"-100" then stop
y%=10
if y%.tostr()<>"10" then stop
      
if "5".toint()<>5 or type("5".toint())<>"Integer" then stop
if "5".tofloat()<>5.0 or type("5".tofloat())<>"Float" then stop
fs="-1.1"
if fs.tofloat()<>-1.1 or fs.toint()<>-1 then stop
      
if "01234567".left(3)<>"012" then stop
if "01234567".right(4)<>"4567" then stop
if "01234567".mid(3)<>"34567" then stop
if "01234567".mid(3,1)<>"3" then stop
if "01234567".instr("56")<>5 then stop
if "01234567".instr(6,"56")<>-1 then stop
if "01234567".instr(0,"0")<>0 then stop
```

## Interfaces

Interfaces in BrightScript operate similarly to Java or Microsoft COM: An interface is a known set of member functions that implement a set of logic. In some ways, an interface is similar to a virtual base class in C++; any script or program that is compatible with C can use an object interface without regards to the type of object it belongs to: For example, the *roSerialPort* object, which controls the standard serial interface, implements three interfaces: *ifSerialControl*, *ifStreamReceive*, and *ifStreamSend*. Since the print statement sends its output to any object that has an *ifStreamSend* interface, it works with the *roSerialPort* object, as well as any other object with the *ifStreamSend* interface.

## Statement and Interface Integration

Some BrightScript statements have integrated functionality with interfaces. This section describes how to use statements with interfaces.

### PRINT

Using the `PRINT` statement in the following format will print into an object that has an *ifStreamSend* interface, including the *roTextField* and *roSerialPort* objects:

```
port = CreateObject("roSerialPort",0,115200)
print port, "string"
```

If the expression being printed evaluates to an object with an *ifEnum* interface, the `PRINT` statement will print every item that can be enumerated.

In addition to printing the values of intrinsic types, the `PRINT` statement can also be used to print any object that exposes one of the following interfaces: *ifString*, *ifInt*, *ifFloat*.

### WAIT

The `WAIT` statement can work in conjunction with any object that has an *ifMessagePort* interface.

### Expression Parsing

Any expression that expects a certain type of variable—including Integer, Float, Double, Boolean, or String—can accept an object with an interface equivalent of that type: *ifInt*, *ifFloat*, *ifDouble*, *ifBoolean*, *ifString*.

### Array Operator

The \[ \] array operator works with any object that has an *ifArray* or *ifAssociativeArray* interface, including arrays, associative arrays, and lists.

### Member Access Operator

The member access operator (i.e. [Dot Operator](../language-reference/operators.md)) works with any object that has an *ifAssociativeArray* interface. It also works with any object when used to call a member function (i.e. method). It also has special meaning when used on an *roXMLElement* or *roXMLList* object.
----
developers\developers\brightscript\language-reference\operators.md
# Operators

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Table of Contents

*   [Logical and Bitwise Operators](#logical-and-bitwise-operators)
*   [Dot Operator](#dot-operator)
    *   [Associative Arrays](#associative-arrays)
*   [Array and Function-Call Operators](#array-and-function-call-operators)
    *   [Array Dimensions](#array-dimensions)
*   [Equals Operator](#equals-operator)

Operations in the innermost level of parentheses are performed first. Evaluation then proceeds according to the precedence in the following table. Operations on the same precedence are left-associative, except for exponentiation, which is right-associative.

|     |     |
| --- | --- |
| **Description** | **Symbol(s)** |
| Function Calls or Parentheses | ()  |
| Array Operators | . , \[\] |
| Exponentiation | ^   |
| Negation | –, + |
| Multiplication, Division, Modulus | \*, /, MOD |
| Addition, Subtraction | +, - |
| Comparison | <, >, = , <>, <=, >= |
| Logical Negation | NOT |
| Logical Conjunction | AND |
| Logical OR | OR  |

**String Operators**: The following operators work with strings: `<, >, =, <>, <=, >=, +`

**Function References**: The `=` and `<>` operators work on variables that contain function references and function literals.

## Logical and Bitwise Operators

The `AND`, `OR`, and `NOT` operators are used for logical (Boolean) comparisons if the arguments for these operators are Boolean:

```
a = 20
b = 20
c = 20
if a = c and not(b > 40) then print "success"
```

On the other hand, if the arguments for these operators are numeric, they will perform bitwise operations:

```
x = 1 and 2   ' x is zero
y = true and false  ' y is false
```

When the `AND` or `OR` operator is used for a logical operation, only the necessary amount of the expression is executed. For example, the first statement below will print "True", while the second statement will cause a runtime error (because "invalid" is not a valid operand for `OR`):

```
print true or invalid
print false or invalid
```

## Dot Operator

The "." Dot Operator can be used on any BrightScript object. It also has special meaning when used on an *roAssociativeArray* object, as well as [*roXMLElement* and *roXMLList*](#XML_Support) objects. When used on a BrightScript object, it refers to an interface or method associated with that object. In the following example, `IfInt` refers to the interface and `SetInt()` refers to a method that is part of that interface:

```
i = CreateObject("roInt")
i.ifInt.SetInt(5)
i.SetInt(5)
```

Every object method is part of an interface. However, specifying the interface with the "." Dot Operator is optional. If the interface is omitted, as in the third line of the above example, each interface that is part of the object will be searched for the specified member. If there is a naming conflict (i.e. a method with the same name appears in two interfaces), then the interface should be specified.

### Associative Arrays

When the "." Dot Operator is used on an Associative Array, it is the same as calling the `Lookup()` or `AddReplace()` methods, which are member functions of the [*roAssociativeArray*](../../brightscript/object-reference/brightscript-core-objects/roassociativearray.md) object:

```
aa = {}
aa.newkey = "the value"
print aa.newkey
```

Note that the parameters of the "." Dot Operator are set at compile time; unlike the `Lookup()` and `AddReplace()` methods, they are not dynamic.

The "." Dot Operator is always case insensitive: For example, the statement `aa.NewKey=55` will create the entry "newkey" in the associative array. To generate case-sensitive keys, instantiate an *roAssociativeArray* object and use the `SetModeCaseSensitive()` method.

## Array and Function-Call Operators

The \[ \] operator is used to access an array (i.e. any BrightScript object that has an *ifArray* interface, such as *roArray* and *roList* objects). It can also be used to access an associative array. The \[ \] operator takes expressions that are evaluated at runtime, while the "." Dot Operator takes identifiers at compile time.

The ( ) operator can be used to call a function. When used on a function literal (or variable containing a function reference), that function will be called.

The following code snippet demonstrates the use of both array and function-call operators.

```
aa = CreateObject("roAssociativeArray")
aa["newkey"] = "the value"
print aa["newkey"]

array = CreateObject("roArray", 10, true)
array[2] = "two"
print array[2]
 
fivevar = five
print fivevar()
 
array[1] = fivevar
print array[1]()   ' print 5
 
function five() As Integer
   return 5
end function
```

### Array Dimensions

Arrays in BrightScript are one dimensional. Multi-dimensional arrays are implemented as arrays of arrays. The \[ \] operator will automatically map multi-dimensionality. For example, the following two fetching expressions are the same:

```
dim array[5,5,5]
item = array[1][2][3]
item = array[1,2,3]
```

> [!NOTE]
> If a multi-dimensional array grows beyond its hint size, the new entries are not automatically set to *roArray*.

## Equals Operator

The = operator is used for both assignment and comparison:

```
a = 5
If a = 5 then print "a is 5"
```

Unlike the C language, BrightScript does not support use of the = assignment operator inside an expression. This is meant to eliminate a common class of bugs caused by confusion between assignment and comparison.

When assignment occurs, intrinsic types are copied, while BrightScript objects are reference counted.
----
developers\developers\brightscript\language-reference\program-statements.md
# Program Statements

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Table of Contents

*   [Statement Syntax](#statement-syntax)
*   [LIBRARY](#library)
*   [DIM](#dim)
*   [Assignment ("=")](#assignment)
*   [END](#end)
*   [STOP](#stop)
*   [GOTO](#goto)
*   [RETURN](#return)
*   [PRINT](#print)
*   [FOR / END FOR](#for-end-for)
*   [FOR EACH IN / END FOR](#for-each-in-end-for)
    *   [Nesting FOR EACH Statements](#nesting-for-each-statements)
*   [WHILE / EXIT WHILE](#while-exit-while)
*   [IF / THEN / ELSE](#if-then-else)
*   [Block IF / ELSEIF / THEN / ENDIF](#block-if-elseif-then-endif)
*   [Function() As Type / End Function](#function-as-type-end-function)

BrightScript supports the following statement types (note that BrightScript is not case sensitive). The syntax of each statement is documented in more detail later in this chapter.

*   `Library`
    
*   `Dim`
    
*   `=` (assignment)
    
*   `End`
    
*   `Stop`
    
*   `Goto`
    
*   `Rem <or> '`
    
*   `print`
    
*   `For / To / End For / Step / Exit For <or> Next`
    
*   `For Each / In / End For / Exit For <or> Next`
    
*   `While / End While / Exit While`
    
*   `Function / End Function / As / Return`
    

##### **Example**

```
Function Main() As Void
 
       dim cavemen[10]
 
       cavemen.push("fred")
       cavemen.push("barney")
       cavemen.push("wilma")
       cavemen.push("betty")
 
       for each caveman in cavemen
             print caveman
       end for
 
End Function
```

## Statement Syntax

Each line may contain a single statement. However, a colon (:) may be used to separate multiple statements on a single line.

##### **Example**

```
myname = "fred"
if myname="fred" then yourname = "barney":print yourname
```

## LIBRARY 

`LIBRARY Filename.brs`

The LIBRARY statement allows you to include your own BrightScript libraries (*.brs* files), which can then be utilized by your script. The LIBRARY statement(s) must occur at the beginning of a script, before any other statements, functions, operators, etc.

The system locates a library by searching the directory containing the current script, as well as the `SYS:/script-lib/` directory. Note that the `Run()` function does not currently change the path of a LIBRARY statement to that of the called script (i.e. the system will continue searching the directory of the caller script). On the other hand, running a script directly from the BrightSign shell does modify the library search path to that of the called script.

The first statement will include a library in the same folder as the script, while the second will include a library in a sub-folder.

```
LIBRARY "myBSL1.brs"
LIBRARY "new_lib/myBSL2.brs"
```

The following statement will include the [*bslCore.brs*](../language-reference/core-library-extension.md) library, which has some useful BrightScript features, from the `SYS:/script-lib/` directory.

```
LIBRARY "v30/bslCore.brs"
```

## DIM 

`DIM Name (dim1, dim2, …, dimK)`

The `DIM` (“dimension”) statement provides a shortcut for creating *roArray* objects. It sets the variable Name to type “roArray”. It can create arrays of arrays as needed for multi-dimensionality. The dimension passed to `DIM` is the index of the maximum entry to be allocated (i.e. the array initial size = dimension+1), though the array will be resized larger automatically if needed.

The following two lines create identical arrays.

```
Dim array[5]
array = CreateObject("roArray", 6, true)
```

> [!NOTE]
> **Note**
> The expression x\[a,b\] is equivalent to x\[a\]\[b\].

The following script demonstrates useful operations on a DIM array.

```
Dim c[5, 4, 6]


For x = 1 To 5
   For y = 1 To 4
        For z = 1 To 6
           c[x, y, z] = k
           k = k + 1
       End for
   End for
End for


k=0
For x = 1 To 5
    For y = 1 To 4
       For z = 1 To 6
          If c[x, y, z] <> k Then print"error" : Stop
          k = k + 1
          End for
   End for
End for
```

## Assignment ("=")

`variable = expression`

The assignment statement (“=”) assigns a variable to a new value.

In each of the following lines, the variable on the left side of the equals operator is assigned the value of the constant or expression on the right side of the equals operator.

```
a$="a rose is a rose"
b1=1.23
x=2.23
x=x-b1
```

## END

The `END` statement terminates script execution normally.

## STOP

The `STOP` statement interrupts script execution, returns a “STOP” error, and invokes the debugger. Use the `cont` command at the debugger prompt to continue execution of the script or the `step` command to execute a single step in the script.

## GOTO

`GOTO label`

The `GOTO` statement transfers program control to the line number specified by `label`. The `GOTO label` statement results in a branching operation. A `label` is an identifier terminated with a colon on a line that contains no other statements or expressions. 

##### **Example**

```
mylabel:
print "Hello World"
goto mylabel
```

## RETURN

`RETURN expression`

The `RETURN` statement returns from a function back to its caller. If the function is not type Void, `RETURN` can also return a value to the caller.

## PRINT

`PRINT [#output_object], [@location], item list`

The PRINT statement prints an item or list of items in the console. The item(s) may be strings, integers, floats, variables, or expressions. An object with an *ifInt*, *ifFloat*, or *ifString* interface may also be printed. If the `output_object` is specified, this statement will print to an object with an *ifStreamSend* interface.

If the statement is printing a list of items, the items must be separated with semicolons or commas. If semicolons are used, spaces are not inserted between printed items; if commas are used, the cursor will automatically advance to the next print zone before printing the next item.

Positive numbers and zero are printed with a leading space (without a plus sign). Spaces are not inserted before or after strings.

##### **Example**

```
x = 5 : print 25; " is equal to"; x ^2  
' prints "25 is equal to 25"
```

##### **Example**

```
a$ = "string"
print a$;a$,a$;" ";a$
'prints "stringstring	string string"
```

Each print zone in the following example is 16 characters wide. The cursor moves to the next print zone each time a comma is encountered.

```
> print "zone 1","zone 2","zone 3","zone 4"
'prints "zone 1          zone 2           zone 3           zone 4"
```

##### **Example**

```
print "print statement #1 ";
print "print statement #2"
'prints "print statement #1 print statement #2"
```

In some cases, semicolons can be dropped. For example, the following statement is legal:

```
Print "this is a five "5"!!"
```

A trailing semicolon overrides the cursor-return so that the next `PRINT` statement begins where the last left off. If no trailing punctuation is used with a `PRINT` statement, the cursor drops to the beginning of the next line.

#### \[@location\]

If the console you are printing to has the *ifTextField* interface, you can use the `@` character to specify where printing will begin.

##### **Example**

```
print #m.text_field,@width*(height/2-1)+(width-len(msg$))/2,msg$;
```

Whenever you use `PRINT @` on the bottom line of the display, an automatic line-feed causes all displayed lines to move up one line. To prevent this from happening, use a trailing semicolon at the end of the statement.

#### TAB (expression)

This statement moves the cursor to the specified position on the current line (modulo the width of the console if the TAB position is greater than the console width).

##### **Example**

```
print tab(5)"tabbed 5";tab(25)"tabbed 25"
```

Note the following about the `TAB` statement:

*   The `TAB` statement may be used several times in a `PRINT` list.
    
*   No punctuation is required after a `TAB` statement.
    
*   Numerical expressions may be used to specify a `TAB` position.
    
*   The `TAB` statement cannot be used to move the cursor to the left.
    
*   If the cursor is beyond the specified position, the `TAB` statement is ignored.
    

#### POS(x)

This statement returns an integer that indicates the current cursor position from 0 to the maximum width of the window. This statement requires a dummy argument in the form of any numeric expression.

```
print tab(40) pos(0)   'prints 40 at position 40

print "these" tab(pos(0)+5)"words" tab(pos(0)+5)"are";
print tab(pos(0)+5)"evenly" tab(pos(0)+5)"spaced"
```

## FOR / END FOR

`FOR counter_variable = initial_value TO final_value STEP increment / END FOR <or> NEXT`

The `FOR` statement creates an iterative loop that allows a sequence of program statements to be executed a specified number of times.

The `initial_value`, `final_value`, and `increment` can be any expression. The first time the `FOR` statement is executed, these three variables are evaluated and their values are saved; changing the variables during the loop will have no affect on the operation of the loop. However, the `counter_variable` must not be changed, or the loop will not operate normally. The first time the `FOR` statement is executed, the counter is set to both the value and type of the `initial_value`.

At the beginning of each loop, the value of the `counter_variable` is compared with the `final_value`. If the value of the `counter_variable` is greater than the `final_value`, the loop will complete and execution will continue with the statement following the `END FOR` (or `NEXT`) statement. If, on the other hand, the counter has not yet exceeded the `final_value`, control passes to the first statement after the `FOR` statement. If increment is a negative number, the loop will complete when the value of the `counter_variable` is less than the `final_value`.

When program flow reaches the `END FOR` (or `NEXT`) statement, the counter is incremented by the specified increment amount (or decremented if increment is a negative value). If the `STEP [increment]` language is not included in the `FOR` statement, the increment defaults to 1.

Use `EXIT FOR` to exit a `FOR` block prematurely.

The following script decrements `i` at the beginning of each loop until it is less than 1.

```
for i=10 to 1 step -1
       print i
end for
```

## FOR EACH IN / END FOR

`FOR EACH item IN object / END FOR <or> NEXT` 

The `FOR EACH` statement can iterate through a set of items in any object that has an *ifEnum* interface (i.e. an enumerator). The `FOR` block is terminated with the `END FOR` (or `NEXT`) statement. Objects that are ordered intrinsically (such as *roList*) are enumerated in order, while objects that have no intrinsic order (such as *roAssociativeArray*) are enumerated in apparent random order. It is possible to delete entries as they are enumerated.

Use `EXIT FOR` to exit a `FOR` block prematurely.

The following objects can be enumerated: *roList*, *roArray*, *roAssociativeArray*, *roMessagePort*.

The following script iterates over an associative array in random order, prints each key/value pair, then deletes it.

```
aa={joe: 10, fred: 11, sue:9}
For each n in aa
   Print n;aa[n]
   aa.delete[n]
end for
```

### Nesting FOR EACH Statements

The `FOR EACH` statement can only track one pointer per object instance, so nesting `FOR EACH` loops that iterate on the same object may cause the series to terminate prematurely:

```
values = {a: 1, b: 2, c: 3, d: 4, e: 5, f: 6}

for each key_outer in values
	print "outer: ";key_outer;" : ";values[key_outer]
	for each key_inner in values 'THIS WILL CAUSE PROBLEMATIC BEHAVIOR
		print "inner: ";key_inner;" : ";values[key_inner]
	end for
end for
```

To work around this limitation with associative arrays, copy the keys to an array and iterate on the array in the nested `FOR EACH` loop:

```
values = {a: 1, b: 2, c: 3, d: 4, e: 5, f: 6}
valuesArray = []

for each key in values 'Copy the keys to an array
	valuesArray.push(key)
end for

for each key_outer in values
	print "outer: ";key_outer;" : ";values[key_outer]
	for each key_inner in valuesArray 'Iterate over the array of keys
		print "inner: ";key_inner;" : ";values[key_inner]
	end for
end for
```

## WHILE / EXIT WHILE

`WHILE expression / EXIT WHILE`

A `WHILE` loop executes until the specified expression is false. Use the `EXIT WHILE` statement to exit a `WHILE` block prematurely.

```
k=0
while k<>0
   k=1
   Print "loop once"
end while
 
while true
   Print "loop once"
   Exit while
End while
```

## IF / THEN / ELSE

`IF expression THEN statements [ELSE statements]`

> [!NOTE]
> This is the single-line form of the IF THEN ELSE statement; see the next section for more details about the block form of the IF THEN ELSE statement.

The `IF` statement instructs the interpreter to test the following expression. If the expression is True, control will proceed to the statements immediately following the expression. If the expression is False, control will jump to either the matching `ELSE` statement (if there is one) or to the next program line after the block.

##### **Example**

```
if x>127 then print "out of range" : end
```

`THEN` is optional in the above and similar statements. However, `THEN` is sometimes required to eliminate ambiguity, as in the following example:

```
if y=m then m=o 'won't work without THEN
```

## Block IF / ELSEIF / THEN / ENDIF

The block (i.e. multi-line) form of IF / THEN / ELSE has the following syntax:

```
If BooleanExpression [ Then ]
   [ Block ]
   [ ElseIfStatement+ ]
   [ ElseStatement ]
End If
 
ElseIfStatement ::=
   ElseIf BooleanExpression [ Then ]
   [ Block ]
 
ElseStatement ::=
   Else
   [ Block ]
```

##### **Example**

```
vp_msg_loop:
        msg=wait(tiut, p)
        if type(msg)="rovideoevent" then                                            
            if debug then print "video event";msg.getint()
            if lm=0 and msg.getint() = meden then
                if debug then print "videofinished"
                retcode=5
                return
            endif
        else if type(msg)="rogpiobutton" then
            if debug then print "button press";msg
            if esc0 and msg=b0 then retcode=1:return
            if esc1 and msg=b1 then retcode=2:return
            if esc2 and msg=b2 then retcode=3:return
            if esc3 and msg=b3 then retcode=4:return
        else if type(msg)=" Invalid" then
            if debug then print "timeout"
            retcode=6
            return
        endif
 
        goto vp_msg_loop
```

## Function() As Type / End Function

`Function name(parameter As Type, …) As Type`

> [!NOTE]
> Each function has its own scope.

A function is declared using the `Function()` statement. The parentheses may contain one or more optional parameters; parameters can also have default values and expressions.

The type of each parameter may be declared. The return type of the function may also be declared. If a parameter type or return type is not declared, it is Dynamic by default. Intrinsic types are passed by value (and a copy is made), while objects are passed by reference. The `Sub` statement can be used instead of `Function` as a shortcut for creating a function with return type Void.

A parameter can be one of the following types:

*   Integer
    
*   Float
    
*   Double
    
*   String
    
*   Object
    
*   Dynamic
    

The function return can be one of the following types:

*   Void
    
*   Integer
    
*   Float
    
*   Double
    
*   String
    
*   Object
    
*   Dynamic
    

#### "M" Identifier 

If a function is called from an associative array, then the local variable `m` is set to the associative array in which the function is stored. If the function is not called from an associative array, then its `m` variable is set to an associative array that is global to the module and persists across calls.

The `m` identifier should only be used for the purpose stated above: We do not recommend using `m` as a general-purpose identifier.

##### **Example**

```
sub main()
   obj={
       add: add
       a: 5
       b: 10
       }
 
   obj.add()
   print obj.result
end sub
 
function add() As void
    m.result=m.a+m.b
end function
```

#### Anonymous Functions

A function without a name declaration is considered anonymous.

The following is a simple anonymous function declaration:

```
myfunc=function (a, b)
       Return a+b
end function
 
print myfunc(1,2)
```

Anonymous functions can also be used with associative-array literals:

```
q = {
 
starring : function(o, e)
str = e.GetBody()
print "Starring: " + str 
toks = box(str).tokenize(",")
for each act in toks
actx = box(act).trim()
if actx <> "" then
print "Actor: [" + actx + "]"
                o.Actors.Push(actx)
endif
end for
return 0
end function
}
 
q.starring(myobj, myxml)
```
----
developers\developers\brightscript\language-reference\reserved-words.md
# Reserved Words

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

|     |     |     |     |
| --- | --- | --- | --- |
| AND | ENDSUB | LINE\_NUM | RND |
| CREATEOBJECT | ENDWHILE | M\* | STEP |
| DIM | EXIT | NEXT | STOP |
| EACH | EXITWHILE | NOT | SUB |
| EACH | FALSE | OBJFUN | TAB |
| ELSE | FOR | OR  | THEN |
| END | FUNCTION | POS | TO  |
| ENDFOR | GOTO | PRINT | TRUE |
| ENDFUNCTION | IF  | REM | TYPE |
| ENDIF | INVALID | RETURN | WHILE |

\* Although `M` is not strictly a reserved word, it should not be used as an identifier outside of its [intended purpose](../language-reference/program-statements.md).
----
developers\developers\brightscript\language-reference\scope.md
# Scope

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

BrightScript uses the following scoping rules:

*   Global variables are not supported; however, there is a single hard-coded global variable (“global”) that is an interface to the [global BrightScript object](../../brightscript/object-reference/global-functions.md), which contains all global library functions.
    
*   Functions declared with the `Function` statement are global in scope; however, if the function is anonymous, it will still be local in scope.
    
*   Local variables exist within the function scope. If a function calls another function, that new function has its own scope.
    
*   Labels exist within the function scope.
    
*   Block statements such as `For / End For` and `While / End While` do not create a separate scope.
----
developers\developers\brightscript\language-reference\threading-model.md
# Threading Model

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

BrightScript runs in a single thread. In general, BrightScript object calls are synchronous if they return quickly, and asynchronous if they take a substantial amount of time to complete. For example, methods belonging to the *roArray* object are all synchronous, while the `Play()` method that is part of the *roVideoPlayer* object will return immediately (it is asynchronous). As a video plays, the *roVideoPlayer* object will post messages to the message port, indicating such events as “media playback finished” or “frame x reached”.                                  

The object implementer decides whether a BrightScript object should launch a background thread to perform a synchronous operation. Sometimes, an object will feature synchronous and asynchronous versions of the same method.

This threading model ensures that the script writer does not have to deal with mutexes and other synchronization objects. The script is always single threaded, and the message port is polled or waited on to receive events into the thread. On the other hand, those implementing BrightScript objects have to consider threading issues: For example, the *roList* and *roMessagePort* objects are thread-safe internally, allowing them to be used by multiple threads.
----
developers\developers\brightscript\language-reference\variables-literals-and-types.md
# Variables, Literals, and Types

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Table of Contents

*   [Identifiers](#identifiers)
    *   [Examples](#examples)
*   [Types](#types)
*   [Type Declaration Characters](#type-declaration-characters)
*   [Literals (Constants)](#literals-constants)
*   [Array Literals](#array-literals)
*   [Associative Array Literals](#associative-array-literals)
*   [Invalid Object Return](#invalid-object-return)
*   [Numbers](#numbers)
    *   [Dynamic Typing](#dynamic-typing)
    *   [Type Conversion](#type-conversion)
    *   [Type Conversion and Accuracy](#type-conversion-and-accuracy)

## Identifiers

Identifiers are names of variables, functions, and labels. They also apply to BrightScript object methods (i.e. functions) and interfaces (which appear after a "." Dot Operator). Identifiers have the following rules:

*   Must start with an alphabetic character (a-z).
    
*   May consist of alphabetic characters, numbers, or the underscore symbol ("\_").
    
*   Are not case sensitive.
    
*   May be of any length.
    
*   May not be a [reserved word](../language-reference/reserved-words.md).
    
*   (**variables only**) May end with an optional type declaration ("$" for a string, "%" for an integer, "!" for a float, "#" for a double).
    

##### **Examples**

```
a
boy5
super_man$
42%
```

## Types

BrightScript supports both dynamic typing and declared types. This means that every value has a type determined at runtime, but variables can also be instructed to always contain a value of a specified type. If a value is assigned to a variable that has a specified type, the type of the value will be converted to the variable type if possible. If conversion is impossible, a runtime error will occur.

A variable that does not end in a type declaration may change its type dynamically. For example, the statement `a=4` will create an integer, while a following statement specifying that `a="hello"` will change the type of the variable a to a string.

BrightScript supports the following types:

*   **Boolean**: True or False
    
*   **Integer**: A 32-bit signed integer number
    
*   **Float**: The smallest floating point number format supported by either the hardware or software
    
*   **Double**: The largest floating point number format supported by either the hardware or software. Although Double is an intrinsically understood type, it is implemented internally with the *roIntrinsicDouble* object.
    
*   **String**: A sequence of ASCII (not UTF-8) characters. BrightScript uses two intrinsic string states:
    
    *   **Constant strings**: A statement such as `s="astring"` will create an intrinsic constant string.
        
    *   **roString instances**: Once a string is used in an expression, it becomes an *roString* instance. For example, the statement `s = s + "bstring"` will cause the intrinsic string `s` to convert to an *roString* instance. If this is followed by the statement `s2 = s`, the `s2` value will be a reference to `s`, not a copy of it. The behavior of reference counting strings is new to BrightScript version 3.0.
        
*   **Object**: A reference to a BrightScript object (i.e. a native component). Note that the `type()` function will not return "Object" but the type of object instead (e.g. *roList*, *roVideoPlayer*). Also note that there is no separate type for intrinsic BrightScript Objects. All intrinsic BrightScript Objects are built on the *roAssociativeArray* object type.
    
*   **Interface**: An interface in a BrightScript Object. If a  "." Dot Operator is used on an interface type, the member must be static (since there is no object context).
    
*   **Invalid**: A type that can have only one value: `Invalid`. This type is returned in various instances when no other type is valid (for example, when indexing an array that has never been sent). It can also be assigned to a variable with the statement `var = invalid`.
    

The following are examples of different types. The `?` statement is a shortcut for `print`, while the `type()` function returns a string that identifies the type of the passed expression.

```
BrightScript> ?type(1)                      
Integer
        
BrightScript> ?type(1.0)                        
Float
       
BrightScript> ?type("hello")                            
String
        
BrightScript> ?type(CreateObject("roList"))                   
roList  
    
BrightScript> ?type(1%)
Integer

BrightScript> b!=1
BrightScript> ?type(b!)
Float

BrightScript> c$="hello"
BrightScript> ?type(c$)
String

BrightScript> d="hello again"
BrightScript> ?type(d)
String

BrightScript> d=1
BrightScript> ?type(d)
Integer

BrightScript> d=1.0
BrightScript> ?type(d)
Float
 
BrightScript>e=invalid
BrightSCript>?type(e)
Invalid
```

## Type Declaration Characters

A type declaration may be used at the end of a variable or literal to fix its type. Variables with the same identifier but separate types are separate variables: For example, defining a$ and a% would create two independent variables.

|     |     |     |
| --- | --- | --- |
| **Character** | **Type** | **Examples** |
| $   | String | A$, ZZ$ |
| %   | Integer | A1%, SUM% |
| !   | Single-Precision (Float) | B!, N1! |
| #   | Double-Precision (Double) | A#, 1/3#, 2# |

## Literals (Constants)

The following are valid literal types:

*   Type Boolean: Either `True` or `False`
    
*   Type Invalid: `Invalid` only
    
*   Type String: A string in quotes (e.g. `"This is a string"`)
    
*   Type Integer: An integer in hex (e.g. `HFF`) or decimal (e.g. `255`) format
    
*   Type Float: A number with a decimal (e.g. `2.01`), in scientific notation (e.g. `1.23456E+30`), or with a Float type designator (e.g. `2!`)
    
*   Type Double: A number in scientific notation containing a double-precision exponent symbol (e.g. `1.23456789D-12`) or with a Double type declaration (e.g. `2.3#`)
    
*   Type Function: Similar to variable formatting (e.g. `MyFunction`)
    
*   Type Integer: LINE\_NUM – The current source line number
    

## Array Literals

The `[]` Array Operator can be used to declare an array. It can contain literals (constants) or expressions.

```
x = 5
Myarray = []
Myarray = [ 1, 2, 3]
Myarray = [ x+5, true, 1<>2, ["a","b"]]
```

## Associative Array Literals

The { } Associative Array Operator can be used to define an associative array. It can contain literals (constants) or expressions.

```
aa = { }
aa = {key1:"value", key2: 55, key3: 5+3 }
```

Arrays and associative arrays can also be defined with the following format: 

```
aa = {
   Myfunc1: aFunction
   Myval1 : "the value"
}
```

## Invalid Object Return

Many methods (i.e. functions) that return objects can also return Invalid (for example, in cases where there is no object to return). In these cases, the variable accepting the result must be dynamically typed since it may be assigned either type.

The following code will return a type mismatch: a$ is a string that has a string type declaration, and thus it cannot contain Invalid.

```
l = []
a$ = l.pop()
```

## Numbers

### Dynamic Typing

The following rules determine how integers, doubles, and floats are dynamically typed:

1.  If a constant contains 10 or more digits, or if `D` is used in the exponent, the number is Double. Adding a `#` type declaration also forces a constant to be a Double.
    
2.  If the number is not double precision and it contains a decimal point, the number is a Float. Expressing a number in scientific notation using the `E` exponent also forces a constant to be a Float.
    
3.  If neither of the above conditions is true for a constant, the number is an Integer.
    

### Type Conversion

When operations are performed on one or two numbers, the result must be typed as an Integer, Float, or Double. When an addition (+), subtraction (-), or multiplication (\*) operation is performed, the result will have the same degree of precision as the most precise operand: For example, multiplying an Integer by a Double will return a number that is a Double.

Only when both operands are Integers will the result be an Integer number. If the result of two Integer operands is outside the 32-bit range, the operation and return will be carried out with Doubles.

Division (/) operates using the same rules as above, except that it can never be carried out at the Integer level: When both operators are Integers, the operation and return will be carried out with Floats.

Comparison operations (e.g. <, >, =) will convert the numbers to the same type before they are compared. The less precise type will always be converted to the more precise type.

### Type Conversion and Accuracy

When a Float or Double number is converted to the Integer type, it is *rounded down*: The largest integer that is not greater than the number is used. This also happens when the INT function is called on a number.

When a Double number is converted to the Float type, it is *4/5 rounded*: The least significant digit is rounded up if the fractional part is >=5 (otherwise, it is left unchanged).

When a Float number is converted to the Double type, only the seven most significant digits will be accurate.
----
developers\developers\brightscript\language-reference\xml-support.md
# XML Support

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Table of Contents

*   [Dot Operator](#dot-operator)
*   [Attribute Operator](#attribute-operator)
*   [Examples](#examples)
    *   [Flikr code clip](#flikr-code-clip)

BrightScript provides XML support with two BrightScript objects and a set of dedicated language features:

*   **roXMLElement**: This object provides support for parsing, generating, and containing XML.
    
*   **roXMLList**: This object is used to contain a list of *roXMLElement* instances.
    

## Dot Operator

The "." [Dot Operator](../language-reference/operators.md) has the following features when used with XML objects:

*   When used with an *roXMLElement* instance, the "." Dot Operator returns an *roXMLList* instance of the child tags that match the dot operand. If no tags match the operand, an empty list is returned.
    
*   When applied to an *roXMLList* instance, the "." Dot Operator aggregates the results of performing the above operation on each *roXMLElement* in the list.
    
*   When applied to XML, which is technically case sensitive, the "." Dot Operator is still case insensitive. If you wish to perform a case-sensitive XML operation, use the member functions of the *roXMLElement*/*roXMLList* objects.
    

## Attribute Operator

The “@” Attribute Operator can be used with an *roXMLElement* instance to return a named attribute. Though XML is case sensitive, the Attribute Operator is always case insensitive. If the Attribute Operator is used with an *roXMLList* instance, it will only return a value if that list contains exactly one element.

## Examples

```
<?xml version="1.0" encoding="utf-8" ?>
<rsp stat="ok">
    <photos page="1" pages="5" perpage="100" total="500">
        <photo id="3131875696" owner="21963906@N06" secret="f248c84625" server="3125"
        farm="4" title="VNY 16R" ispublic="1" isfriend="0" isfamily="0" />
        <photo id="3131137552" owner="8979045@N07" secret="b22cfde7c4" server="3078"
        farm="4" title="hoot" ispublic="1" isfriend="0" isfamily="0" />
        <photo id="3131040291" owner="27651538@N06" secret="ae25ff3942" server="3286"
        farm="4" title="172 • 365 :: Someone once told me..." ispublic="1" isfriend="0"
        />
    </photos>
</rsp>
```

Given the XML in the above *example.xml* file, then the following code will return an *roXMLList* instance with three entries:

```
rsp=CreateObject("roXMLElement")
rsp.Parse(ReadAsciiFile("example.xml"))
 
? rsp.photos.photo
```

The following will return an *roXMLElement* reference to the first photo (id="**3131875696**"):

```
? rsp.photos.photo[0]
```

The following will return an *roXMLList* reference containing the <photos> tag:

```
? rsp.photos
```

The following will return the string “100”:

```
rsp.photos@perpage
```

You can use the *roXMLElement.GetText()* method to return an element’s text: For example, if the variable `<booklist>` contains the element `<book lang=eng>The Dawn of Man</book>`, then the following code will print the string “The Dawn of Man”.

```
Print booklist.book.gettext()
```

Alternatively, using the Attribute Operator will print the string “eng”.

```
print booklist.book@lang
```

### Flikr code clip

```
REM
REM Interestingness
REM pass an (optional) page of value 1 - 5 to get 100 photos
REM starting at 0/100/200/300/400
REM
REM returns a list of "Interestingness" photos with 100 entries
REM


Function GetInterestingnessPhotoList(http as Object, page=1 As Integer) As Object


	print "page=";page


    http.SetUrl("http://api.flickr.com/services/rest/?method=flickr.interestingness.getList&api_key=YOURKEYGOESHERE&page="+mid(stri(page),2))


    xml=http.GetToString()


    rsp=CreateObject("roXMLElement")
    if not rsp.Parse(xml) then stop

       return helperPhotoListFromXML(http, rsp.photos.photo) 'rsp.GetBody().Peek().GetBody())

      
End Function


Function helperPhotoListFromXML(http As Object, xmllist As Object, owner=invalid As dynamic) As Object


    photolist=CreateObject("roList")
    for each photo in xmllist
       photolist.Push(newPhotoFromXML(http, photo, owner))
    end for
    return photolist


End Function


REM
REM newPhotoFromXML
REM
REM    Takes an roXMLElement Object that is an <photo> ... </photo>
REM    Returns an brs object of type Photo
REM       photo.GetTitle()
REM       photo.GetID()
REM       photo.GetURL()
REM       photo.GetOwner()
REM


Function newPhotoFromXML(http As Object, xml As Object, owner As dynamic) As Object
    photo = CreateObject("roAssociativeArray")
    photo.http=http
    photo.xml=xml
    photo.owner=owner
    photo.GetTitle=function():return m.xml@title:end function
    photo.GetID=function():return m.xml@id:end function
    photo.GetOwner=pGetOwner
    photo.GetURL=pGetURL
    return photo
End Function


Function pGetOwner() As String
	if m.owner<>invalid return m.owner
	return m.xml@owner
End Function


Function pGetURL() As String
	a=m.xml.GetAttributes()
	url="http://farm"+a.farm+".static.flickr.com/"+a.server+"/"+a.id+"_"+a.secret+".jpg"
	return url
End Function
```
----
developers\developers\brightscript\language-reference.md
# Language Reference

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

The following are some general characteristics of BrightScript, as compared to other common scripting languages:

*   BrightScript is not case sensitive.
    
*   Statement syntax is similar to Python, Basic, Ruby, and Lua (and dissimilar to C).
    
*   Like JavaScript and Lua, objects and named data-entry structures are associative arrays.
    
*   BrightScript supports dynamic typing (like JavaScript) and declared types (like C and Java).
    
*   Similar to .Net and Java, BrightScript uses "interfaces" and "components" (i.e. objects).
    

BrightScript code is compiled into bytecode that is run by an interpreter. The compilation step occurs every time a script is loaded and run. Similar to JavaScript, there is no separate compilation step that results in a saved binary file.

BrightScript and its component architecture are written in 100% C for speed, efficiency, and portability. Since many embedded processors do not have floating-point units, BrightScript makes extensive use of the "integer" type. Unlike some languages (including JavaScript), BrightScript only uses floating point numbers when necessary.
----
developers\developers\brightscript\object-reference\brightscript-core-objects\roarray.md
# roArray

This object stores objects in a continuous array of memory locations. Since an *roArray* contains BrightScript components, and there are object wrappers for most intrinsic data types, entries can either be different types or all of the same type. 

Object Creation: The *roArray* object is created with two parameters. 

```
CreateObject("roArray", size As Integer, resize As Boolean)
```

*   `size`: The initial number of entries allocated for the array.
    
*   `resize`: If true, the array will be resized larger to accommodate more entries if needed. If the array is large, this process might take some time.
    

The [DIM](../../../brightscript/language-reference/program-statements.md) statement may be used instead of the `CreateObject()` function to create a new array. The `DIM` statement can be advantageous because it automatically creates array-of-array structures for multi-dimensional arrays. 

## ifArray

##### Peek() As Dynamic

Returns the last (highest index) array entry without removing it.

##### Pop() As Dynamic

Returns the last (highest index) entry and removes it from the array.

##### Push(entry As Dynamic)

Adds a new highest-index entry to the end of the array.

##### Shift() As Dynamic

Removes index zero from the array and shifts all other entries down by one unit.

##### Unshift(entry As Dynamic)

Adds a new index zero to the array and shifts all other entries up by one unit.

##### Delete(index As Integer) As Boolean

Deletes the indicated array entry and shifts all above entries down by one unit.

##### Count() As Integer

Returns the length of the array (i.e. the index of the highest entry in the array plus one).

##### Clear()

Deletes every entry in the array.

##### Append(array As roArray)

Appends one *roArray* to another. If the passed *roArray* contains entries that were never set to a value, they are not appended.

> [!NOTE]
> The two appended objects must be of the same type.

## ifEnum

##### Reset()

Resets the position to the first element of enumeration.

##### Next() As Dynamic

Returns a typed value at the current position and increments the position.

##### IsNext() As Boolean

Returns True if there is a next element.

##### IsEmpty() As Boolean

Returns True if there is not an exact statement.

## ifArrayGet

##### GetEntry(index As Integer) As Dynamic

Returns an array entry of a given index. Entries start at zero. If the entry at the specified index has not been set, this method will return Invalid.

## ifArraySet

##### SetEntry(a As Integer, b As Dynamic)

Sets an entry of a given index to the passed type value.
----
developers\developers\brightscript\object-reference\brightscript-core-objects\roassociativearray.md
# roAssociativeArray

This object allows you to store objects in an associative array (also known as a map, dictionary, or hash table), a data structure that associates objects with string keys. 

> [!NOTE]
> Using nested `FOR EACH` loops to iterate over the same *roAssociativeArray* instance can lead to unexpected behavior. See the [FOR EACH statement description](../../../brightscript/language-reference/program-statements.md) for more details.

The *roAssociativeArray* object is created with no parameters: 

```
CreateObject("roAssociativeArray")
```

Alternatively, an associative array can be created using brackets:

```
aa1 = {}
aa2 = {key1:"value", key2: 55, key3: 5+3 }
```

## ifEnum

##### Reset() As Void

Resets the position to the first element of enumeration.

##### Next() As Dynamic

Returns a typed value at the current position and increments the position.

##### IsNext() As Boolean

Returns `true` if there is a next element.

##### IsEmpty() As Boolean

Returns `true` if the associative array contains no elements.

## ifAssociativeArray

##### AddReplace(key As String, value As Object) As Void

Adds a new entry to the associative array, associating the supplied object with the supplied key string. Only one object may be associated with a key, so any existing object linked to that key is discarded. This method is always case-sensitive when creating keys, whereas object-literal syntax (e.g. `aa={bright:"Sign"}`) is case-insensitive when creating keys unless `SetModeCaseSensitive()` is called.

##### Lookup(key As String) As Dynamic

Looks up the specified key and returns the associated object. If there is no object associated with the key string, then this method will return `Invalid`.

> [!TIP]
> **Tip**
> In many cases, the [Dot Operator](../../../brightscript/language-reference/operators.md) can be used as shorthand for the `Lookup()` and `AddReplace()` methods when working with associative arrays.

##### DoesExist(key As String) As Boolean

Looks up the specified key in the associative array. If the key exists, `true` is returned; otherwise, `false` is returned.

##### Delete(key As String) As Boolean

Looks for an object in the associative array linked to the specified key. If there is such an object, it is deleted and `true` is returned; otherwise, `false` is returned.

##### Clear() As Void

Removes all objects from the associative array.

##### SetModeCaseSensitive() As Void

Makes all subsequent actions case sensitive. All lookups and created keys (with the exception of the `AddReplace()` method) are case insensitive by default.

##### LookupCi(key As String) As Dynamic

Looks for an object in the array associated with the specified key. This method functions similarly to `Lookup()`, with the exception that key comparisons are always case insensitive, regardless of case mode.

##### Append(aa As roAssociativeArray) As Void

Appends a second associative array to the first.

## Examples

```
aa = CreateObject("roAssociativeArray") 
aa.AddReplace("Bright", "Sign")
aa.AddReplace("TMOL", 42) 
print aa.Lookup("tmol")
print aa.Lookup("bright") 
```

The above script returns the following: 

```
42
Sign
```

Alternatively, you can use the [Dot Operator](../../../brightscript/language-reference/operators.md) in place of the `AddReplace()` and `Lookup()` methods:

```
aa = {}
aa.bright = "Sign"
aa.tmol = 42 
print aa.tmol
print aa.bright
```

You can also specify an associative array as a multiline object literal:

```
aa = {
bright : "Sign",
tmol : 42,
pie : 3.14
}

```
----
developers\developers\brightscript\object-reference\brightscript-core-objects\roboolean.md
# roBoolean

This is the object equivalent of the Boolean intrinsic type. It is useful in the following situations:

*   **When an object is needed instead of an intrinsic value**: For example, if a Boolean is added to *roList*, it will be automatically wrapped in an *roBoolean* object by the language interpreter. When a function that expects a BrightScript component as a parameter is passed a Boolean, BrightScript automatically creates the equivalent BrightScript component.
    
*   **When an object exposes the** ***ifBoolean*** **interface**: That object can then be used in any expression that expects an intrinsic value.
    

## ifBoolean 

##### GetBoolean() As Boolean

##### SetBoolean(a As Boolean

#####
----
developers\developers\brightscript\object-reference\brightscript-core-objects\robytearray.md
# roByteArray

This object contains functions for converting strings to or from a byte array, as well as to or from ASCII hex or ASCII base64. 

> [!NOTE]
> If you are converting a byte array to a string, and the byte array contains a zero, the string conversion will end at that point.

The byte array will automatically resize to become larger as needed. If you wish to disable this behavior, use the `SetResize()` method. If an uninitialized index is read, Invalid is returned. 

Since *roByteArray* supports the *ifArray* interface, it can be accessed with the `[]` array operator. The byte array is always accessed as unsigned bytes while this interface is being used. This object also supports the *ifEnum* interface, and so can be used with a `FOR EACH` statement. 

The JavaScript equivalent is `Blob()`. Note that JavaScript now has [typed arrays](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays) (for example, [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)) . 

## ifByteArray

##### WriteFile(file\_path As String) As Boolean

Writes the bytes contained in the byte array to the specified file. This method returns True if successful.

##### WriteFile(file\_path As String, start\_index As Integer, length As Integer) As Boolean

Writes a subset of the bytes contained in the byte array to the specified file. This method writes `length` bytes, beginning at `start_index` of the byte array.

##### ReadFile(file\_path As String) As Boolean

Reads the specified file into the byte array. This operation will discard any data currently contained in the byte array.

##### ReadFile(file\_path As String, start\_index As Integer, length As Integer) As Boolean

Reads a section of the specified file into the byte array. This method reads `length` bytes, beginning at `start_index` of the file. This operation will discard any data currently contained in the byte array.

##### AppendFile(file\_path As String) As Boolean

Appends the contents of the byte array to the specified file.

##### SetResize(minimum\_allocation\_size As Integer, autoresize As Boolean)

Expands the size of the byte array to the `minimum_allocation_size` if it is less than the `minimum_allocation_size`. This method also accepts a Boolean parameter that specifies whether the byte array should be resized automatically or not.

##### ToHexString() As String

Returns a hexadecimal string representation of the contents of the byte array. Each byte is represented as two hex digits.

##### FromHexString(hex\_string As String)

Writes the contents of the passed hexadecimal string to the byte array. The passed string must contain an even number of hex digits. This operation will discard any data currently contained in the byte array.

##### ToBase64String() As String

Returns the contents of the byte array as a base64-formatted string.

##### FromBase64String(base\_64\_string As String)

Writes the contents of a valid base64-formatted string to the byte array. This operation will discard any data currently contained in the byte array.

##### ToAsciiString() As String

Returns the contents of the byte array as an ASCII-formatted string.

##### FromAsciiString(ascii\_string As String)

Writes the contents of a valid ASCII-formatted string to the byte array. This operation will discard any data currently contained in the byte array.

##### GetSignedByte(index As Integer) As Integer

Returns the signed byte at the specified zero-based index in the byte array. To read an unsigned byte within a byte array, use the *ifArrayGet.GetEntry()* method or the `[]` array operator.

##### GetSignedLong(index As Integer) As Integer

Retrieves the integer located at the specified long-word index of the byte array. Note that this method cannot accept a byte index as its parameter.

##### IsLittleEndianCPU() As Boolean

Returns True if the CPU architecture is little-endian.

## ifArray

##### Peek() As Dynamic

Returns the last (highest index) array entry without removing it.

##### Pop() As Dynamic

Returns the last (highest index) entry and removes it from the array.

##### Push(entry As Dynamic)

Adds a new highest index entry to the end of the array.

##### Shift() As Dynamic

Removes index zero from the array and shifts all other entries down by one unit.

##### Unshift(entry As Dynamic)

Adds a new index zero to the array and shifts all other entries up by one unit.

##### Delete(index As Integer) As Boolean

Deletes the indicated array entry and shifts all above entries down by one unit.

##### Count() As Integer

Returns the index of the highest entry in the array plus one (i.e. the length of the array).

##### Clear()

Deletes every entry in the array.

##### Append(array As roArray)

Appends one *roArray* to another. If the passed *roArray* contains entries that were never set to a value, they are not appended.

> [!NOTE]
> The two appended objects must be of the same type.

## ifEnum

##### Reset()

Resets the position to the first element of enumeration.

##### Next() As Dynamic

Returns a typed value at the current position and increment position.

##### IsNext() As Boolean

Returns True if there is a next element.

##### IsEmpty() As Boolean

Returns True if there is not an exact statement.

## ifArrayGet

##### GetEntry(index As Integer) As Dynamic

Returns an array entry of a given index. Entries start at zero. If this method attempts to fetch an entry that has not been set, it will return Invalid.

## ifArraySet

##### SetEntry(index As Integer, entry As Dynamic)

Sets an entry of a given index to the passed type value.
----
developers\developers\brightscript\object-reference\brightscript-core-objects\rodouble-rointrinsicdouble.md
# roDouble, roIntrinsicDouble

## ifDouble

##### GetDouble() As Double

##### SetDouble(a As Double)
----
developers\developers\brightscript\object-reference\brightscript-core-objects\rofunction.md
# roFunction

## ifFunction

##### GetSub() As Function

##### SetSub(value As Function)
----
developers\developers\brightscript\object-reference\brightscript-core-objects\roint-rofloat-rostring.md
# roInt, roFloat, roString

The [intrinsic types](http://docs.brightsign.biz/display/DOC/Variables%2C+Literals%2C+and+Types#Variables,Literals,andTypes-Types) `Int32`, `Float`, and `String` have object and interface equivalents. These are useful in the following situations:

*   An object is needed instead of a typed value (e.g. the *roList* object maintains a list of objects). When a function that expects a BrightScript object as a parameter is passed an integer, float, or string, BrightScript automatically creates the equivalent object.
    
*   If any object exposes the *ifInt*, *ifFloat*, or *ifString* interfaces, that object can be used in any expression that expects a typed value. For example, an [*roVideoEvent*](../../object-reference/presentation-and-widget-objects/rovideoevent-roaudioevent.md) can be used as an integer with a value representing the event ID.
    

**Integer Operations**

If "o" is of type *roInt*, then these statements will have the following effects:

*   `print o`: Prints the value of `o.GetInt()`
    
*   `i%=o`: Assigns the integer `i%` the value of `o.GetInt().`
    
*   `k=o`: Presumably `k` is automatically typed, so it becomes another reference to the *roInt* `o.`
    
*   `o=5`: This is NOT the same as `o.SetInt(5)`. Instead it releases `o`, changes the type of `o` to *roINT32* (`o` is automatically typed), and assigns it to 5.
    

## ifInt

*roInt* contains the *ifInt* interface, which provides the following:

##### GetInt() As Integer

Returns the integer value of the object. 

##### SetInt(value As Integer) As Void

Sets the integer value of the object. 

## ifIntOps

*roInt* also contains the *ifIntOps* interface, which provides the following:

##### ToStr() As String

Returns the integer value as a string. A space is not appended to the front for positive numbers.

## ifFloat

*roFloat* contains *the ifFloat* interface, which provides the following:

##### GetFloat() As Float

Returns the float value of the object. 

##### SetFloat(value As Float) As Void

Sets the float value of the object. 

## ifString

*roString* contains the *ifString* interface, which provides the following:

##### GetString() As String

Returns the string value of the object.

##### SetString(value As String) As Void

Sets the string value of the object.

## ifStringOps

*roString* also contains the *ifStringOps* interface, which provides the following:

> [!NOTE]
> Some [global functions](../../object-reference/global-functions.md) offer the same functionality as *ifStringOps* methods. The function indexes of *ifStringOps* methods start at zero, while those of global functions start at one.

##### SetString(str As String, str\_len As Integer)

Sets the string value of the object using the specified string and string-length values. This is similar to the `SetSeting()` method, which does not accept a parameter for string length.

##### AppendString(str As String, str\_len As Integer)

Appends to the string value of the object using the specified string and string-length values. This method modifies itself—this can cause unexpected results when you pass an intrinsic string type, rather than a string object.

##### **Example**

```
x="string"
x.ifstringops.appendstring("ddd",3)
print x 'will print 'string' 
y=box("string")
y.ifstringops.appendstring("ddd",3)
print y 'will print 'stringddd'
```

##### Len() As Integer

Returns the number of characters in a string.

##### GetEntityEncode() As String

Returns the string with certain characters replaced with HTML entity encoding sequences:

| Character | Replaced with |
| --- | --- |
| " (double quote) | &quot; |
| ' (single quote) | &apos; |
| <   | &lt; |
| \>  | &gt; |
| &   | &amp; |

##### Tokenize(delim As String) As roList

Splits a string into substrings using the specified delimiter character(s). The `delim` parameter can contain one or more characters to treat as delimiters. If the string object contains multiple contiguous delimiters, they will be treated as a single delimiter. This method returns the substrings as an *roList* object; the delimiters are not returned with the substrings.

##### **Example**

```
BrightScript> s = "one&&two"
BrightScript> print s.Tokenize("&")
one
two
```

##### Trim() As String

Returns the string with any leading and trailing whitespace characters (e.g. TAB, LF, CR, VT, FF, NO-BREAK SPACE) removed.

##### ToInt() As Integer

Returns the value of the string as an integer number.

##### ToFloat() As Float

Returns the value of the string as a floating point number.

##### Left(n As Integer) As String

Returns the first `n` characters of the string.

##### Right(n As Integer) As String

Returns the last `n` characters of the string.

##### Mid(start\_index As Integer) As String

Returns a subset of the string that begins at the zero-based `start_index` and terminates at the end of the string.

##### Mid(start\_index As Integer, n As Integer) As String

Returns a subset of the string, beginning at the zero-based `start_index` and consisting of `n` characters. If the string contains fewer than `n` characters after the specified `start_index`, this method will return all characters after the `start_index`.

##### Instr(substring As String) As Integer 

Returns the zero-based index of the first occurence of the substring in the string. If the substring does not occur in the string, this method returns -1. 

##### Instr(start\_index As Integer, substring As String) As Integer

Returns the zero-based index of the first occurence of the substring after the specified `start_index` in the string. If the substring does not occur after the specified `start_index`, this method returns -1.

> [!TIP]
> **Tip**
> `Instr()` is also offered as a [global function](../../object-reference/global-functions.md) (note that the string index of the global function starts at 1).

## Examples

```
BrightScript> o=CreateObject("roInt")
BrightScript> o.SetInt(555)
BrightScript> print o
555
BrightScript> print o.GetInt()
555
BrightScript> print o-55
500 
```

An integer value of 5 is converted to type *roInt* automatically because the `AddTail()` method expects a BrightScript object as its parameter:

```
BrightScript> list=CreateObject("roList")
BrightScript> list.AddTail(5)
BrightScript> print type(list.GetTail()) 
```

Here the `ListDir()` method returns an *roList* object containing *roString* objects:

```
BrightScript> l=ListDir("/")
BrightScript> for i=1 to l.Count():print l.RemoveHead():next
test_movie_3.vob
test_movie_4.vob
test_movie_1.vob
test_movie_2.vob
```
----
developers\developers\brightscript\object-reference\brightscript-core-objects\rojre.md
# roJRE

This object allows you to load Java applications using the Java Runtime Environment (JRE) on the player. Java Runtime is no longer built into the firmware and roJRE is not invokable unless you run a BSFW file extension to add JRE to the player. After you install JRE, you must then invoke it to use roJRE. Contact BrightSign customer support to get the BSFW file extension.

The JRE uses OpenJDK 8 and is available on XTx44/43, XDx34/33, HDx24/23, LS424/423, and 4Kx42 models.

Object Creation: The *roJRE* object is instantiated with the Java package filename and an optional associative array that specifies JVM system properties and program arguments. You can use the `Type()` global function to determine if the package was successfully loaded.

```
CreateObject("roJRE", filename As String, options As roAssociativeArray)
```

The associative array can contain two entries:

*   `defines`: An associative array specifying system properties.
    
*   `arguments` : An array specifying command-line arguments.
    

All property/argument values must be passed as strings. Note that associative-array keys are case insensitive (i.e. converted to all lowercase) by default; use the *roAssociativeArray.SetModeCaseSensitive()* method to enable case-sensitive keys.

##### **Example**

```
props = {}
props.SetModeCaseSensitive()
props["SYS_PROP_1"] = "system prop 1"
props["SYS_PROP_2"] = "system prop 2"
props["java.io.tmpdir"] = "/var/tmp"
 
jre = CreateObject("roJRE", "app.jar", { defines: props, arguments: [ "arg 1", "arg 2" ] })
if type(jre)="roJRE" then
	print "Successfully started Java runtime"
else
	print "Unable to start Java runtime"
end if
```
----
developers\developers\brightscript\object-reference\brightscript-core-objects\rolist.md
# roList

This object functions as a general-purpose, doubly linked list. It can be used as a container for arbitrary-length lists of BrightSign objects. The array operator \[ \] can be used to access any element in an ordered list. 

## ifList

##### Count() As Integer

Returns the number of elements in the list.

##### ResetIndex() As Boolean

Resets the current index or position in the list to the head element.

##### AddTail(obj As Object) As Void

Adds a typed value to the tail of the list.

##### AddHead(obj As Object) As Void

Adds a typed value to the head of the list.

##### RemoveIndex() As Object

Removes an entry from the list at the current index or position and increments the index or position in the list. It returns Invalid when the end of the list is reached.

##### GetIndex() As Object

Retrieves an entry from the list at the current index or position and increments the index or position in the list. It returns Invalid when the end of the list is reached.

##### RemoveTail() As Object

Removes the entry at the tail of the list.

##### RemoveHead() As Object

Removes the entry at the head of the list.

##### GetTail() As Object

Retrieves the entry at the tail of the list and keeps the entry in the list.

##### GetHead() As Object

Retrieves the entry at the head of the list and keeps the entry in the list.

##### Clear()

Removes all elements from the list.

## ifEnum

##### Reset()

Resets the position to the first element of enumeration.

##### Next() As Dynamic

Returns a typed value at the current position and increment position.

##### IsNext() As Boolean

Returns True if there is a next element.

##### IsEmpty() As Boolean

Returns True if there is not an exact statement.

## ifArray

##### Peek() As Dynamic

Returns the last (highest index) list entry without removing it.

##### Pop() As Dynamic

Returns the last (highest index) entry and removes it from the list.

##### Push(entry As Dynamic)

Adds a new highest-index entry to the end of the list.

##### Shift() As Dynamic

Removes index zero from the list and shifts all other entries down by one unit.

##### Unshift(entry As Dynamic)

Adds a new index zero to the list and shifts all other entries up by one unit.

##### Delete(index As Integer) As Boolean

Deletes the indicated list entry and shifts all above entries down by one unit.

##### Count() As Integer

Returns the length of the list (i.e. the index of the highest entry in the list plus one).

##### Clear()

Deletes every entry in the list.

##### Append(list As roList)

Appends one *roList* to another. If the passed *roList* contains entries that were never set to a value, they are not appended.

> [!NOTE]
> The two appended objects must be of the same type.

## ifArrayGet 

##### GetEntry(a As Integer) As Dynamic

Returns a list entry of a given index. Entries start at zero. If an entry that has not been set is fetched, Invalid is returned.

## ifArraySet

##### SetEntry(a As Integer, b As Dynamic)

Sets an entry of a given index to the passed type value.

## Example

```
list = CreateObject("roList")
list.AddTail("a")
list.AddTail("b")
list.AddTail("c")
list.AddTail("d") 
list.ResetIndex()
x= list.GetIndex()
while x <> invalid
print x
x = list.GetIndex()
end while 
print list[2]
```
----
developers\developers\brightscript\object-reference\brightscript-core-objects\romessageport.md
# roMessagePort

A message port is the destination where messages (events) are sent. See the explanation of [Event Loops](../../object-reference.md) for more details. You do not call these functions directly when using BrightScript. Instead, use the `Wait()` [global function](../../object-reference/global-functions.md).

## ifMessagePort

##### GetMessage() As Object

Returns the event object if available. Otherwise, Invalid is returned. In either case, this method returns immediately without waiting.

##### WaitMessage(timeout As Integer) As Object

Waits until an event object is available or the specified amount of milliseconds have passed. When an event object becomes available, it will be returned. If the timeout is reached, Invalid will be returned. Passing a zero timeout value instructs this method to wait indefinitely for a message.

You can also use the `Wait()` global function to retrieve event objects over a specified interval. The following two statements have the same effect:

```
msg = port.WaitMessage(timeout)
msg = wait(timeout, port)
```

##### PostMessage(msg As Object) As Void  
 

##### PeekMessage() As Object

Returns the event object if available (or Invalid if otherwise), but does not remove the event object from the message queue; a later call to `GetMessage()`, `WaitMessage()`, or `PeekMessage()` will return the same event object. 

##### SetWatchdogTimeout(seconds As Integer) As Integer

Enables a watchdog timeout on the *roMessagePort* instance if passed a positive integer. The watchdog will crash and reboot the player if the script does not call `GetMessage()` or `WaitMessage()` after the specified number of seconds (the timeout is blocked while the script waits on the message port). Passing zero to this method disables the watchdog.

Some BrightScript operations (e.g. *roAssetRealizer.Realize()*) can take a long time to return. In these cases, it may be better to use a short watchdog timeout in general but switch to a longer timeout before calling such operations.

The watchdog timeout only applies to its associated *roMessagePort* instance, so enabling the watchdog on one *roMessagePort* instance, then calling `WaitMessage()` on another, may cause the watchdog to trigger unexpectedly. The watchdog will not trigger while waiting on the BrightScript debugger prompt. 

##### DeferWatchdog(seconds As Integer)

Defers the watchdog timeout set by the `SetWatchdogTimeout()` method. Passing an integer to this method defers the timeout for the specified number of seconds.

##### DeferWatchdog()

Defers the watchdog timeout by the amount of seconds set in the `SetWatchdogTimeout()` method.

> [!NOTE]
> Calls to either `DeferWatchdog()` method cannot cause the watchdog to trigger earlier than it already will. For example, calling `DeferWatchdog(100)` followed by `DeferWatchdog(10)` will still cause the watchdog to trigger after 100 seconds.

## ifEnum

##### Reset()

Resets the position to the first element of enumeration.

##### Next() As Dynamic

Returns the typed value at the current position and increment position.

##### IsNext() As Boolean

Returns True if there is a next element.

##### IsEmpty() As Boolean

Returns True if there is not a next element.
----
developers\developers\brightscript\object-reference\brightscript-core-objects\roregex.md
# roRegex

This object allows the implementation of the regular-expression processing provided by the PCRE library. The JavaScript equivalent is `RegExp()`.

This object is created with a string to represent the matching-pattern and a string to indicate flags that modify the behavior of one or more matching operations: 

```
CreateObject("roRegex", "[a-z]+", "i") 
```

The match string (in the example above, `"[a-z]+"`, which matches all lowercase letters) can include most Perl compatible regular expressions found in the [PCRE documentation](http://pcre.org/). 

This object supports any combination of the following behavior flags (in the example above, "i", which can be modified to match both uppercase and lowercase letters):

*   `"i"`: Case-insensitive match mode.
    
*   `"m"`: Multiline mode. The start-line ("^") and end-line ("$") constructs match immediately before or after any newline in the subject string. They also match at the absolute beginning or end of a string.
    
*   `"s"`: Dot-all mode, which includes a newline in the ".\*" regular expression. This modifier is equivalent to "/s" in Perl.
    
*   `"x"`: Extended mode, which ignores whitespace characters except when escaped or inside a character class. This modifier is equivalent to "/x" in Perl.
    

## ifRegex

##### IsMatch(string As String) As Boolean

Returns True if the string is consistent with the matching pattern.

##### Match(string As String) As roArray

Returns an *roArray* of matched substrings from the string. The entire match is returned in the form `array[0]`.This will be the only entry in the array if there are no parenthetical substrings. If the matching pattern contains parenthetical substrings, the relevant substrings will be returned as an array of length n+1, where `array[0]` is the entire match and each additional entry in the array is the match for the corresponding parenthetical expression.

##### Replace(string As String, subset As String) As String

Replaces the first occurrence of a matching pattern in the string with the subset and returns the result.

The subset may contain numbered back-references to parenthetical substrings.

##### **Example**

```
 > r = CreateObject("roRegex", "(\d+)\s+(\w+)", "")
 > ? r.Replace("123 abc", "word:\2 number:\1")
 > word:abc number:123
```

##### ReplaceAll(string As String, subset As String) As String

Replaces the all occurrences of a matching pattern in the string with the subset and returns the result.

##### **Example**

```
 > r = CreateObject("roRegex", "a", "i")
 > ? r.ReplaceAll("Abracadabra", "x")
 xbrxcxdxbrx
```

##### Split(string As String) As roList

Uses the matching pattern as a delimiter and splits the string on the delimiter boundaries. The function returns an *roList* of strings that were separated by the matching pattern in the original string.
----
developers\developers\brightscript\object-reference\brightscript-core-objects\roxmlelement.md
# roXMLElement

This object is used to contain an XML tree. The JavaScript equivalent is `DOMParser()`.

The *roXMLElement* object is created with no parameters: 

```
CreateObject("roXMLElement")
```

The following examples illustrate how XML elements are parsed in BrightScript:

```
<tag1>This is example text</tag1>
```

*   Name = tag1
    
*   Attributes = Invalid
    
*   Body = *roString* containing "This is example text"
    

```
<tag2 caveman="barney"/>
```

*   Name = tag2
    
*   Attributes = *roAssociativeArray* with one entry, `{caveman, barney}`
    
*   Body = Invalid
    

If the tag contains other tags, the body will be of type *roXMLList*.

To generate XML content, create an *roXMLElement* and call the `SetBody()` and `SetName()` methods to build it–then call the `GenXML()` method to generate it.

##### **Example**

```
root.SetName("myroot")
root.AddAttribute("key1","value1")
root.AddAttribute("key2","value2")
ne=root.AddBodyElement()
ne.SetName("sub")
ne.SetBody("this is the sub1 text")
ne=root.AddBodyElement()
ne.SetName("subelement2")
ne.SetBody("more sub text")
ne.AddAttribute("k","v")
ne=root.AddElement("subelement3")
ne.SetBody("more sub text 3")
root.AddElementWithBody("sub","another sub (#4)")
PrintXML(root, 0)
print root.GenXML(false)
```

## ifXMLElement

##### GetBody() As Object  
 

##### GetAttributes() As Object  
 

##### GetName() As String  
 

##### GetText() As String  
 

##### GetChildElements() As Object  
 

##### GetNamedElements(a As String) As Object  
 

##### GetNamedElementsCi(a As String) As Object  
 

##### SetBody(a As Object)

Generates an *roXMLList* for the body if needed. The method then adds the passed item (which should be an *roXMLElement* tag).

##### AddBodyElement() As Object  
 

##### AddElement(a As String) As Object  
 

##### AddElementWithBody(a As String, b As Object) As Object  
 

##### AddAttribute(a As String, b As String)  
 

##### SetName(a As String)  
 

##### Parse(a As String) As Boolean

Parses the XML content passed to it. In the event of failure, this method returns False. However, it also populates *roXMLElement* with whatever text could be successfully parsed. To avoid passing along erroneous strings, it is always best to have the script check the return value of `Parse()` before using them.

##### GenXML(a As Boolean) As String

Generates XML content. This method takes a single Boolean parameter, indicating whether or not the XML should have an `<?xml …>` tag at the top.

##### Clear() As Void  
 

##### GenXMLHdr(a As String) As String  
 

##### IsName(a As String) As Boolean  
 

##### HasAttribute(a As String) As Boolean  
 

##### ParseFile(a As String) As Boolean

## Example

This subroutine example prints out the contents of an *roXMLElement* tree:

```
PrintXML(root, 0)

Sub PrintXML(element As Object, depth As Integer)
    print tab(depth*3);"Name: ";element.GetName()
    if not element.GetAttributes().IsEmpty() then
        print tab(depth*3);"Attributes: ";
        for each a in element.GetAttributes()
            print a;"=";left(element.GetAttributes()[a], 20);
            if element.GetAttributes().IsNext() then print ", ";
        end for
        print
    end if
    if element.GetText()<>invalid then
        print tab(depth*3);"Contains Text: ";left(element.GetText(), 40)
    end if
    if element.GetChildElements()<>invalid
        print tab(depth*3);"Contains roXMLList:"
        for each e in element.GetChildElements()
            PrintXML(e, depth+1)
        end for
    end if
    print
end sub
```
----
developers\developers\brightscript\object-reference\brightscript-core-objects\roxmllist.md
# roXMLList

The JavaScript equivalent to this object is `DOMParser()`.

## ifXMLList

##### Simplify() As Object

Returns an *roXmlElement* if the list contains exactly one element. Otherwise, it will return itself.

##### GetAttributes() As Object  
 

##### GetText() As String  
 

##### GetChildElements() As Object  
 

##### GetNamedElements(a As String) As Object

Returns a new XMLList that contains all *roXmlElements* that match the name of the passed element. This action is the same as using the dot operator on an *roXmlList*.

##### GetNamedElementsCi(a As String) As Object

## ifList

##### Count() As Integer

Returns the number of elements in the list.

##### ResetIndex() As Boolean

Resets the current index or position in the list to the head element.

##### AddTail(obj As Object) As Void

Adds a typed value to the tail of the list.

##### AddHead(obj As Object) As Void

Adds a typed value to the head of the list.

##### RemoveIndex() As Object

Removes an entry from the list at the current index or position and increments the index or position in the list. It returns Invalid when the end of the list is reached.

##### GetIndex() As Object

Retrieves an entry from the list at the current index or position and increments the index or position in the list. It returns Invalid when the end of the list is reached.

##### RemoveTail() As Object

Removes the entry at the tail of the list.

##### RemoveHead() As Object

Removes the entry at the head of the list.

##### GetTail() As Object

Retrieves the entry at the tail of the list and keeps the entry in the list.

##### GetHead() As Object

Retrieves the entry at the head of the list and keeps the entry in the list.

##### Clear() As Void

Removes all elements from the list.

## ifEnum

##### Reset()

Resets the position to the first element of enumeration.

##### Next() As Dynamic

Returns a typed value at the current position and increment position.

##### IsNext() As Boolean

Returns True if there is a next element.

##### IsEmpty() As Boolean

Returns True if there is not an exact statement.

## ifArray

##### Peek() As Dynamic

Returns the last (highest index) array entry without removing it.

##### Pop() As Dynamic

Returns the last (highest index) entry and removes it from the array.

##### Push(a As Dynamic)

Adds a new highest index entry to the end of the array.

##### Shift() As Dynamic

Removes index zero from the array and shifts all other entries down by one unit.

##### Unshift(a As Dynamic)

Adds a new index zero to the array and shifts all other entries up by one unit.

##### Delete(a As Integer) As Boolean

Deletes the indicated array entry and shifts all above entries down by one unit.

##### Count() As Integer

Returns the index of the highest entry in the array plus one (i.e. the length of the array).

##### Clear() As Void

Deletes every entry in the array.

##### Append(a As Object) As Void

Appends one *roArray* to another. If the passed *roArray* contains entries that were never set to a value, they are not appended.

> [!NOTE]
> The two appended objects must be of the same type.

## ifArrayGet 

##### GetEntry(a As Integer) As Dynamic

Returns an array entry of a given index. Entries start at zero. If an entry that has not been set is fetched, Invalid is returned.

## ifArraySet

##### SetEntry(a As Integer, b As Dynamic) As Void

Sets an entry of a given index to the passed type value.
----
developers\developers\brightscript\object-reference\brightscript-core-objects.md
# BrightScript Core Objects

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

This section describes objects that provide core BrightScript functionality.

*   [roArray](./brightscript-core-objects/roarray.md)
*   [roAssociativeArray](./brightscript-core-objects/roassociativearray.md)
*   [roBoolean](./brightscript-core-objects/roboolean.md)
*   [roByteArray](./brightscript-core-objects/robytearray.md)
*   [roDouble, roIntrinsicDouble](./brightscript-core-objects/rodouble-rointrinsicdouble.md)
*   [roFunction](./brightscript-core-objects/rofunction.md)
*   [roInt, roFloat, roString](./brightscript-core-objects/roint-rofloat-rostring.md)
*   [roJRE](./brightscript-core-objects/rojre.md)
*   [roList](./brightscript-core-objects/rolist.md)
*   [roMessagePort](./brightscript-core-objects/romessageport.md)
*   [roRegex](./brightscript-core-objects/roregex.md)
*   [roXMLElement](./brightscript-core-objects/roxmlelement.md)
*   [roXMLList](./brightscript-core-objects/roxmllist.md)
----
developers\developers\brightscript\object-reference\content-management-objects\roassetcollection.md
# roAssetCollection

This object is used to represent a collection of assets.

Object Creation: The *roAssetCollection* object is created with no parameters.

```
CreateObject("roAssetCollection")
```

You can populate an asset collection with individual calls to `AddAsset()` or `AddAssets()`. You can also populate an asset collection using the *roSyncSpec.GetAssets()* method, as shown below:

```
assetCollection = CreateObject("roAssetCollection")
 
localCurrentSync = CreateObject("roSyncSpec")
if localCurrentSync.ReadFromFile("local-sync.xml") then
	assetCollection = localCurrentSync.GetAssets("download")
endif
```

## ifFailureReason

##### GetFailureReason() As String

Returns additional information if a method fails. 

## ifAssetCollection 

##### AddAsset(asset\_info As Dynamic) As Boolean

Adds a single asset from an associative array or JSON-formatted string. If the argument is a string, it should match the format used for a single asset in a JSON sync spec. Returns true to indicate success and false to indicate failure. If false is returned more detailed information is available by calling the `GetFailureReason` method.

##### AddAssets(asset\_info\_array As Dynamic) As Boolean

Adds multiple assets from an enumerable object (an *roList*, *roArray*, or string containing a JSON-formatted array) that contains compatible associative arrays. Returns true to indicate success and false to indicate failure. If false is returned more detailed information is available by calling the `GetFailureReason` method.

##### GetAssetList() As roList

Returns an *roList* instance containing associative arrays of asset metadata. This method is not efficient and is, therefore, recommended for debugging and diagnostic purposes only.

Each associative array contains the following:

|     |     |     |     |
| --- | --- | --- | --- |
| name | String | Required | The name of the asset. For a file to be realized, it must have a valid filename (i.e. no slashes). |
| link | String | Required | The download location of the asset |
| size | Integer/String | Optional | The size of the asset. Use a string if you want to specify a number that is too large to fit into an integer (this allows file sizes larger than 2 GB). |
| hash | String | Optional | A string in the form of "hash\_algorithm:hash". See the next table for available hash algorithms. |
| change\_hint | String | Optional | Any string that will change in conjunction with the file contents. This is not necessary if the link or hash is supplied and always changes. |
| auth\_inherit | Boolean | Optional | Indication of whether or not this asset uses *roAssetFetcher* authentication information. The default is set to True. |
| auth\_user | Boolean | Optional | User to utilize for authentication when downloading only this asset. This automatically disables "auth\_inherit". |
| auth\_password | Boolean | Optional | Password to use when downloading only this asset. This automatically disables "auth\_inherit". |
| headers\_inherit | Boolean | Optional | The command to pass any header supplier to *roAssetFetcher* when fetching this asset. The default is true. |

> [!CAUTION]
> **Important**
> Any "optional" fields that are specified when populating the pool must also be specified when retrieving assets from the pool (i.e. they become "mandatory" once they are used for an asset). For example, if the hash value is specified when fetching into the pool, then it must also be specified when attempting to refer to files in the pool.

Hash algorithms:

|     |     |
| --- | --- |
| sha1 | If a sha1 is available, you can validate the hash as the file is downloaded. If such a hash is available, it should be used. The link and change\_hint properties have no effect on the pool file name, so the file is shared even if it is downloaded from different locations. |
| besha1 | This algorithm hashes some of the file along with the file size in order to verify the contents. It also moves the link and change\_hint properties into the pool filename. |
| MD5 | Uses the MD5 hash algorithm to validate files. |
| (none) | Without any hash, the file cannot be verified as it is downloaded, and the system will rely on the link and change\_hint properties to give the pool a unique filename. |
----
developers\developers\brightscript\object-reference\content-management-objects\roassetfetcher.md
# roAssetFetcher

This object contains functions for downloading files to the pool. The JavaScript equivalent is [assetpoolfetcher](../../../../developers/player-apis/javascript-apis/assetfetcher.md).

Object Creation: The *roAssetFetcher* object must be passed an *roAssetPool* instance upon creation.

```
CreateObject("roAssetFetcher", pool As roAssetPool)
```

##### **Example**

```
Pool = CreateObject("roAssetPool", "pool")
Fetcher = CreateObject("roAssetFetcher", Pool)
```

## ifAssetFetcher

##### GetFailureReason() As String

Returns an error string if an *roAssetFetcher* method has failed (this is usually indicated by returning False). The error string may help diagnose the failure.

##### SetUserAndPassword(user As String, password As String) As Boolean

Sets the default user and password strings to be used for all download requests that are not otherwise marked using the following attributes: <auth inherit=”no”> or <auth user=”user” password =”password”>.

##### EnableUnsafeAuthentication(enable As Boolean) As Boolean

Supports basic HTTP authentication if True. HTTP authentication uses an insecure protocol, which might allow others to easily determine the password. The *roAssetFetcher* object will still prefer the stronger digest HTTP if it is supported by the server. If this method is False (which is the default setting), it will refuse to provide passwords via basic HTTP authentication, and any requests requiring this authentication will fail.

##### EnableUnsafeProxyAuthentication(enable As Boolean) As Boolean

Supports basic HTTP authentication against proxies if True (which, unlike EnableUnsafeAuthentication(), is the default setting). HTTP authentication uses an insecure protocol, which might allow others to easily determine the password. If this method is False, it will refuse to provide passwords via basic HTTP authentication, and any requests requiring this authentication type will fail.

##### EnableEncodings(enable As Boolean) As Boolean

Enables HTTP compression, which communicates to the server that the system can accept any encoding that the *roAssetFetcher* object is capable of decoding by itself (this behavior is enabled by default). Supported encodings currently include "deflate" and "gzip", which allow for transparent compression of responses. Clients of the *roAssetFetcher* instance see only the decoded data and are unaware of the encoding being used.

##### AsyncDownload(assets As roAssetCollection) As Boolean

Begins populating the asset pool using the files listed in the passed *roAssetCollection* instance. Files that are not already in the pool will be downloaded automatically. Events are raised during the download process to indicate whether individual file downloads have succeeded or failed; finally, a single event will be raised indicating whether the entire asset collection has been downloaded successfully or not. See the *roAssetFetcherEvent* and *roAssetFetcherProgressEvent* entries for more details.

##### AsyncSuggestCache(spec As roAssetCollection) As Boolean 

Begins downloading the required files from the passed *roAssetCollection* instance, then disconnects shortly afterward. If the player is set to use a suitably configured proxy (either globally or via the `SetProxy()` method), then the proxy will continue to download the files, making them readily available for `AsyncDownload()` calls in the future.

This method generates an *roAssetFetcherEvent* message with response code 202 ("Accepted") to indicate success. Other errors will be reported as usual. The final all-files-complete event code will always be -2 ("EVENT\_ALL\_FAILED") because the download does not complete.

##### AsyncCancel() As Boolean

Cancels any pending “Async” requests. Note that, prior to and during this method call, events associated with an asynchronous action may be queued. No more events will be queued once this call returns. We recommend collecting any pending events prior to calling any further “Async” methods on the same object to avoid confusion.

##### EnablePeerVerification(verification As Boolean) As Boolean

Enables checking of TLS/SSL certificates. This method is set to `true` by default. Disabling peer verification allows you to bypass an expired certificate check.

##### EnableHostVerification(verification As Boolean) As Boolean

Enables checking of the TLS/SSL certificate for the correct hostname. This method is set to `true` by default. Disabling host verification allows you to accept a certificate being sent for the wrong hostname.

> [!CAUTION]
> **Important**
> Peer verficiation and host verification are important security checks that prevent "man-in-the-middle" attacks. These features should only be disabled after careful consideration of the security implications.

##### SetCertificatesFile(filename As String) As Boolean

Configures an alternative set of CA certificates for the connection. This method is useful if the connection certificates are signed by a CA that is not on the the default trusted list (for example, if your organization uses a private CA hierarchy that is not signed by a well known root CA). This method replaces the default list, so the passed certificate file must contain all acceptable CA certificates required for the connection.

##### AddHeader(name As String, value As String) As Boolean

Specifies a header that will be passed to HTTP requests made by the *roAssetFetcher* instance. A particular download will not include the header if it has the <headers inherit=”no”> attribute in the sync spec.

##### SetHeaders(headers As roAssociativeArray) As Boolean

Specifies all headers that will be passed to HTTP requests made by the *roAssetFetcher* instance. This method removes any previously set headers. A particular download will not include the headers if it has the <headers inherit=”no”> attribute in the sync spec.

##### SetProxy(proxy As String) As Boolean

Sets the name or address of the proxy server that will be used by the *roAssetFetcher* instance. The proxy string should be formatted as "[http://user:password@hostname](http://user:password@hostname):port". It can contain up to four "\*" characters; each "\*" character can be used to replace one octet from the current IP address. For example, if the IP address is currently 192.168.1.2, and the proxy is set to "proxy-\*-\*", then the player will attempt to use a proxy named "proxy-192.168".

##### SetProxyBypass(hostnames As Array) As Boolean

Exempts the specified hosts from the proxy setting. The passed array should consist of one or more hostnames. The *roAssetFetcher* instance will attempt to reach the specified hosts directly rather than using the proxy that has been specified with the `SetProxy()` method. For example, the hostname "[http://example.com](http://example.com) " would exempt "[http://example.com](http://example.com) ", "[http://example.com:80](http://example.com:80) ", and "[http://www.example.com](http://www.example.com) " from the proxy setting.

##### SetFileProgressIntervalSeconds(interval As Integer) As Boolean

Specifies the interval (in seconds) between progress events when an individual file is being downloaded. Setting the interval to -1 disables all progress events. Setting the interval to 0 specifies that events should be generated as often as possible, though this will slow down the transfer process. If the interval is set to 0 or any positive integer, events will always be generated at the start and end of the file download irrespective of elapsed time. The default interval is 300 seconds.

##### SetFileRetryCount(count As Integer) As Boolean

Specifies the maximum number of times each file download will be retried before moving on to the next file download. The default retry count is five.

##### SetRelativeLinkPrefix(prefix As String) As Boolean

Specifies a prefix that will be appended to the front of relative links in the sync spec. Normally, this method is used to make file:/// URIs drive agnostic, but it can also be used to reduce the size of the sync spec if all files are stored in the same place. Non-relative links are not affected by this method.

##### BindToInterface(interface As Integer) As Boolean

Ensures that the HTTP request goes out over the specified network interface (0 for Ethernet or 1 for WiFi). The default behavior (which can be specified by passing -1) is to send requests using the most appropriate network interface, which may depend on the routing metric configured via the *roNetworkConfiguration* object. If both interfaces are on the same layer 2 network, this method may not work as expected due to the Linux weak-host model.

##### SetMaximumReceiveBytesPerSecond(bytes\_per\_second as Double) As Boolean

Limits the rate at which downloads are performed by the *roAssetFetcher* instance. The source data rate isn't under the direct control of the BrightSign player, but download rates should average below the specified value over time. 

This method returns `true` on success and `false` on failure. In event of failure, the `GetFailureReason()` method may provide more information.

##### SetMinimumTransferRate(bytes\_per\_second As Integer, period\_in\_seconds As Integer) As Boolean

Sets the minimum transfer rate for each file download. A transfer will be terminated if the rate drops below *bytes\_per\_second* when averaged over *period\_in\_seconds*. Note that if the transfer is over the Internet, you may not want to set `period_in_seconds` to a small number in case network problems cause temporary drops in performance. For large file transfers and a small `bytes_per_second` limit, averaging fifteen minutes or more may be appropriate.

## ifMessagePort

##### SetPort(port As roMessagePort)

Posts messages of type *roAssetFetcherEvent* and *roAssetFetcherProgressEvent* to the attached message port.

## ifUserData

##### SetUserData(user\_data As Object)

Sets the user data that will be returned when events are raised.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()` . It will return Invalid if no data has been set.
----
developers\developers\brightscript\object-reference\content-management-objects\roassetfetcherevent.md
# roAssetFetcherEvent

This event is generated by an *roAssetFetcher* instance when a file transfer succeeds or fails or when population of the asset pool as a whole succeeds or fails.

## ifAssetFetcherEvent

##### GetEvent() As Integer

Returns an integer indicating the result of an *roAssetFetcher* download attempt:

*    1: POOL\_EVENT\_FILE\_DOWNLOADED
    
*   \-1: POOL\_EVENT\_FILE\_FAILED
    
*    2: POOL\_EVENT\_ALL\_DOWNLOADED
    
*   \-2: POOL\_EVENT\_ALL\_FAILED
    

##### GetName() As String

Returns the filename associated with the event (if any).

##### GetFailureReason() As String

Returns additional failure information associated with the event (if any).

##### GetFileIndex() As Integer

Retrieves the zero-based index from the sync spec of the file associated with the event. 

##### GetResponseCode() As Integer

Returns the protocol response code associated with an event. The following codes indicate success:

*   200: Successful HTTP transfer
    
*   226: Successful FTP transfer
    
*   0: Successful local file transfer
    

For unexpected errors, the return value is negative. There are many possible negative errors from the CURL library, but it is often best to look at the text version by calling `GetFailureReason()`.

Here are some potential errors. Not all of them can be generated by a BrightSign player: 

|     |     |     |
| --- | --- | --- |
| **Status** | **Name** | **Description** |
| \-1 | CURLE\_UNSUPPORTED\_PROTOCOL |     |
| \-2 | CURLE\_FAILED\_INIT |     |
| \-3 | CURLE\_URL\_MALFORMAT |     |
| \-5 | CURLE\_COULDNT\_RESOLVE\_PROXY |     |
| \-6 | CURLE\_COULDNT\_RESOLVE\_HOST |     |
| \-7 | CURLE\_COULDNT\_CONNECT |     |
| \-8 | CURLE\_FTP\_WEIRD\_SERVER\_REPLY |     |
| \-9 | CURLE\_REMOTE\_ACCESS\_DENIED | A service was denied by the server due to lack of access. When login fails, this is not returned. |
| \-11 | CURLE\_FTP\_WEIRD\_PASS\_REPLY |     |
| \-13 | CURLE\_FTP\_WEIRD\_PASV\_REPLY |     |
| \-14 | CURLE\_FTP\_WEIRD\_227\_FORMAT |     |
| \-15 | CURLE\_FTP\_CANT\_GET\_HOST |     |
| \-17 | CURLE\_FTP\_COULDNT\_SET\_TYPE |     |
| \-18 | CURLE\_PARTIAL\_FILE |     |
| \-19 | CURLE\_FTP\_COULDNT\_RETR\_FILE |     |
| \-21 | CURLE\_QUOTE\_ERROR | Failed quote command |
| \-22 | CURLE\_HTTP\_RETURNED\_ERROR |     |
| \-23 | CURLE\_WRITE\_ERROR |     |
| \-25 | CURLE\_UPLOAD\_FAILED | Failed upload command. |
| \-26 | CURLE\_READ\_ERROR | Could not open/read from file. |
| \-27 | CURLE\_OUT\_OF\_MEMORY |     |
| \-28 | CURLE\_OPERATION\_TIMEDOUT | The timeout time was reached. |
| \-30 | CURLE\_FTP\_PORT\_FAILED | FTP PORT operation failed. |
| \-31 | CURLE\_FTP\_COULDNT\_USE\_REST | REST command failed. |
| \-33 | CURLE\_RANGE\_ERROR | RANGE command did not work. |
| \-34 | CURLE\_HTTP\_POST\_ERROR |     |
| \-35 | CURLE\_SSL\_CONNECT\_ERROR | Wrong when connecting with SSL. |
| \-36 | CURLE\_BAD\_DOWNLOAD\_RESUME | Could not resume download. |
| \-37 | CURLE\_FILE\_COULDNT\_READ\_FILE |     |
| \-38 | CURLE\_LDAP\_CANNOT\_BIND |     |
| \-39 | CURLE\_LDAP\_SEARCH\_FAILED |     |
| \-41 | CURLE\_FUNCTION\_NOT\_FOUND |     |
| \-42 | CURLE\_ABORTED\_BY\_CALLBACK |     |
| \-43 | CURLE\_BAD\_FUNCTION\_ARGUMENT |     |
| \-45 | CURLE\_INTERFACE\_FAILED | CURLOPT\_INTERFACE failed. |
| \-47 | CURLE\_TOO\_MANY\_REDIRECTS | Catch endless re-direct loops. |
| \-48 | CURLE\_UNKNOWN\_TELNET\_OPTION | User specified an unknown option. |
| \-49 | CURLE\_TELNET\_OPTION\_SYNTAX | Malformed telnet option. |
| \-51 | CURLE\_PEER\_FAILED\_VERIFICATION | Peer's certificate or fingerprint wasn't verified correctly. |
| \-52 | CURLE\_GOT\_NOTHING | When this is a specific error. |
| \-53 | CURLE\_SSL\_ENGINE\_NOTFOUND | SSL crypto engine not found. |
| \-54 | CURLE\_SSL\_ENGINE\_SETFAILED | Cannot set SSL crypto engine as default. |
| \-55 | CURLE\_SEND\_ERROR, | Failed sending network data. |
| \-56 | CURLE\_RECV\_ERROR | Failure in receiving network data. |
| \-58 | CURLE\_SSL\_CERTPROBLEM | Problem with the local certificate. |
| \-59 | CURLE\_SSL\_CIPHER | Could not use specified cipher. |
| \-60 | CURLE\_SSL\_CACERT | Problem with the CA cert (path?) |
| \-61 | CURLE\_BAD\_CONTENT\_ENCODING | Unrecognized transfer encoding. |
| \-62 | CURLE\_LDAP\_INVALID\_URL | Invalid LDAP URL. |
| \-63 | CURLE\_FILESIZE\_EXCEEDED, | Maximum file size exceeded. |
| \-64 | CURLE\_USE\_SSL\_FAILED, | Requested FTP SSL level failed. |
| \-65 | CURLE\_SEND\_FAIL\_REWIND, | Sending the data requires a rewind that failed. |
| \-66 | CURLE\_SSL\_ENGINE\_INITFAILED | Failed to initialize ENGINE. |
| \-67 | CURLE\_LOGIN\_DENIED | User, password, or similar field was not accepted and login failed . |
| \-68 | CURLE\_TFTP\_NOTFOUND | File not found on server. |
| \-69 | CURLE\_TFTP\_PERM | Permission problem on server. |
| \-70 | CURLE\_REMOTE\_DISK\_FULL | Out of disk space on server. |
| \-71 | CURLE\_TFTP\_ILLEGAL | Illegal TFTP operation. |
| \-72 | CURLE\_TFTP\_UNKNOWNID | Unknown transfer ID. |
| \-73 | CURLE\_REMOTE\_FILE\_EXISTS | File already exists. |
| \-74 | CURLE\_TFTP\_NOSUCHUSER | No such user. |
| \-75 | CURLE\_CONV\_FAILED | Conversion failed. |
| \-76 | CURLE\_CONV\_REQD | Caller must register conversion callbacks using the following URL\_easy\_setopt options: CURLOPT\_CONV\_FROM\_NETWORK\_FUNCTION CURLOPT\_CONV\_TO\_NETWORK\_FUNCTION CURLOPT\_CONV\_FROM\_UTF8\_FUNCTION |
| \-77 | CURLE\_SSL\_CACERT\_BADFILE | Could not load CACERT file, missing or wrong format. |
| \-78 | CURLE\_REMOTE\_FILE\_NOT\_FOUND | Remote file not found. |
| \-79 | CURLE\_SSH | Error from the SSH layer (this is somewhat generic, so the error message will be important when this occurs). |
| \-80 | CURLE\_SSL\_SHUTDOWN\_FAILED | Failed to shut down the SSL connection. |

The following error codes are generated by the system software and are outside the range of CURL events

|     |     |     |
| --- | --- | --- |
| **Status** | **Name** | **Description** |
| \-1002 | ENOENT | The specified file does not exist or cannot be created. |
| \-10001 | Cancelled | The operation has been cancelled. |
| \-10002 | Exception | The operation caused a local exception. Call GetFailureReason() for more details. |
| \-10003 | ERROR\_EXCEPTION | An unexpected exception occurred. |
| \-10004 | ERROR\_DISK\_ERROR | A disk error occurred (usually as a result of the disk being full). |
| \-10005 | ERROR\_POOL\_UNSATISFIED | The expected files are not present in the pool. |
| \-10006 | ERROR\_DOWNLOADING\_ELSEWHERE | The file is being downloaded by another *roAssetFetcher* instance. |
| \-10007 | ERROR\_HASH\_MISMATCH | A downloaded file did not match its checksum or file size. |

## ifUserData

##### SetUserData(user\_data As Object)

Sets the user data that will be returned when events are raised.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()`. It will return Invalid if no data has been set.
----
developers\developers\brightscript\object-reference\content-management-objects\roassetfetcherprogressevent.md
# roAssetFetcherProgressEvent

This event is generated by the *roAssetFetcher* object at regular intervals during file downloads. Use the *roAssetFetcher.SetFileProgressIntervalSeconds()* method to customize how often progress events are generated. 

## ifAssetFetcherProgressEvent

##### GetFileName() As String

Returns the name of the file associated with the event. The file name is retrieved from the sync spec associated with the *roAssetFetcher* that generated the event.

##### GetFileIndex() As Integer

Returns the zero-based index from the sync spec of the file associated with the event.

##### GetFileCount() As Integer

Returns the total number of files within the sync spec.

##### GetCurrentFileTransferredMegabytes() As Integer

Returns the number of transferred megabytes belonging to the file associated with the event.

##### GetCurrentFileSizeMegabytes() As Integer

Returns the size of the file associated with the event.

##### GetCurrentFilePercentage() As Float

Returns a floating-point number representing the download percentage of the file associated with the event.

> [!NOTE]
> The file size/percentage returned by the methods above is derived from the asset `size` in the associated *roAssetCollection* or sync spec–not from the HTTP "Content-Length" header. Specifying an asset `size` of zero will cause these methods to return zero.

## ifUserData

##### SetUserData(user\_data As Object) As Void

Sets the user data.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()` (on either the event or source object). It will return Invalid if no data has been set.
----
developers\developers\brightscript\object-reference\content-management-objects\roassetpool.md
# roAssetPool

An *roAssetPool* instance represents a pool of files for synchronization. You can instruct this object to populate the pool based on a sync spec and then realize it in a specified directory when required. The JavaScript equivalent is [assetpool](https://docs.brightsign.biz/display/DOC/assetpool).

Object Creation: The *roAssetPool* object is created with a single parameter representing the rooted path of the pool.

```
CreateObject("roAssetPool", pool_path As String)
```

Example:

```
pool = CreateObject ("roAssetPool", "SD:/pool")
```

## ifAssetPool

##### GetFailureReason() As String  
 

##### ProtectAssets(name As String, collection As Object) As Boolean

Requests that the files specified in the "download" section of a sync spec receive a certain amount of protection. Specified files will not be deleted when the system software needs to reduce the size of the pool to make space.

##### UnprotectAssets(name As String) As Boolean

Removes the protected status placed on the specified files by the `ProtectAssets()` method. Asset collections are reference counted at the system-software level. As a result, when calling `UnprotectAssets()`, you must pass the same object that you previously passed to `ProtectAssets()`.

##### UnprotectAllAssets() As Boolean

Removes the protected status placed on any files in the asset pool using the `ProtectAssets()` method. 

##### ReserveMegabytes(size As Integer) As Boolean

Reserves the specified amount of storage space. This method is dynamic: The system software attempts to keep the space free even when parallel processes are filling up the storage.

##### SetMaximumPoolSizeMegabytes(maximum\_size As Integer) As Boolean

Specifies the maximum size of an *roAssetPool* instance in megabytes. This method is more resource-intensive than `ReserveMegabytes()`, but it is useful when creating multiple pools on a storage device.

##### GetPoolSizeInMegabytes() As Integer

Returns the current size of the asset pool (in megabytes). 

##### Validate(sync\_spec As Object, options As roAssociativeArray) As Boolean

Checks the SHA1, BESHA1, or MD5 hash value of files that are in the sync spec and are currently present in the pool. This method returns True if all checks pass and False if one or more checks fail. Calling `GetFailureReason()` will return information about the corrupt file(s). Note that a True return may not mean that all files in the sync spec are currently present in the pool. The second parameter represents a table of validation options: The key specifies the option and the value specifies whether the option is enabled or not (as a Boolean value). Currently, the only option is "DeleteCorrupt", which determines whether the method should automatically delete corrupt files or not.

##### QueryFiles(sync\_spec As roAssociativeArray) As roAssociativeArray

Determines whether the specified files are present in the asset pool. This method returns an associative array with filename keys and corresponding Boolean values.

##### AssetsReady(collection As Object) As Boolean

Returns `true` if the specified files are ready in the asset pool.
----
developers\developers\brightscript\object-reference\content-management-objects\roassetpoolfiles.md
# roAssetPoolFiles

This object allows for interacting with files in an asset pool. The JavaScript equivalent is [assetpoolfiles](../../../../developers/player-apis/javascript-apis/assetpoolfiles.md).

Object Creation: The *roAssetPoolFiles* object is created with two parameters.

```
CreateObject("roAssetPoolFiles", pool As roAssetPool, assets As Dynamic)
```

The `assets` argument can be either an *roAssetCollection* or *roSyncSpec* object. If multiple object instances requires use of an *roAssetCollection* instance, it will be more efficient to convert *roSyncSpec* to *roAssetCollection* by calling `GetAssets()` once and then passing that collection to all object instances requiring it.

This object works similarly to the *roSyncPoolFiles* object.

## ifAssetPoolFiles

##### GetFailureReason() As String

Returns explanatory text if `GetPoolFilePath()` returns an empty string or `GetPoolFileInfo()` returns Invalid.

##### MoveFileIntoPool(source\_filename As String, asset\_name As String) As Boolean

Moves an arbitrary file into the appropriate location in the asset pool. The source file must be in the same filesystem as the asset pool. This method accepts two parameters:

*   `source_filename` string: The path of an existing file in the filesystem
    
*   `asset_name` string: The name of an asset within the asset collection associated with the *roAssetPoolFiles* instance. If the asset size is known, it will be checked against the source file. The move operation will fail if the `asset_name` does not match any asset in the pool or if the file size does not match the known asset size.
    

This method returns `true` on success and `false` on failure. Use the `GetFailureReason()` method to retrieve an error description.

##### GetPoolFilePath(asset\_name As String) As String

Looks up the specified file name in the asset collection and uses the information to determine the actual name of the file in the pool. This method returns an empty string if the name is not found in the asset collection, or if the file is not found in the pool.

##### GetPoolFileInfo(asset\_name As String) As Object

Looks up the specified file name in the asset collection and returns all available information, including the pool file path, as an associative array. This method returns Invalid if the asset name is not found in the asset collection. If the file is not found in the pool, information from the asset collection will be returned without the pool path. See the table below for a description of assets in the associative array.

|     |     |     |
| --- | --- | --- |
| **Field** | **Value** | **Description** |
| name | String | Asset name |
| link | String | Asset URL |
| size | String |     |
| hash | String | Hash in algorithm ":" hash format |
| change\_hint | String | Only present if set |
| auth\_user | String | Only present if set |
| auth\_password | String | Only present if set |
| auth\_inherit | Boolean |     |
| headers\_inherit | Boolean |     |
| probe | String | Probe data |
| path | String | Absolute path of the file in the pool (or "invalid" if the file is not in the pool) |
----
developers\developers\brightscript\object-reference\content-management-objects\roassetrealizer.md
# roAssetRealizer

This object contains functions for realizing files (i.e. extracting files from an asset pool and placing them into the standard file directory). Realizing a complete asset pool is not recommended because the process can be slow. Instead, the script should retrieve pool file locations using the *roAssetPoolFiles* object and use them to refer to files directly. The *roAssetRealizer* object is still useful for realizing files that must be in the root directory to work (e.g. autorun and firmware update files). The JavaScript equivalent is [assetrealizer](https://docs.brightsign.biz/display/DOC/assetrealizer).

Object Creation: The *roAssetRealizer* object requires two parameters upon creation: an *roAssetPool* object and a destination directory.

```
CreateObject("roAssetRealizer", pool As roAssetPool, destination_directory As String)
```

##### **Example**

```
pool = CreateObject("roAssetPool", "pool")
realizer = CreateObject ("roAssetRealizer", pool, "/")
```

## IfUserData

##### SetUserData(user\_data As Object)

Sets the user data that will be returned when events are raised.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()`. It will return Invalid if no data has been set.

## ifAssetRealizer

##### GetFailureReason() As String

Yields additional useful information if a function return indicates an error.

##### EstimateRealizedSizeInMegabytes(spec As Object) As Integer

Returns the estimated amount of space that would be taken up by the specified sync spec.

##### Realize(spec As roSyncSpec/roAssetCollection) As roAssetRealizerEvent

Places the files into the destination directory specified in the passed *roSyncSpec* or *roAssetCollection*. If the pool does not contain the full set of required files, then this method will immediately fail before any files are changed (this method attempts to do as much work as possible before destructively modifying the file system). This method automatically checks the length of the file and any hashes that match the specification. If there is a mismatch, then the affected file is deleted and realization fails. This method indicates success or failure by returning an *roAssetRealizerEvent* object.

> [!NOTE]
> The pool and the destination must be in the same file system.

##### ValidateFiles(spec As Object, options As Object) As roAssociativeArray

Checks the hash of every file in the spec against the corresponding file in the destination path and returns an associative array containing each mismatched file name mapped to the reason. The options parameter is an *roAssociativeArray*, which can currently support a single option:

*   "DeleteCorrupt": Automatically deletes any files that do not match the expected hash. By default, these files are not deleted.
----
developers\developers\brightscript\object-reference\content-management-objects\roassetrealizerevent.md
# roAssetRealizerEvent

This event object is returned by the *roAssetRealizer.Realize()* method. It yields information about the success or failure of the realization process.

## ifAssetRealizerEvent

##### GetEvent() As Integer 

Returns an integer value indicating the type of the event:

|     |     |     |
| --- | --- | --- |
| 101 | EVENT\_REALIZE\_SUCCESS | The specified sync list was successfully realized. |
| \-102 | EVENT\_REALIZE\_INCOMPLETE | Realization could not begin because at least one of the required files is not available in the pool. |
| \-103 | EVENT\_REALIZE\_FAILED\_SAFE | Realization has failed. Nothing has been written to the destination, so it is likely safe to continue the realization process. More information is about the failure is available via the `GetFailureReason()` and `GetName()` methods. |
| \-104 | EVENT\_REALIZE\_FAILED\_UNSAFE | Realization has failed while running, and changes have been made to destination files. It may not be safe to continue the realization process. More information about the failure is available via the `GetFailureReason()` and `GetName()` methods. |

##### GetName() As String

Retrieves the name of the affected file if the realization process fails.

##### GetResponseCode() As Integer

Retrieves the *roUrlTransfer* response code associated with the event (if any).

##### GetFailureReason() As String

Returns additional information if the realization process fails.

##### GetFileIndex() As Integer

Retrieves the zero-based index number of the the file in the sync spec.

## ifUserData

##### SetUserData(user\_data As Object) As Void

Sets the user data.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()` (on either the event or source object). It will return Invalid if no data has been set.
----
developers\developers\brightscript\object-reference\content-management-objects\rosyncspec.md
# roSyncSpec

This object represents a parsed sync spec. It allows you to retrieve various parts of the specification with methods.

## ifSyncSpec

##### GetFailureReason() As String

Returns information if an *roSyncSpec* method indicates failure.

##### ReadFromFile(filename As String) As Boolean

Populates the sync spec by reading the specified file. This method returns True upon success and False upon failure.

##### ReadFromString(spec As String) As Boolean

Populates the sync spec by reading the passed string. This method returns True upon success and False upon failure.

##### WriteToFile(filename As String) As Boolean

Writes out the current sync spec to the specified file as XML. Because the XML is regenerated, it is possible this file may not be textually identical to the specification that was read. This method returns True upon success and False upon failure.

##### WriteToFile(filename As String, options As roAssociativeArray) As Boolean

Writes out the current sync spec to the specified file as XML or JSON. The `options` associative array can currently contain the `format` parameter, which can have a value of "xml" or "json". Because the XML/JSON is regenerated, it is possible this file may not be textually identical to the specification that was read. This method returns True upon success and False upon failure.

##### WriteToString() As String

Writes out the current sync spec to a string and returns it as XML. This method returns an empty string if the write operation fails.

##### WriteToString(options As roAssociativeArray) As String

Writes out the current sync spec to a string and returns it as XML or JSON. The `options` associative array can currently contain the `format` parameter, which can have a value of "xml" or "json". This method returns an empty string if the write operation fails.

##### GetMetadata(section As String) As roAssociativeArray

Returns an *roAssociativeArray* object containing the information stored in the specified metadata section of the sync spec (typically "client" or "server"). This method returns 0 if the read operation fails.

If the sync spec is formatted as XML, then all returned values will be strings. If the spec spec is formatted as JSON, the JavaScript types will be converted as follows:

| JavaScript type | BrightScript type |
| --- | --- |
| Array | roArray |
| Object | roAssociativeArray |
| String | String |
| Boolean | Boolean |
| Number | Double |
| Null | Invalid |

##### LookupMetadata(section As String, field As String) As String

Provides a shortcut for looking up specified metadata items in the specified section without needing to create a temporary *roAssociativeArray* object. This method returns an empty string if the read operation fails.

##### GetFileList(section As String) As roList

Returns an *roList* object containing *roAssociativeArray* objects for each file in the specified section of the sync spec. This method returns Invalid if the read operation fails.

##### GetFile(section As String, index As Integer) As roAssociativeArray

Returns an *roAssociativeArray* object for the file in the specified section and at the specified index. This method returns Invalid if the read operation fails.

##### GetName() As String

Returns the name supplied for the sync spec in the <sync> XML element.

##### EqualTo(other As roSyncSpec) As Boolean

Compares the contents of the *roSyncSpec* object with another *roSyncSpec* object. This method compares the parsed contents of each sync spec rather than the XML files themselves.

##### VerifySignature(signature as String, obfuscated\_passphrase as String) As Boolean

De-obfuscates the passphrase and uses it to verify the signature of the sync spec. This method returns True upon success and False upon failure.

##### FilterFiles(section As String, criteria As roAssociativeArray) As roSyncSpec

Returns a new *roSyncSpec* object that is a copy of the existing object, except that the specified section is filtered using the specified criteria. The criteria are matched against the file metadata. Multiple criteria can be specified in the passed associative array, and all criteria must be met for a file to be returned with the new *roSyncSpec*.

The following call will yield an *roSyncSpec* object with a "download" section that has been filtered so that only files of the group "scripts" will remain.

```
filtered_spec = spec.FilterFiles("download", { group: "scripts" })
```

##### FilesEqualTo(spec As roSyncSpec) As Boolean

Compares the contents of the sync spec to another sync spec and returns `true` if they're identical. This method compares the parsed contents of the sync specs, rather than the XML/JSON itself.

##### GetAssets(section As String) As Object

Retrieves a list of assets from the sync spec in a form that's compatible with *roAssetPool* and its associated objects.
----
developers\developers\brightscript\object-reference\content-management-objects.md
# Content Management Objects

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

This section describes objects that enable downloading, storage, and retrieval of content from a remote CMS.

*   [roAssetCollection](./content-management-objects/roassetcollection.md)
*   [roAssetFetcher](./content-management-objects/roassetfetcher.md)
*   [roAssetFetcherEvent](./content-management-objects/roassetfetcherevent.md)
*   [roAssetFetcherProgressEvent](./content-management-objects/roassetfetcherprogressevent.md)
*   [roAssetPool](./content-management-objects/roassetpool.md)
*   [roAssetPoolFiles](./content-management-objects/roassetpoolfiles.md)
*   [roAssetRealizer](./content-management-objects/roassetrealizer.md)
*   [roAssetRealizerEvent](./content-management-objects/roassetrealizerevent.md)
*   [roSyncSpec](./content-management-objects/rosyncspec.md)
----
developers\developers\brightscript\object-reference\date-and-time-objects\rodatetime.md
# roDateTime

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

This object is used to represent an instant in time. At the time of its creation, a new object represents zero seconds. The JavaScript equivalent is "Date".

## ifDateTime

##### GetDayOfWeek() As Integer  
 

##### GetDay() As Integer  
 

##### GetMonth() As Integer  
 

##### GetYear() As Integer  
 

##### GetHour() As Integer  
 

##### GetMinute() As Integer  
 

##### GetSecond() As Integer  
 

##### GetMillisecond() As Integer  
 

##### SetDay(day As Integer) As Void  
 

##### SetMonth(month As Integer) As Void  
 

##### SetYear(year As Integer) As Void  
 

##### SetHour(hour As Integer) As Void  
 

##### SetMinute(minute As Integer) As Void  
 

##### SetSecond(second As Integer) As Void  
 

##### SetMillisecond(millisecond As Integer) As Void  
 

##### AddSeconds(seconds As Integer) As Void  
 

##### SubtractSeconds(seconds As Integer) As Void  
 

##### AddMilliseconds(milliseconds As Integer) As Void  
 

##### SubtractMilliseconds(milliseconds As Integer) As Void  
 

##### Normalize() As Boolean

Checks that all the fields supplied are correct. This function fails if the values are out of bounds.

##### ToIsoString() As String

Returns the current *roDateTime* value as an ISO-8601 basic formatted string. Hyphens for date and colons for time are omitted, and a comma is used to separate seconds from milliseconds: For example, the ISO-8601 standard "2014-05-29T12:30:00.100" would be formatted as "20140529T123000,100".

This method returns an empty string if the year is less than 1970 or greater than 2100. Since a new, un-configured *roDateTime* object lies outside the acceptable range, it will also return an empty string.

##### FromIsoString(date-time As String) As Boolean

Sets the value of the *roDateTime* object using an ISO-8601 basic formatted string. Hyphens for date and colons for time are omitted, and either a period or comma can be used to separate seconds from milliseconds: The ISO-8601 standard "2014-05-29T12:30:00.100" could, for example, be formatted as either "20140529T123000,100" or "20140529T123000.100". This method will return `false` (indicating that it has not affected changes to the *roDateTime* object) if the string is formatted incorrectly or if the date passed is outside the range of January 1, 1970 and December 31, 2100.

##### ToSecondsSinceEpoch() As Integer

Returns the number of seconds that have elapsed since midnight on January 1, 1970, as represented by the *roDateTime* instance (not the system time).

##### FromSecondsSinceEpoch(seconds As Integer) As Boolean

Populates the *roDateTime* instance with the specified number of seconds since midnight on January 1, 1970.

##### GetString() As String

## ifString

##### GetString() As String

Returns the current date using a sortable date format: "YYYY/MM/DD hh:mm:ss.sss".
----
developers\developers\brightscript\object-reference\date-and-time-objects\ronetworktimeevent.md
# roNetworkTimeEvent

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

This event object is generated by the *roSystemTime* object.  

## ifUserData

##### SetUserData(user\_data As Object)

Sets the user data that will be returned by `GetUserData()`.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()`. It will return Invalid if no data has been set.

## ifNetworkTimeEvent

##### WasSuccessful() As Boolean

Returns True if the last attempt to set the clock via the network (i.e. NTP or HTTP) was successful.

##### GetFailureReason() As String

Returns a description of the error if the last attempt to set the clock via the network failed.
----
developers\developers\brightscript\object-reference\date-and-time-objects\rosystemtime.md
# roSystemTime

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

This object provides the ability to read and write the time stored in the real-time clock (RTC). It can also be used to read and write the time-zone setting. The JavaScript equivalent is [systemtime](https://docs.brightsign.biz/display/DOC/systemtime).

> [!NOTE]
> Dates up to January 1, 2038 are supported.

## ifUserData

##### SetUserData(user\_data As Object)

Sets the user data that will be returned when events are raised.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()`. It will return Invalid if no data has been set.

## ifMessagePort

##### SetPort(port As roMessagePort)

Posts messages of the type *roNetworkTimeEvent* to the attached message port.

## ifSystemTime

##### GetLocalDateTime() As roDateTime

Returns the current time from the RTC (modulated using the current time zone) as an *roDateTime* instance.

##### GetUtcDateTime() As roDateTime

Returns the current time from the RTC (modulated using the UTC/GMT time zone) as an *roDateTime* instance.

##### GetZoneDateTime(timezone\_name As String) As Object

Returns the current time from the RTC (modulated using the specified time zone) as an *roDateTime* instance. Supported time zones are listed below.

##### SetLocalDateTime(local\_DateTime As roDateTime) As Boolean

Specifies a new time for the RTC using the current time zone.

##### SetUtcDateTime(utc\_DateTime As roDateTime) As Boolean

Specifies a new time for the RTC using the UTC/GMT time zone.

##### GetTimeZone() As String

Returns the current time-zone setting of the player. A `POSIX:` value is appended to the beginning of the string if the time zone has been set using the POSIX format.

##### SetTimeZone(zone\_name As String) As Boolean

Specifies a new time-zone setting for the player (supported time zones are listed below). Alternatively, a POSIX formatted time zone can be applied by appending a `POSIX:` value to the beginning of the string.

The following code specifies a POSIX-formatted time zone:

```
t = CreateObject("roSystemTime")
t.SetTimeZone("POSIX:GMT-0BST-1,M3.5.0/1:00,M10.5.0/2:00")
```

##### IsValid() As Boolean

Returns True if the system time is set to a valid value. The time can be set from the RTC or with NTP.

##### GetLastNetworkTimeResult() As roAssociativeArray

Returns an associative array containing information about the last attempt to set the time via the network:

*   `success_timestamp`: A value indicating when the clock was last set successfully via the network. This value is zero if the clock has never been set successfully via the network.
    
*   `attempt_timestamp`: A value indicating when the last attempt was made to set the clock via the network. This value is zero if no attempt has been made yet.
    
*   `failure_reason`: If the last attempt to set the clock via the network failed, this string will contain an error message. If the last attempt was successful, this string will be empty.
    

In this associative array, "timestamp" refers to the number of seconds since the player booted. This value can be compared against the total uptime of the player, which is retrieved by calling `UpTime(0)`.

## Supported Time Zones 

The following are supported system time zones (this list does not apply to POSIX-formatted time zones):

*   EST: US Eastern Time
    
*   CST: US Central Time
    
*   MST: US Mountain Time
    
*   PST: US Pacific Time
    
*   AKST: Alaska Time
    
*   HST: Hawaii-Aleutian Time with no Daylight Savings (Hawaii)
    
*   HST1: Hawaii-Aleutian Time with Daylight Saving
    
*   MST1: US MT without Daylight Saving Time (Arizona)
    
*   EST1: US ET without Daylight Saving Time (East Indiana)
    
*   AST: Atlantic Time
    
*   CST2: Mexico (Mexico City)
    
*   MST2: Mexico (Chihuahua)
    
*   PST2: Mexico (Tijuana)
    
*   BRT: Brazil Time (Sao Paulo)
    
*   NST: Newfoundland Time
    
*   AZOT: Azores Time
    
*   GMTBST: London/Dublin Time
    
*   WET: Western European Time
    
*   CET: Central European Time
    
*   EET: Eastern European Time
    
*   MSK: Moscow Time
    
*   SAMT: Delta Time Zone (Samara)
    
*   YEKT: Echo Time Zone (Yekaterinburg)
    
*   IST: Indian Standard Time
    
*   NPT: Nepal Time
    
*   OMST: Foxtrot Time Zone (Omsk)
    
*   JST: Japanese Standard Time
    
*   CXT: Christmas Island Time (Australia)
    
*   AWST: Australian Western Time
    
*   AWST1: Australian Western Time without Daylight Saving Time
    
*   ACST: Australian Central Standard Time (CST) with Daylight Saving Time
    
*   ACST1: Darwin, Australia/Darwin, and Australian Central Standard Time (CST) without Daylight Saving Time
    
*   AEST: Australian Eastern Time with Daylight Saving Time
    
*   AEST1: Australian Eastern Time without Daylight Saving Time (Brisbane)
    
*   NFT: Norfolk (Island) Time (Australia)
    
*   NZST: New Zealand Time (Auckland)
    
*   CHAST: , Fiji Time, , Fiji, Pacific/Fiji, Yankee Time Zone (Fiji)
    
*   SST: X-ray Time Zone (Pago Pago)
    
*   GMT: Greenwich Mean Time
    
*   GMT-1: 1 hour behind Greenwich Mean Time
    
*   GMT-2: 2 hours behind Greenwich Mean Time
    
*   GMT-3: 3 hours behind Greenwich Mean Time
    
*   GMT-3:30: 3.5 hours behind Greenwich Mean Time
    
*   GMT-4: 4 hours behind Greenwich Mean Time
    
*   GMT-4:30: 4.5 hours behind Greenwich Mean Time
    
*   GMT-5: 5 hours behind Greenwich Mean Time
    
*   GMT-6: 6 hours behind Greenwich Mean Time
    
*   GMT-7: 7 hours behind Greenwich Mean Time
    
*   GMT-8: 8 hours behind Greenwich Mean Time
    
*   GMT-9: 9 hours behind Greenwich Mean Time
    
*   GMT-9:30: 9.5 hours behind Greenwich Mean Time
    
*   GMT-10: 10 hours behind Greenwich Mean Time
    
*   GMT-11: 11 hours behind Greenwich Mean Time
    
*   GMT-12: 12 hours behind Greenwich Mean Time
    
*   GMT-13: 13 hours behind Greenwich Mean Time
    
*   GMT-14: 14 hours behind Greenwich Mean Time
    
*   GMT+1: 1 hour ahead of Greenwich Mean Time
    
*   GMT+2: 2 hours ahead of Greenwich Mean Time
    
*   GMT+3: 3 hours ahead of Greenwich Mean Time
    
*   GMT+3:30: 3.5 hours ahead of Greenwich Mean Time
    
*   GMT+4: 4 hours ahead of Greenwich Mean Time
    
*   GMT+4:30: 4.5 hours ahead of Greenwich Mean Time
    
*   GMT+5: 5 hours ahead of Greenwich Mean Time
    
*   GMT+5:30: 5.5 hours ahead of Greenwich Mean Time
    
*   GMT+6: 6 hours ahead of Greenwich Mean Time
    
*   GMT+6:30: 6.5 hours ahead of Greenwich Mean Time
    
*   GMT+7: 7 hours ahead of Greenwich Mean Time
    
*   GMT+7:30: 7.5 hours ahead of Greenwich Mean Time
    
*   GMT+8: 8 hours ahead of Greenwich Mean Time
    
*   GMT+8:30: 8.5 hours ahead of Greenwich Mean Time
    
*   GMT+9: 9 hours ahead of Greenwich Mean Time
    
*   GMT+9:30: 9.5 hours ahead of Greenwich Mean Time
    
*   GMT+10: 10 hours ahead of Greenwich Mean Time
    
*   GMT+10:30: 10.5 hours ahead of Greenwich Mean Time
    
*   GMT+11: 11 hours ahead of Greenwich Mean Time
    
*   GMT+11:30: 11.5 hours ahead of Greenwich Mean Time
    
*   GMT+12: 12 hours ahead of Greenwich Mean Time
    
*   GMT+12:30: 12.5 hours ahead of Greenwich Mean Time
    
*   GMT+13: 13 hours ahead of Greenwich Mean Time
    
*   GMT+14: 14 hours ahead of Greenwich Mean Time
----
developers\developers\brightscript\object-reference\date-and-time-objects\rotimer.md
# roTimer

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

This object allows the script to trigger events at a specific date/time or during specified intervals. Events are triggered by delivering *roTimerEvent* objects to the specified message port. The JavaScript equivalent is .setTimeout()/.setInterval().

## ifTimer

##### SetTime(hour As Integer, minute As Integer, second As Integer, millisecond As Integer) As Void

Sets the time for the event to trigger. In general, if a value is -1, then it is a wildcard and will cause the event to trigger every time the rest of the specification matches. If there are no wildcards, then the timer will trigger only once when the specified time occurs.

> [!NOTE]
> Periodic timers that fire every second are not supported. The seconds and milliseconds parameters must be zero if there are any wildcards elsewhere.

##### SetTime(a As Integer, b As Integer, c As Integer)  
 

##### SetDate(year As Integer, month As Integer, day As Integer) As Void

Sets the date for the event to trigger. In general, if a value is -1, then it is a wildcard and will cause the event to trigger every time the rest of the specification matches. If there are no wildcards, then the timer will trigger only once when the specified date/time occurs.

##### SetDayOfWeek(day\_of\_week As Integer) As Void

Sets the day of week for the event to trigger. In general, if a value is -1, then it is a wildcard and will cause the event to trigger every time the rest of the specification matches. If there are no wildcards, then the timer will trigger only once when the specified date/time occurs.

> [!NOTE]
> It is possible, using a combination of SetDate() and SetDayOfWeek() calls, to specify invalid combinations that will never occur. If specifications include any wildcard, then the second and millisecond specifications must be zero; events will be raised at most once per minute near the whole minute.

##### SetDateTime(date\_time As roDateTime) As Void

Sets the time when you wish the event to trigger from an *roDateTime* object. It is not possible to set wildcards using this method.

##### Start() As Boolean

Starts the timer based on the current values specified using the above functions.

##### Stop() As Void

Stops the timer.

##### SetElapsed(seconds As Integer, milliseconds As Integer)

Configures a timer to trigger once the specified time period has elapsed. Unlike the absolute timer methods above, changes to the system clock will not affect the period of the SetElapsed() timer.

## ifMessagePort

##### SetPort(port As roMessagePort) As Void

Posts messages of type *roTimerEvent* to the attached message port.

## ifUserData

##### SetUserData(user\_data As Object)

Sets the user data that will be returned when events are raised.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()`. It will return Invalid if no data has been set.

## ifIdentity

##### GetIdentity() As Integer

Returns a unique number that can be used to identify when events originate from this object.

> [!NOTE]
> The *ifIdentity* interface has been deprecated. We recommend using the *ifUserData* interface instead.

## Examples

This script uses the `SetElapsed()` method to create a timer that triggers every 30 seconds:

```
Sub Main()
    mp = CreateObject("roMessagePort")
    timer = CreateObject("roTimer")
    timer.SetPort(mp)

    timer.SetElapsed(30, 0)

    print "Start at "; Uptime(0)
    timer.Start()

    while true
       ev = mp.WaitMessage(0)
       if type(ev) = "roTimerEvent" then
           print "Timer event received at "; Uptime(0)
           timer.Start()
       else
           print "Another event arrived: "; type(ev)
       end if
    end while
End Sub
```

This script creates a timer that triggers every minute using wildcards in the timer spec:

```
st=CreateObject("roSystemTime")
timer=CreateObject("roTimer")
mp=CreateObject("roMessagePort")
timer.SetPort(mp)

timer.SetDate(-1, -1, -1)
timer.SetTime(-1, -1, 0, 0)
timer.Start()

while true
       ev = Wait(0, mp)
       if (type(ev) = "roTimerEvent") then
             print "timer event received"
       else
             print "unexpected event received"
       endif
endwhile
```

This script creates a timer that triggers once at a specific date/time.

```
timer=CreateObject("roTimer")
mp=CreateObject("roMessagePort")
timer.SetPort(mp)

timer.SetDate(2008, 11, 1)
timer.SetTime(0, 0, 0, 0)

timer.Start()

while true
       ev = Wait(0, mp)
       if (type(ev) = "roTimerEvent") then
             print "timer event received"
       else
             print "unexpected event received"
       endif
endwhile
```
----
developers\developers\brightscript\object-reference\date-and-time-objects\rotimerevent.md
# roTimerEvent

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

This event object is generated by the *roTimer* object.

## ifUserData

##### SetUserData(user\_data As Object)

Sets the user data.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()` (either on the source or event object). It will return Invalid if no data has been set.

## ifSourceIdentity

##### GetSourceIdentity() As Integer

Retrieves the identity value that can be used to associate events with the source *roTimer* instance.

> [!NOTE]
> The *ifSourceIdentity* interface has been deprecated. We recommend using the *ifUserData* interface instead.
----
developers\developers\brightscript\object-reference\date-and-time-objects\rotimespan.md
# roTimeSpan

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

This object provides an interface to a simple timer for tracking the duration of activities. It is useful for tracking how long an action has taken or whether a specified time has elapsed from a starting event. The JavaScript equivalent is "Date".

## ifTimeSpan

##### Mark()  
 

##### TotalMilliseconds() As Integer  
 

##### TotalSeconds() As Integer  
 

##### GetSecondsToISO8601Date(a As String) As Integer

#####
----
developers\developers\brightscript\object-reference\date-and-time-objects.md
# Date and Time Objects

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

This section describes objects that manipulate date and time settings on the player.

*   [roDateTime](./date-and-time-objects/rodatetime.md)
*   [roNetworkTimeEvent](./date-and-time-objects/ronetworktimeevent.md)
*   [roSystemTime](./date-and-time-objects/rosystemtime.md)
*   [roTimer](./date-and-time-objects/rotimer.md)
*   [roTimerEvent](./date-and-time-objects/rotimerevent.md)
*   [roTimeSpan](./date-and-time-objects/rotimespan.md)
----
developers\developers\brightscript\object-reference\file-objects\roappendfile.md
# roAppendFile

This object can be used to create a new file or append information to the end of an existing file.

Object Creation: Creating an *roAppendFile* object opens an existing file or creates a new file. The current position is set to the end of the file, and all writes are made to the end of the file.

```
CreateObject("roAppendFile", filename As String)
```

## ifStreamSend

##### SetSendEol(eol\_sequence As String) As Void

Sets the EOL sequence when writing to the stream. The default value is CR+LF. If you need to set this value to a non-printing character, use the `chr()` [global function](../../object-reference/global-functions.md).

##### SendByte(byte As Integer) As Void

Writes the specified byte to the stream.

##### SendLine(string As String) As Void

Writes the specified characters to the stream followed by the current EOL sequence.

##### SendBlock(a As Dynamic) As Void

Writes the specified characters to the stream. This method can support either a string or an *roByteArray*. If the block is a string, any null bytes will terminate the block.

##### Flush() As Void

Writes the stream to the file, blocking execution until all data is written out. 

##### AsyncFlush() As Void

Writes the stream to the file within a few seconds. The system will not block execution while writing to the file.

> [!NOTE]
> The system performs an asynchronous flush automatically when the object instance is destroyed (for instance, when the the variable containing it is reassigned). The stream is first written to the kernel, which then writes it to the file system when resources are available.

## ifStreamPosition

##### CurrentPosition() As Integer

Returns the current position within the file.
----
developers\developers\brightscript\object-reference\file-objects\rocreatefile.md
# roCreateFile

This object can be used to write a new file or overwrite an existing file.

Object Creation: Creating an *roCreateFile* object opens an existing file or creates a new file. If the file exists, it is truncated to a size of zero.

```
CreateObject("roCreateFile", filename As String)
```

## ifReadStream

##### SetReceiveEol(eol\_sequence As String) As Void

Sets the EOL sequence when reading from the stream.

##### ReadByte() As Integer

Reads a single byte from the stream, blocking if necessary. If the EOF is reached or there is an error condition, then a value less than 0 is returned.

##### ReadByteIfAvailable() As Integer

Reads a single byte from the stream if one is available. If no bytes are available, it returns immediately. A return value less than 0 indicates either that the EOF has been reached or no byte is available.

##### ReadLine() As String

Reads until it finds a complete end of the line sequence. If it fails to find the sequence within 4096 bytes, then it returns the 4096 bytes that are found. No data is discarded in this case.

##### ReadBlock(size As Integer) As String

Reads the specified number of bytes. The number is limited to 65536 bytes. In the event of an EOF or an error, fewer bytes than requested will be returned. Any null bytes in the file will mask any further bytes.

##### AtEof() As Boolean

Returns True if an attempt has been made to read beyond the end of the file. If the current position is at the end of the file, but no attempt has been made to read beyond it, this method will return False.

## ifStreamSend

##### SetSendEol(eol\_sequence As String) As Void

Sets the EOL sequence when writing to the stream. The default value is CR+LF. If you need to set this value to a non-printing character, use the `chr()` [global function](../../object-reference/global-functions.md).

##### SendByte(byte As Integer) As Void

Writes the specified byte to the stream.

##### SendLine(string As String) As Void

Writes the specified characters to the stream followed by the current EOL sequence.

##### SendBlock(a As Dynamic) As Void

Writes the specified characters to the stream. This method can support either a string or an *roByteArray*. If the block is a string, any null bytes will terminate the block.

##### Flush() As Void

Writes the stream to the file, blocking execution until all data is written out.

##### AsyncFlush() As Void

Writes the stream to the file within a few seconds. The system will not block execution while writing to the file.

> [!NOTE]
> The system performs an asynchronous flush automatically when the object instance is destroyed (for instance, when the the variable containing it is reassigned). The stream is first written to the kernel, which then writes it to the file system when resources are available.

## ifStreamSeek

##### SeekAbsolute(offset As Integer) As Void

Seeks the specified offset. If the offset is beyond the end of the file, then the file will be extended upon the next write and any previously unoccupied space will be filled with null bytes.

##### SeekRelative(offset As Integer) As Void

Seeks to the specified offset relative to the current position. If the ultimate offset is beyond the end of the file, then the file will be extended as described in `SeekAbsolute()`.

##### SeekToEnd() As Void

Seeks to the end of the file.

##### CurrentPosition() As Integer

Retrieves the current position within the file.
----
developers\developers\brightscript\object-reference\file-objects\roreadfile.md
# roReadFile

Object Creation: Creating an *roReadFile* object opens the specified file for reading only. Object creation fails if the file does not exist. 

```
CreateObject("roReadFile", filename As String)
```

## ifStreamRead

##### SetReceiveEol(eol\_sequence As String) As Void

Sets the EOL sequence when reading from the stream. The default EOL character is CR LF, (ASCII values 13 then 10). If you need to set this value to a non-printing character, use the `chr()` [global function](../../object-reference/global-functions.md).

##### ReadByte() As Integer

Reads a single byte from the stream, blocking if necessary. If the EOF is reached or there is an error condition, then a value less than 0 is returned.

##### ReadByteIfAvailable() As Integer

Reads a single byte from the stream if one is available. If no bytes are available, it returns immediately. A return value less than 0 indicates either that the EOF has been reached or no byte is available.

##### ReadLine() As String

Reads until it finds a complete end of the line sequence. If it fails to find the sequence within 4096 bytes, then it returns the 4096 bytes that are found. No data is discarded in this case.

##### ReadBlock(size As Integer) As String

Reads the specified number of bytes. The number is limited to 65536 bytes. In the event of an EOF or an error, fewer bytes than requested will be returned. Any null bytes in the file will mask any further bytes.

##### AtEof() As Boolean

Returns True if an attempt has been made to read beyond the end of the file. If the current position is at the end of the file, but no attempt has been made to read beyond it, this method will return False.

## ifStreamSeek

##### SeekAbsolute(offset As Integer) As Void

Seeks the specified offset. If the offset is beyond the end of the file, then the file will be extended upon the next write and any previously unoccupied space will be filled with null bytes.

##### SeekRelative(offset As Integer) As Void

Seeks to the specified offset relative to the current position. If the ultimate offset is beyond the end of the file, then the file will be extended as described in `SeekAbsolute()`.

##### SeekToEnd() As Void

Seeks to the end of the file.

##### CurrentPosition() As Integer

Retrieves the current position within the file.
----
developers\developers\brightscript\object-reference\file-objects\roreadwritefile.md
# roReadWriteFile

The object opens a file and allows both reading and writing operations on that file.

Object Creation: Creating an *roReadWriteFile* object opens an existing file for both reading and writing. Object creation fails if the file does not exist. The current position is set to the beginning of the file.

```
CreateObject("roReadWriteFile", filename As String)
```

## ifReadStream

##### SetReceiveEol(eol\_sequence As String) As Void

Sets the EOL sequence when reading from the stream.

##### ReadByte() As Integer

Reads a single byte from the stream, blocking if necessary. If the EOF is reached or there is an error condition, then a value less than 0 is returned.

##### ReadByteIfAvailable() As Integer

Reads a single byte from the stream if one is available. If no bytes are available, it returns immediately. A return value less than 0 indicates either that the EOF has been reached or no byte is available.

##### ReadLine() As String

Reads until it finds a complete end of the line sequence. If it fails to find the sequence within 4096 bytes, then it returns the 4096 bytes that are found. No data is discarded in this case.

##### ReadBlock(size As Integer) As String

Reads the specified number of bytes. The number is limited to 65536 bytes. In the event of an EOF or an error, fewer bytes than requested will be returned. Any null bytes in the file will mask any further bytes.

##### AtEof() As Boolean

Returns `True` if an attempt has been made to read beyond the end of the file. If the current position is at the end of the file, but no attempt has been made to read beyond it, this method will return `False`.

## ifStreamSend

##### SetSendEol(eol\_sequence As String) As Void

Sets the EOL sequence when writing to the stream. The default value is CR+LF. If you need to set this value to a non-printing character, use the `chr()` [global function](../../object-reference/global-functions.md).

##### SendByte(byte As Integer) As Void

Writes the specified byte to the stream.

##### SendLine(string As String) As Void

Writes the specified characters to the stream followed by the current EOL sequence.

##### SendBlock(a As Dynamic) As Void

Writes the specified characters to the stream. This method can support either a string or an *roByteArray*. If the block is a string, any null bytes will terminate the block.

##### Flush() As Void

Writes the stream to the file, blocking execution until all data is written out.

##### AsyncFlush() As Void

Writes the stream to the file within a few seconds. The system will not block execution while writing to the file.

> [!NOTE]
> The system performs an asynchronous flush automatically when the object instance is destroyed (for instance, when the the variable containing it is reassigned). The stream is first written to the kernel, which then writes it to the file system when resources are available.

## ifStreamSeek

##### SeekAbsolute(offset As Integer) As Void

Seeks the specified offset. If the offset is beyond the end of the file, then the file will be extended upon the next write and any previously unoccupied space will be filled with null bytes.

##### SeekRelative(offset As Integer) As Void

Seeks to the specified offset relative to the current position. If the ultimate offset is beyond the end of the file, then the file will be extended as described in `SeekAbsolute()`.

##### SeekToEnd() As Void

Seeks to the end of the file.

##### CurrentPosition() As Integer

Retrieves the current position within the file.

 [](http://docs.brightsign.biz/display/DOC/roCreateFile)
----
developers\developers\brightscript\object-reference\file-objects.md
# File Objects

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

This section describes objects for creating, deleting, and manipulating files. The JavaScript equivalent is the `fs` (file) API.

Manipulating the file system does not require you to create an object. You can find documentation on creating and deleting directories and files, along with other file system manipulation functions, on [this page](../object-reference/global-functions.md).

*   [roAppendFile](./file-objects/roappendfile.md)
*   [roCreateFile](./file-objects/rocreatefile.md)
*   [roReadFile](./file-objects/roreadfile.md)
*   [roReadWriteFile](./file-objects/roreadwritefile.md)
----
developers\developers\brightscript\object-reference\global-functions.md
# Global Functions

BrightScript provides a set of standard, module-scope functions that are stored in the global object. If a global function is referenced, the compiler directs the runtime to call the appropriate global object member. When calling a global function, you do not need to use the [dot operator](../../brightscript/language-reference/operators.md) to reference the *roGlobal* object.

> [!NOTE]
> Global trigonometric functions accept and return values in radians, not degrees.

## ifGlobal

##### CreateObject(name As String) As Object

Creates a BrightScript object corresponding to the specified class name. This method returns invalid if object creation fails. Some objects have parameters in their constructor, which must be passed after the class `name` in a comma-separated list.

```
sw = CreateObject("roGpioControlPort")
serial = CreateObject("roSerialPort", 0, 9600)
```

##### RestartScript() As Void

Exits the current script. The system then scans for a valid *autorun.brs* file to run.

##### RestartApplication() As Void

Restarts the BrightSign application.

##### Sleep(milliseconds As Integer)

Instructs the script to pause for a specified amount of time without wasting CPU cycles. The sleep interval is specified in milliseconds.

##### asc(letter As String) As Integer

Returns the ASCII code for the first character of the specified string. A null-string argument will cause an error.

##### chr(character As Integer) As String

Returns a one-character string containing a character reflected by the specified ASCII or control. For example, because quotation marks are normally used as string delimiters, you can pass ASCII code 34 to this function to add quotes to a string.

##### len(target\_string As String) As Integer

Returns the number of characters in a string

##### str(value As Double) As String

Converts a specified float value to a string. This method also returns a string equal to the character representation of a value. For example, if A is assigned a value of 58.5, then calling `str(A)` will return "58.5" as a string.

##### strI(value As Integer) As String

Converts a specified integer value to a string. This method returns a string equal to the character representation of a value, and it will always add a leading space to non-negative numbers. For example, if A is assigned a value of 58.5, then calling `stri(A)` will return " 58" as a string.

See [roInt,roFloat,roString-ToStr()AsString](https://docs.brightsign.biz/display/DOC/roInt%2C+roFloat%2C+roString#roInt,roFloat,roString-ToStr()AsString) if you need an alternate method that will return the string without the prepended space.

##### val(target\_string As String) As Double

Returns a number represented by the characters in the string argument. This is the opposite of the `str()` function. For example, if A is assigned the string "58", and B is assigned the string "5", then calling `val(A+"."+B)` will return the float value 58.5.

##### strtoi(target\_string As String) As Integer

Converts the target string to an integer. Any non-integer characters (including decimal points and spaces), and any numbers to the right of a non-integer character, will not be part of the integer output.

##### abs(x As Double) As Double

Returns the absolute value of the argument `x`

##### atn(x As Double) As Double

Returns the arctangent (in radians) of the argument `x` (i.e. `Atn(x)` returns "the angle whose tangent is `x`"). To get the arctangent in degrees, multiply `Atn(x)` by 57.29578.

##### csng(x As Integer) As Float

Returns a single-precision float representation of the argument `x`

##### cdbl(x As Integer) As Double

Returns a double-precision float representation of the argument `x`

##### cint(x As Double) As Integer

Returns an integer representation of the argument `x` by rounding to the nearest whole number.

##### cos(x As Double) As Double

Returns the cosine of the arugment `x`. The argument must be in radians. To obtain the cosine of `x` when `x` is in degrees, use `Cos(x*.01745329)`.

##### exp(x As Double) As Double

Returns the natural exponential of `x`. This is the inverse of the `log()` function.

##### fix(x As Double) As Integer

Returns a truncated representation of the argument `x`. All digits to the right of the decimal point are removed so that the resultant value is an integer. For non-negative values of *x*, `fix(x)` is equal to `int(x)`. For negative values of `x`, `fix(x)` is equal to `int(x)+1`.

##### int(x As Double) As Integer

Returns an integer representation of the argument `x` using the largest whole number that is not greater than the argument. For example, `int(2.2)` returns 2, while `int(-2.5)` returns -3.

##### log(x As Double) As Double

Returns the natural logarithm of the argument `i` (i.e. *loge(x)*). This is the inverse of the `exp()` function. To find the logarithm of a number to a base *b*, use the following formula*: logb(x) = loge(x)/loge(b)*.

##### sgn(x As Double) As Integer

Returns an integer representing how the float argument *x* is signed: -1 for negative, 0 for zero, and 1 for positive.

##### sgnI(x As Integer) As Integer

Returns an integer representing how the integer argument *x* is signed: -1 for negative, 0 for zero, and 1 for positive.

##### sin(x As Double) As Double

Returns the sine of the argument `x`. The argument must be in radians. To obtain the sine of `x` when `x` is in degrees, use `sin(x*.01745329)`.

##### tan(x As Double) As Double

Returns the tangent of the argument `x`. The argument must be in radians. To obtain the tangent of *x* when *x* is in degrees, use `tan(x*.01745329)`.

##### sqr(x As Double) As Double

Returns the square root of the argument `x`. This function is the same as *x^(1/2)*, but calculates the result faster.

##### StableEnumeration(array as Object) As Object

Returns an object that represents the iteration. This function does not affect the original object. Must use this function to safely enumerate containers more than once in parallel.

##### Left(target\_string As String, n As Integer) As String

Returns the first `n` characters of the specified string.

##### Right(target\_string As String, n As Integer) As String

Returns the last `n` characters of the specified string.

##### StringI(n As Integer, character As Integer) As String

Returns a string composed of a character symbol repeated `n` times. The character symbol is passed to the method as an ASCII code integer.

##### String(n As Integer, character As String) As String

Returns a string composed of a character symbol repeated `n` times. The character symbol is passed to the method as a string.

##### Mid(target\_string As String, start\_position As Integer, length As Integer) As String

Returns a substring of the target string. The first integer passed to the method specifies the starting position of the substring, and the second integer specifies the length of the substring. The start position of a string begins with 1.

##### Instr(start\_position As Integer, search\_text As String, substring As String) As Integer 

Returns the position of a substring within a string. This function is case sensitive and returns 0 if the specified substring is not found. The start position of a string begins with 1.

> [!TIP]
> **Tip**
> The string object also offers an `Instr()` method (though it uses a zero-based index). See the [*roString*](../object-reference/brightscript-core-objects/roint-rofloat-rostring.md) documentation for more details.

##### FindMemberFunction(object as Object, funName as String) As Interface

Returns the interface from the object that provides the specified function, or else returns `invalid`. It is only available if `roDeviceInfo.HasFeature("FindMemberFunction")` returns `true`.

It can be used as shown below:

```
print FindMemberFunction({}, "Count") '= <Interface: ifAssociativeArray>
```

##### GetInterface(object As Object, ifname As String) As Interface

Returns a value of the type Interface. All objects have one or more interfaces. In most cases, you can skip interface specification when calling an object component. This will not cause problems as long as the method names within a function are unique.

##### Wait(timeout As Integer, port As Object) As Object

Instructs the script to wait on an object that has an *ifMessagePort* interface. This method will return the event object that was posted to the message port. If the timeout is specified as zero, `Wait()` will wait indefinitely; otherwise, `Wait()` will return Invalid after the specified number of milliseconds if no messages have been received.

```
p =   CreateObject("roMessagePort")
sw =  CreateObject("roGpioControlPort")
sw.SetPort(p)
msg=wait(0, p)      
print type(msg)     ' should be roGpioButton
print msg.GetInt()  ' button number
```

##### ReadAsciiFile(file\_path As String) As String

Reads the specified text file and returns it as a string.

##### WriteAsciiFile(file\_path As String, buffer As String) As Boolean

Creates a text file at the specified file path. The text of the file is passed as the second parameter. This method cannot be used to edit files: A preexisting text file will be overwritten if it has the same name and directory path as the one being created.

> [!NOTE]
> The [*roCreateFile*](../object-reference/file-objects/rocreatefile.md) object provides more flexibility if you need to create or edit files.

##### ListDir(path As String) As Object

Returns an [*roList*](../object-reference/brightscript-core-objects/rolist.md) object containing the contents of the specified directory path. File names are converted to all lowercase.

##### MatchFiles(path As String, pattern\_in As String) As Object

Takes a directory to look in (it can be as simple as "." or "/") and a pattern to be matched and then returns an [*roList*](../object-reference/brightscript-core-objects/rolist.md) containing the results. Each listed result contains only the part of the filename that is matched against the pattern, not the full path. The match is only applied in the specified directory; you will get no results if the pattern contains a directory separator. The pattern is a case insensitive wildcard expression. It may contain the following special characters:

*   ? – Matches any single character.
    
*   \* – Matches zero or more arbitrary characters.
    
*   \[…\] – Matches any single character specified within the brackets. The closing bracket is treated as a member of the character class if it immediately follows the opening bracket (i.e. "\[\]\]" matches a single closed bracket). Within this class, "-" can be used to specify a range unless it is the first or last character (e.g. "\[A-Cf-h"\] is equivalent to "\[ABCfgh\]"). A character class may be negated by specifying "^" as the first character. To match a literal of this character, place it elsewhere in the class.
    

> [!NOTE]
> The special characters "?", "\*", and "\[" lose their function if preceded by a single "\\", and a single "\\" can be matched using "\\\\".

##### LCase(target\_string As String) As String

Converts the specified string to all lowercase.

##### UCase(target\_string As String) As String

Converts the specified string to all uppercase.

##### DeleteFile(file\_path As String) As Boolean

Deletes the file at the specified file path. This method returns False if the delete operation fails or if the file does not exist.

##### DeleteDirectory(directory As String) As Boolean

Deletes the specified directory. This method will recursively delete any files and directories that are necessary for removing the specified directory. This method returns `False` if it fails to delete the directory, but it may still delete some of the nested files or directories.

For example:

```
dir = DeleteDirectory("/directory")
' Check if directory deletion was successful
print dir; ' true if successful
```

or

```
dir = DeleteDirectory("/directory")
if not dir then
  print "Could not delete directory"
end if
```

##### CreateDirectory(directory As String) As Boolean

Creates the specified directory. Only one directory can be created at a time. This method returns `True` upon success and `False` upon failure.

For example:

```
dir = CreateDirectory("/directory")
' Check if directory creation was successful
print dir; ' true if successful
```

or

```
dir = CreateDirectory("/directory")
if not dir then
  print "Could not create directory"
end if
```

##### RebootSystem() As Void

Instructs the player to perform a soft reboot.

##### ShutdownSystem() As Void  
 

##### UpTime(dummy As Integer) As Double

Returns the uptime of the system (in seconds) since the last reboot.

##### FormatDrive(drive As String, fs\_type As String) As Boolean 

Formats the specified drive using one of the file systems listed below. This function returns True upon success and False upon failure:

*   `vfat` (FAT32, DOS/Windows file system): Readable and writable by Windows, Linux, and MacOS.
    
*   `exfat` (DOS/Windows file system): Supported on Series 3 (XTx43, XDx33, HDx23, LS423, HO523) and Series 4 (XTx44, XDx34, HDx24, LS424) players with firmware versions 6.2.94 and later. Secure boot is not supported with the exFAT filesystem on firmware version 6.2.94.
    
*   `ext2` (Linux file system): Writable by Linux and readable by Windows and MacOS with additional software.
    
*   `ext3` (Linux file system): Writable by Linux and readable by Windows and MacOS with additional software. 
    
*   `ext4` (Linux file system): Writable by Linux and readable by Windows and MacOS with additional software. This is the recommended file system for SSD devices and USB hard drives.
    

##### EjectDrive(drive As String) As Boolean

Ejects the specified drive (e.g. "SD:") and returns True if successful. If the script is currently accessing files from the specified drive, the ejection process will fail.

##### CopyFile(source As String, destination As String) As Boolean

Copies the file at the specified source file-path to the specified destination directory. The function returns True if successful and False in the event of failure.

##### MoveFile(source As String, destination As String) As Boolean

Moves the specified source file to the specified destination directory. The function returns True if successful and False in the event of failure.

> [!NOTE]
> Both path names must be on the same drive.

##### MapFilenameToNative(path As String) As String

Converts the specified BrightScript-style path to the corresponding native path and returns it as a string (e.g. the path "SD:/mydir" will be returned as "/storage/sd/mydir").

##### rnd(a As Dynamic) As Dynamic

##### RunGarbageCollector() As roAssociativeArray

Destroys objects that are currently in a state of circular reference counting. BrightScript normally removes any objects that become unreferenced as part of its automated garbage collection algorithm. However, objects that reference each other will never reach a reference count of zero, and will need to be destroyed manually using this method.

This method is useful when destroying old presentation data structures and generating a new presentation. This method returns an associative array outlining the results of the garbage-collection process.

##### GetDefaultDrive() As String

Returns the current default drive complete with a trailing slash. When running as *autorun.brs*, the drive containing the autorun is designated as the current default.

##### SetDefaultDrive(drive As String)

Sets the current default drive, which does not need to include a trailing slash. This method does not fail; however, if the specified default drive does not exist, it will not be possible to retrieve anything.

This method accepts the following values:

*   `"USB1:"` – The drive for USB storage devices connected to the player
    
*   `"SD:"` – The primary SD or microSD drive on the player.
    
*   `"SD2:"` – The internal microSD drive on the player (4Kx42, XDx32 models only)
    
*   `"SSD:"` – The internal SSD on the player (XTx44, XTx34, XDx34, XDx33 models only)
    

##### EnableZoneSupport(enable As Boolean)

Allows for display of multiple video, HTML, image, and text zones. As of firmware 6.0.x, zone support is enabled by default.

##### EnableAudioMixer(enable As Boolean)

##### Pi() As Double

Returns the value of pi as a double-precision floating-point number.

##### ParseJson(json\_string As String) As Object

Parses a string formatted according to the RFC4627 standard and returns an equivalent BrightScript object, which can consist of the following: Booleans, integers, floating point numbers, strings, *roArray* objects, and *roAssociativeArray* objects. The  `ParseJson()` method has the following properties:

*   Invalid will be returned if the string is not syntactically correct.
    
*   Any *roAssociativeArray* objects that are returned will be case sensitive.
    
*   An error will be returned if an *roArray* or *roAssociativeArray* is nested more than 256 levels deep.
    

The following script demonstrates how to use `ParseJson()` to process a JSON object containing the titles and URLs of a set of images.

##### JSON Script

```
{
"photos" : [
        { 
              "title" : "View from the hotel",
              "url" : "http://example.com/images/00012.jpg" 
        },
        { 
              "title" : "Relaxing at the beach",
              "url" : "http://example.com/images/00222.jpg" 
        },
        { 
              "title" : "Flat tire",
              "url" : "http://example.com/images/00314.jpg" 
        }
]
}
```

##### BrightScript

```
searchRequest = CreateObject("roUrlTransfer")
searchRequest.SetURL("http://api.example.com/services/rest/getPhotos")
response = ParseJson(searchRequest.GetToString())
For Each photo In response.photos
        GetImage(photo.title, photo.url)
End For
```

##### FormatJson(json As roAssociativeArray, flags As Integer) As String

Converts an associative array to a JSON string (i.e. formatted according to the RFC4627 standard). The following are supported data types: Boolean, Integer, Float, String, *roArray*, and *roAssociativeArray*. If the `flags` parameter is set to 0 or not specified, non-ASCII characters are escaped in the output string as “\\uXXXX”, where “XXXX” is the hexadecimal representation of the Unicode character value. If the `flags` parameter is set to 1, non-ASCII characters are not escaped.

If arrays or associative arrays are nested more than 256 levels deep, an error will occur. If an error occurs, an empty string will be returned.

> [!CAUTION]
> **Important**
> By default, using object-literal syntax (e.g. `aa={relativePath:"Foo"}`) to generate an associative array will convert keys to all lower case. To preserve camel case for JSON, use the *roAssociativeArray.AddReplace()* method instead of object literals or call *roAssociativeArray.SetModeCaseSensitive()* before adding entries.
----
developers\developers\brightscript\object-reference\hashing-and-storage-objects\roblockcipher.md
# roBlockCipher

This object provides a means for symmetric block encryption. It currently supports AES and CBC ciphers, at block sizes of 128, 192, or 256 bits. The JavaScript equivalent is the Node.js Crypto API.

Object Creation: The *roBlockCipher* object is created with an associative array representing a set of parameters.

```
CreateObject("roBlockCipher", parameters As roAssociativeArray)
```

The associative array should contain the following parameters:

*   mode: `"aes-128-cbc"`, `"aes-192-cbc"`, or `"aes-256-cbc"`
    
*   padding: `"zero"` or `"pkcs7"`. The object defaults to zero padding if this parameter is omitted.
    

Padding is required for inputs that are not an exact multiple of the cipher block size. Specifying `"zero"` will add padding only when needed, while specifying `"pkcs7"` always adds padding, even if the data is already a multiple of the block size (in this case, an entire block will be added). PKCS#7 padding is automatically removed upon decryption, and zero padding will be retained since there are no means to unambiguously distinguish pad values from data.

## ifBlockCipher

##### SetIV(iv As Object) As Void

Sets the Initialization Vector (IV) for CBC (Cipher-Block-Chaining) modes. If the supplied IV is shorter than required, then it will be zero padded (passing an empty string will set the vector to all zeroes). The IV will typically contain arbitrary characters and be in the form of an *roByteArray*, though it can also be a string.

##### Encrypt(key As Object, plaintext As Object) As roByteArray

Uses the specified key to encrypt the plaintext parameter, which can be passed as either a string or an *roByteArray*.

##### Decrypt(key As Object, cipher\_text As Object) As roByteArray

Uses the specified key to decrypt cipher text, which should be passed as an *roByteArray*. Because the cipher text is encrypted, it can contain any character.

##### **Example**

```
' This is Case#4 from RFC3602
key = CreateObject("roByteArray")
iv = CreateObject("roByteArray")
plain = CreateObject("roByteArray")
key.FromHexString("56e47a38c5598974bc46903dba290349")
iv.FromHexString("8ce82eefbea0da3c44699ed7db51b7d9")   plain.FromHexString("a0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedf")
c = CreateObject("roBlockCipher", { mode: "aes-128-cbc" })
c.SetIV(iv)
crypt = c.Encrypt(key, plain)
result = crypt.ToHexString()
expected = UCase("c30e32ffedc0774e6aff6af0869f71aa0f3af07a9a31a9c684db207eb0ef8e4e35907aa632c3ffdf868bb7b29d3d46ad83ce9f9a102ee99d49a53e87f4c3da55")


' Decrypt example to recover the encrypted data
c.SetIV(iv)
roundtrip = c.Decrypt(key, crypt)


' Second example selecting PKCS#7 padding
c = CreateObject("roBlockCipher", { mode: "aes-128-cbc", padding: "pkcs7" })
```
----
developers\developers\brightscript\object-reference\hashing-and-storage-objects\robrightpackage.md
# roBrightPackage

An *roBrightPackage* object represents a *.zip* file, which can include arbitrary content or be installed on a storage device to provide content and script updates (for example, to distribute updates via USB thumb drives). The JavaScript equivalent is the Node.js Zlib API.

Object Creation: The *roBrightPackage* object is created with a filename parameter that specifies the name of the *.zip* file.

```
CreateObject("roBrightPackage", filename As String)
```

**Limitations**

The *roBrightPackage* object supports *.zip* files that are smaller than 4GB only.

**Supported Technologies**

*   deflate32 (with default options)
    
*   PPMd (with default options)
    
*   WinZip (with "No compression", "Maximum", and "SuperFast" options; other options, including "Enhanced Deflate", are not supported)
    
*   AES encryption
    

**Unsupported Technologies**

*   bzip2
    
*   LZMA
    
*   Deflate64
    
*   zip64 (i.e. the compression software built in to Windows Explorer)
    

## ifBrightPackage

> [!NOTE]
> *ifBrightPackage* is a legacy interface. We recommend you use *roAssetPool* instead to achieve better functionality.

##### Unpack(path As String) As Void

Extracts the *.zip* file to the specified destination path. Any preexisting files in the target directory will be deleted as part of this operation. Providing a destination path of "SD:/" will wipe all preexisting files from the card and extract the *.zip* contents to the root folder.

##### SetPassword(password As String) As Void

Provides the password specified when the *.zip* file was created. This method supports AES 128 and 256 bit encryption, as generated by WinZip.

##### GetFailureReason() As String  
 

##### UnpackFile(a As String, b As String) As Boolean

##### **Example**

```
package = CreateObject("roBrightPackage", "newfiles.zip")
package.SetPassword("test")
package.Unpack("SD:/")
```

## Using roBrightPackage for Content Updates

BrightSign players check storage devices for autorun scripts in the following order:

1.  External USB devices 1 through 9
    
2.  SD
    
3.  µSD
    

In addition to looking for *autorun.brs* scripts, BrightSign players look for *autorun.zip* files that contain the script name *autozip.brs*. If an *autorun.zip* file with an *autozip.brs* file is found, and *autozip.brs* can be decrypted, then the player will execute the *autozip.brs* file.

> [!CAUTION]
> **Important**
> The *autozip.brs* file cannot reference any external files, as it is the only file to be automatically uncompressed by a BrightSign player prior to execution.

The *autozip.brs* script should unpack the contents of the *autorun.zip* file to an installed storage device and reboot to complete the update:

##### **Example**

```
package = CreateObject("roBrightPackage", "SD:/autorun.zip")
package.Unpack("SD:/")
MoveFile("SD:/autorun.zip", "SD:/autorun.zip_invalid")
RebootSystem()
```

### Unpacking Encrypted Archives

If the *autorun.zip* file is encrypted, then the player uses the password stored in the [registry](../hashing-and-storage-objects/roregistry.md), in the section "security" under the name "autozipkey," to decrypt the file.

##### **Extended Example**

```
' Content update application


r=CreateObject("roRectangle", 20, 668, 1240, 80)
t=CreateObject("roTextWidget",r,1,2,1)
r=CreateObject("roRectangle", 20, 20, 1200, 40)
t.SetSafeTextRegion(r)
t.SetForegroundColor(&hff303030)
t.SetBackgroundColor(&hffffffff)
t.PushString("Updating content from USB drive, please wait...")


package = CreateObject("roBrightPackage", "autorun.zip")
package.SetPassword("test")
package.Unpack("SD:/")
package = 0


t.Clear()
t.PushString("Update complete - remove USB drive to restart.")


while true
       sleep(1000)


       usb_key = CreateObject("roReadFile", "USB1:/autorun.zip")
       if type(usb_key) <> "roReadFile" then
             a=RebootSystem()
       endif
       usb_key = 0
end while
```
----
developers\developers\brightscript\object-reference\hashing-and-storage-objects\rodiskerrorevent.md
# roDiskErrorEvent

This object is returned while waiting on a message port that is connected to an *roDiskMonitor* object.

## ifUserData

##### SetUserData(user\_data As Object)

Sets the user data that will be returned when events are raised.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()`. It will return Invalid if no data has been set

## ifDiskErrorEvent

##### GetDiskError() As Object

Returns an *roAssociativeArray* containing the following parameters:

|     |     |     |
| --- | --- | --- |
| **Key** | **Type** | **Description** |
| source | *roString* | The error type |
| time | *roDateTime* | The time at which the error occurred (with millisecond accuracy) |
| device | *roString* | The internal name for the device generating the error |
| error | *roString* | A description of the error (e.g."Timeout") |
| param | *roString* | The error parameter (use depends on type of error (e.g. the sector number)) |

Example:

```
aa = msgp.GetDiskError()
report = "Time: " + aa["Time"] + "Error: " + aa["source"] + " " + aa["error"] + " " + aa["device"] + " " + aa["param"]
```

> [!NOTE]
> This example uses an implicit conversion of *roDateTime*. You could also use *roDateTime.GetString()*.
----
developers\developers\brightscript\object-reference\hashing-and-storage-objects\rodiskmonitor.md
# roDiskMonitor

This object provides access to low-level information about disk errors. It provides an event-based interface that delivers *roDiskErrorEvent* objects via *roMessageport*. Error messages are held for five seconds before delivery to minimize the chance of spurious error reports. Errors are not reported if the disk is removed during this five second interval because disk-removal detection takes several seconds. This allows for long-term monitoring of occasional media errors.

Object Creation: The *roDiskMonitor* object is created with no parameters.

```
CreateObject("roDiskMonitor")
```

## ifMessagePort

##### SetPort(port As roMessagePort)

Posts messages of type *roDiskErrorEvent* to the attached message port. 

## ifUserData

##### SetUserData(user\_data As Object)

Sets the user data that will be returned when events are raised.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()`. It will return Invalid if no data has been set.

##### **Example**

```
diskmon=CreateObject("roDiskMonitor")
 
msgp=CreateObject("roMessagePort")
diskmon.Setport(msgp)
```
----
developers\developers\brightscript\object-reference\hashing-and-storage-objects\rohashgenerator.md
# roHashGenerator

This object allows you to generate a variety of message digests. The JavaScript equivalent is the Node.js Crypto API.

Object Creation: The hashing algorithm is specified when creating the *roHashGenerator* object.

```
CreateObject("roHashGenerator", algorithm As String)
```

The algorithm parameter accepts the following strings:

*   "SHA256"
    
*   "SHA384"
    
*   "SHA512"
    
*   "SHA1"
    
*   "MD5"
    
*   "CRC32"
    

> [!NOTE]
> CRC32 is only available on firmware versions 4.4.x or later.

## ifHashGenerator

##### Hash(obj As Object) As Object

Hashes the payload, which can be supplied in the form of a string (or any object implementing *ifString*) or an *roByteArray*. The hash is returned as an *roByteArray*.

##### SetHmacKey(key As Dynamic) As Boolean

Supplies a cryptographic key for the hashing function. This method accepts a plain-text key.

##### SetObfuscatedHmacKey(key As String) As Boolean

Supplies a cryptographic key for the hashing function. This method accepts a key that is obfuscated using a shared secret.

##### GetFailureReason() As String
----
developers\developers\brightscript\object-reference\hashing-and-storage-objects\ropasskey.md
# roPassKey

This object provides a means for generating keys (hashes) from a password and salt. The JavaScript equivalent is the Node.js Crypto API.

Object Creation: The object is passed an associative array that specifies the generation methods and cipher.

```
CreateObject("roPassKey", parameters As roAssociativeArray)
```

The associative array should contain the following parameters:

*   `method`: The key derivation method. Currently, only "pbkdf2" can be specified.
    
*   `keyfn`: The pseudorandom function (PRF). Currently, only "hmac-sha256" can be specified.
    
*   `keylen`: The key length
    
*   `iterations`: The number of iterations
    

## ifPassKey

##### GenerateKey(password As Object, salt As Object) As roByteArray

Generates a key using the supplied password and salt. The parameters may be passed as either strings or *roByteArray* instances. The generated *roByteArray* instance may contain all possible byte values, including NUL.

##### GenerateSalt(length As Integer) As roByteArray

Generates a salt of the specified length. This salt can be used when calling the `GenerateKey()` method. The generated *roByteArray* instance may contain all possible byte values, including NUL.

##### **Example**

```
' Create input test data
salt = CreateObject("roByteArray")
pass = CreateObject("roByteArray")
pass.FromAsciiString("password")
salt.FromAsciiString("salt")
' Create the key generator
pk = CreateObject("roPassKey",  { method: "pbkdf2", keyfn: "hmac-sha256", keylen: 32, iterations: 4096 } )
' key with be a roByteArray
key = pk.GenerateKey(pass, salt)
```
----
developers\developers\brightscript\object-reference\hashing-and-storage-objects\roregistry.md
# roRegistry

The registry is an area of memory where a small number of persistent settings can be stored. Access to the registry is available through the *roRegistry* object. The JavaScript equivalent is [registry](https://docs.brightsign.biz/display/DOC/registry) (see [BrightScript-JavaScript Migration Guide](../../../../developers/player-apis/brightscript-javascript-migration-guide.md) for the method equivalents).

This object is created with no parameters:

```
CreateObject("roRegistry")
```

## ifRegistry

##### GetSectionList() As roList

Returns a list with one entry for each registry section.

##### Delete(section As String) As Boolean

Deletes the specified section and returns an indication of success.

##### Flush() As Boolean

Flushes the registry out to persistent storage.
----
developers\developers\brightscript\object-reference\hashing-and-storage-objects\roregistrysection.md
# roRegistrySection

This object represents a section of the registry, enabling the organization of settings within the registry. It allows the section to be read or written. The JavaScript equivalent is [registry](https://docs.brightsign.biz/display/DOC/registry) (see [BrightScript-JavaScript Migration Guide](../../../../developers/player-apis/brightscript-javascript-migration-guide.md) for the method equivalents).

Object Creation: This object must be supplied with a registry-section name upon creation.

```
CreateObject("roRegistrySection", section As String)
```

Writes do not always take effect immediately to prevent the system from exceeding the maximum number of writes on the onboard persistent storage. At most, 60 seconds after a write to the registry, the newly written data will be automatically written out to persistent storage. If, for some reason, the change must be written immediately, then the `Flush()` method should be called. All changes will be written automatically prior to exiting the application.

## ifRegistrySection

##### Read(key As String) As String

Reads and returns the value of the specified key. Performing `Read()` on an entry that does not exist, or on a key within a section that does not exist, will return an empty string ("").

##### Write(key As String, value As String) As Boolean

Replaces the value of the specified key.

##### Delete(key As String) As Boolean

Deletes the specified key.

##### Exists(key As String) As Boolean

Returns True if the specified key exists.

##### Flush() As Boolean

Flushes the contents of the registry out to persistent storage.

##### GetKeyList() As roList

Returns a list containing one entry per registry key in this section.

##### **Example**

```
registrySection = CreateObject("roRegistrySection", "widget-usage")
' An empty entry will read as an empty string and therefore be converted to zero.
hits = val(registrySection.Read("big-red-button-hits"))
hits = hits + 1
registrySection.Write("big-red-button-hits", strI(hits))
```
----
developers\developers\brightscript\object-reference\hashing-and-storage-objects\rosqlitedatabase.md
# roSqliteDatabase

This is the main SQLite object that "owns" the database. You can create as many of these objects as you need. The JavaScript equivalent is to use the IndexedDB.

## ifSqliteDatabse

##### Open(path As String) As Boolean

Opens an existing database file. This method returns `True` upon success.

##### Create(path As String) As Boolean

Creates a new, empty database file. This method returns `True` upon success.

Passing `":memory:"` to this method creates a database in non-persistent storage. This is useful for high-volume database applications that might cause wear issues on an SD card. 

##### Close()

Closes an open database.

##### CreateStatement(sql\_text As String) As Object

Creates a new *roSqliteStatement* object using the specified SQL string.

##### RunBackground(sql\_text As String, associative\_array As Object) As Integer

Runs the specified SQL statement in the background and binds variables using the passed *roAssociativeArray*.

##### SetMemoryLimit(limit As Integer)

Sets the "soft" memory limit under which SQLite will attempt to remain (see the SQLite documentation for details).

> [!NOTE]
> The `SetMemoryLimit()` method sets global parameters. It must, therefore, be called before any other calls are made on the database object.

## ifMessagePort

##### SetPort(port As roMessagePort)

Posts messages of type *roSqliteEvent*  to the attached message port.

## Examples

Creating a database:

```
db = CreateObject("roSqliteDatabase")
 
print db
 
openResult = db.Create("SD:/test.db")
 
if openResult
    print "Created OK"
else
    print "Creation FAILED"
    end
endif
```

Creating a table in a database:

```
createStmt = db.CreateStatement("CREATE TABLE playback (md5 text PRIMARY KEY, path PATH, playback_count INT);")

print createStmt

if type(createStmt) <> "roSqliteStatement" then
    print "We didn't get a statement returned!!"
    end
endif

sqlResult = createStmt.Run()

print sqlResult

if sqlResult = SQLITE_COMPLETE
    print "Table Created OK"
else
    print "Table Creation FAILED"
endif

createStmt.Finalise()
```
----
developers\developers\brightscript\object-reference\hashing-and-storage-objects\rosqliteevent.md
# roSqliteEvent

This event object is returned when a `RunBackground()` operation is called by the associated *roSqliteDatabase* object.

## ifSqliteEvent

##### GetTransactionId() As Integer

Returns an integer that matches the result of the originating `RunBackground()` operation.

##### GetSqlResult() As Integer

Returns the result code returned by the *roSqliteStatement.Run()* method. The possible return values are identical to the `Run()` method:

*   100: Statement complete
    
*   101: Busy
    
*   102: Rows available
    

> [!NOTE]
> This method can be used as the asynchronous alternative to the `Run()` method.
----
developers\developers\brightscript\object-reference\hashing-and-storage-objects\rosqlitestatement.md
# roSqliteStatement

This object is created by calling the `CreateStatement()` method on an *roSqliteDatabase* object. The JavaScript equivalent is to use the IndexedDB.

## ifSqliteStatement

All *bind* methods return True upon success.

##### BindByName(associative\_array As Object) As Boolean

Binds the SQL variable(s) using the names contained in the SQL statement.

##### BindByOffset(associative\_array/enumerable As Object) As Boolean

Binds the SQL variable(s) using the index contained in the SQL statement. If passed an associative array, this method will convert the keys of the associative array into numeric offsets when binding. If passed an enumerable object (e.g. *roArray*), it will bind the values of the enumerable in the order that they are stored.

##### BindText(variable/index As Object, value As String) As Boolean

Binds the SQL variable indicated by the name or index parameter to the passed string value.

##### BindInteger(variable/index As Object, value As Integer) As Boolean

Binds the SQL variable indicated by the name or index parameter to the passed integer value.

##### Run() As Integer

Runs the SQL statement immediately and waits for the integer result. The following are possible integer result codes:

*   100: Statement complete
    
*   101: Busy
    
*   102: Rows available
    

##### RunBackground() As Integer

Runs the SQL statement in the background. You can use *roSqliteDatabase.SetPort()* to set a message port that will receive an *roSqliteEvent* message at a later point. The RunBackground() call will result in an integer transaction ID, which will appear in the *roSqliteEvent* message that matches the transaction.

##### GetData() As Object

Returns an associative array of name/value pairs that are available after a SELECT (or similar) operation.

##### Finalise()

Finalizes the statement. This method should be applied to statements before the parent database is closed. The object should not be used after this method is called. Also note that objects are automatically finalized when they are deleted.

## Examples

The following script inserts into a table using the `BindByName()` method:

```
insertStmt = db.CreateStatement("INSERT INTO playback (md5,path,playback_count) VALUES(:md5_param,:path_param,:pc_param);")

print insertStmt

if type(insertStmt) <> "roSqliteStatement" then
    print "We didn't get a statement returned!!"
    end
endif

params = { md5_param: "ABDEF12346",  path_param: "/foo/bar/bing/bong", pc_param: 11 }

bindResult = insertStmt.BindByName(params)

if bindResult
    print "BindByName OK"
else
    print "BindByName FAILED"
    end
endif

sqlResult = insertStmt.Run()

print sqlResult

if sqlResult = SQLITE_COMPLETE
    print "Table Insertion OK"
else
    print "Table Insertion FAILED"
endif

insertStmt.Finalise()
```

The following script inserts into a table in the background:

```
' This examples assume you have set a message port on your roSqliteDatabase instance
'

insertStmt = db.CreateStatement("INSERT INTO playback (md5,path,playback_count) VALUES(:md5_param,:path_param,:pc_param);")

print insertStmt

if type(insertStmt) <> "roSqliteStatement" then
    print "We didn't get a statement returned!!"
    end
endif

params = { md5_param: "ABDEF12348",  path_param: "/foo/bar/bing/bong", pc_param: 13 }

bindResult = insertStmt.BindByName(params)

if bindResult
    print "BindByName OK"
else
    print "BindByName FAILED"
    end
endif

expectedId = insertStmt.RunBackground()

e = mp.WaitMessage(10000)
if e <> invalid then
    if type(e) = "roSqliteEvent" then
        transId = e.GetTransactionId()
        sqlResult = e.GetSqlResult()
        print transId
        print sqlResult
        if transId <> expectedId then
            print "Incorrect transaction Id"
            end
        endif
        if sqlResult <> SQLITE_COMPLETE then
            print "SQL Insertion Failed"
            end
        endif
    else
        print "RunBackground() - Wrong event - FAILED"
        end
    endif
else
    print "RunBackground() - No Response - FAILED"
    end
endif

' You don't need to call Finalise() since that'll be done by the background processor.
```

The following script queries from a table:

```
selectStmt = db.CreateStatement("SELECT * FROM playback;")

if type(selectStmt) <> "roSqliteStatement" then
    print "We didn't get a statement returned!!"
    end
endif

sqlResult = selectStmt.Run()

print sqlResult

while sqlResult = SQLITE_ROWS
    resultsData = selectStmt.GetData()
    print resultsData;
    sqlResult = selectStmt.Run()
end while

selectStmt.Finalise()
```
----
developers\developers\brightscript\object-reference\hashing-and-storage-objects\rostorageattached-rostoragedetached.md
# roStorageAttached, roStorageDetached

These event objects are generated by the *roStorageHotplug* object whenever a storage device becomes attached or detached from the player. The JavaScript equivalent is Node.js `fs.watch()`.

## ifUserData

##### SetUserData(user\_data As Object)

Sets the user data that will be returned when events are raised.

##### GetUserData() As Object

Returns the user data that has previously been set via SetUserData(). It will return Invalid if no data has been set.

## ifString

##### GetString() As String  
 

##### SetString(a As String)
----
developers\developers\brightscript\object-reference\hashing-and-storage-objects\rostoragehotplug.md
# roStorageHotplug

This object provides *roStorageAttached* messages when storage devices appear and *roStorageDetached* messages when storage devices disappear. An *roStorageAttached* event is not delivered until the filesystem is mounted. The JavaScript equivalent is Node.js `fs.watch()`. 

There is currently no way to poll for media. 

Object Creation: The *roStorageHotplug* object is created with no parameters.

```
CreateObject("roStorageHotplug")
```

## ifStorageHotplug

##### GetStorageStatus(drive As String) As roAssociativeArray

Returns the current status of a storage device ("SD:", "SSD:", "USB:"), even if it is not mounted. This method returns an associative array containing the following:

| Key | Value Type | Description |
| --- | --- | --- |
| `present` | Boolean | Indicates whether the specified device is present. |
| `mounted` | Boolean | Indicates whether the specified device is mounted. |
| `corrupt` | Boolean | Indicates whether the specified device is believed to be corrupt. |
| `checking` | Boolean | Indicates whether the specified device is currently being checked. |

> [!NOTE]
> The results of the `GetStorageStatus()` method are unreliable when called with a "USBn:" parameter, where "n" is a positive integer indicating a USB storage device when multiple USB devices are connected to the player.

Example:

```
 status = CreateObject("roStorageHotplug").GetStorageStatus("SSD:")
 if not status.mounted and not status.checking and status.present then
    ' Should ask for confirmation here
    FormatDrive("SSD:")
 end if 
```

## ifFailureReason

##### GetFailureReason() As String

Returns additional diagnostic information if a method returns False.

## ifUserData

##### SetUserData(user\_data As Object)

Sets the user data that will be returned when events are raised.

##### GetUserData() As Object

Returns the user data that has previously been set via SetUserData(). It will return Invalid if no data has been set.

## ifMessagePort

##### SetPort(port As roMessagePort)

Posts messages of type *roStorageAttached* and *roStorageDetached*  to the attached message port.

> [!NOTE]
> In order to avoid race conditions at startup, you should check for any storage devices that might have existed prior to the message port being set. We recommend doing this after the object is created and the message port is set, but before instructing the script to wait for any events.

## Example

```
Sub Main()
    mp = CreateObject("roMessagePort")
    sh = CreateObject("roStorageHotplug")
    gpio = CreateObject("roControlPort", "brightsign")

    sh.SetPort(mp)
    gpio.SetPort(mp)

    finished = false
    while not finished
    ev = mp.WaitMessage(0)
    if type(ev) = "roControlDown"
        finished = true
    else if type(ev) = "roStorageAttached"
        print "ATTACHED "; ev.GetString()
    else if type(ev) = "roStorageDetached"
        print "DETACHED "; ev.GetString()
    else
        print type(ev)
        stop
    end if
    end while
End Sub 
```
----
developers\developers\brightscript\object-reference\hashing-and-storage-objects\rostorageinfo.md
# roStorageInfo

This object is used to report usage information for storage devices.

Object Creation: The *roStorageInfo* object is created with a parameter that specifies the path of the storage device. The path does not need to extend to the root of the storage device. The JavaScript equivalent is [filesysteminfo](https://docs.brightsign.biz/display/DOC/filesysteminfo) and [storageinfo](https://docs.brightsign.biz/display/DOC/storageinfo) (see [BrightScript-JavaScript Migration Guide](../../../../developers/player-apis/brightscript-javascript-migration-guide.md) for the method equivalents).

```
CreateObject("roStorageInfo", path As String) 
```

### Drive Specifications 

Use the following string values to specify different storage drives:

*   `"USB1:"` – The drive for USB storage devices connected to the player
    
*   `"SD:"` – The primary SD or microSD drive on the player.
    
*   `"SD2:"` – The internal microSD drive on the player (4Kx42, XDx32 models only)
    
*   `"SSD:"` – The internal SSD on the player (XTx44, XTx43, XDx34, and XDx33 models only)
    

## ifStorageInfo

##### GetFailureReason() As String

Yields additional useful information if a function return indicates an error.

##### GetBytesPerBlock() As Integer

Returns the size of a native block on the filesystem used by the specified storage device.

##### GetSizeInMegabytes() As Integer

Returns the total size (in mebibytes) of the storage device.

> [!CAUTION]
> **Important**
> On some filesystems that have a portion of space reserved for the super user, the following expression may not be true:  GetUsedInMegabytes() + GetFreeInMegabytes() == GetSizeInMegabytes()

##### GetUsedInMegabytes() As Integer

Returns the amount (in mebibytes) of space currently used on the storage device. This amount includes the size of the pool because this class does not integrate pools into its calculations.

##### GetFreeInMegabytes() As Integer

Returns the available space (in mebibytes) on the storage device.

##### GetFileSystemType() As String

Returns a string describing the type of filesystem used on the specified storage or whether it is encrypted (“+ecryptfs”). The following are potential values:

*   "exfat"
    
*   "ext3"
    
*   "ext4"
    
*   "fat12"
    
*   "fat16"
    
*   "fat32"
    
*   "hfs"
    
*   "hfsplus"
    
*   "ntfs"
    
*   “+ecryptfs” (as of BOS version 9.0.145.1)
    

##### GetStorageCardInfo() As roAssociativeArray

Returns an associative array containing details of the storage device hardware. For SD cards, the returned data may include the following:

|     |     |     |
| --- | --- | --- |
| `sd_mfr_id` | Integer | Card manufacturer ID as assigned by the SD Card Association |
| `sd_oem_id` | String | Two-character card OEM identifier as assigned by the SD Card Association |
| `sd_product_name` | String | Product name, assigned by the card manufacturer (5 bytes for SD, 6 bytes for MMC) |
| `sd_spec_vers` | Integer | Version of SD spec to which the card conforms |
| `sd_product_rev` | String | Product revision assigned by the card manufacturer |
| `sd_speed_class` | String | Speed class (if any) declared by the card |
| `sd_au_size` | Integer | Size of the SD AU in bytes. |

Example:

```
si=CreateObject("roStorageInfo", "SD:/")
Print si.GetFreeInMegabytes(); "MiB free"
```
----
developers\developers\brightscript\object-reference\hashing-and-storage-objects\rovirtualmemory.md
# roVirtualMemory

The *roVirtualMemory* object allows you to create a virtual memory repository for the Chromium HTML engine. This allows Chromium to automatically swap unused elements out of physical memory.

This object is only available on platforms that can support SSD/mSATA drives: XTx44, XTx43, XDx34, XDx33, and 4Kx42.

Object Creation: This object is instantiated without parameters.

```
CreateObject("roVirtualMemory")
```

## ifVirtualMemory

##### AddSwapFile(parameters As roAssociativeArray) As Boolean

Adds a virtual memory repository to local storage. This method accepts an associative array with the following parameters:

*   `filename` string: The URI of the swap file to be created. It is possible to specify a file location other than the SSD/mSATA drive, but it is not recommended.
    
*   `megabytes` int: The size of the swap file to be created.
    

If the specified file does not already exist, it will be created. If it already exists, the size will be modified. Either way, this operation can take some time, but it should only need to be called once.

##### RemoveSwapFile(filename As String) As Boolean

Removes a swap file with the specified filename.

## ifFailureReason

##### GetFailureReason() As String

Returns additional useful information when a method on the *ifVirtualMemory* interface returns `False`.
----
developers\developers\brightscript\object-reference\hashing-and-storage-objects.md
# Hashing and Storage Objects

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

This section describes objects related to local storage and the player registry, as well as generating data structures and hashing files.

*   [roBlockCipher](./hashing-and-storage-objects/roblockcipher.md)
*   [roBrightPackage](./hashing-and-storage-objects/robrightpackage.md)
*   [roDiskErrorEvent](./hashing-and-storage-objects/rodiskerrorevent.md)
*   [roDiskMonitor](./hashing-and-storage-objects/rodiskmonitor.md)
*   [roHashGenerator](./hashing-and-storage-objects/rohashgenerator.md)
*   [roPassKey](./hashing-and-storage-objects/ropasskey.md)
*   [roRegistry](./hashing-and-storage-objects/roregistry.md)
*   [roRegistrySection](./hashing-and-storage-objects/roregistrysection.md)
*   [roSqliteDatabase](./hashing-and-storage-objects/rosqlitedatabase.md)
*   [roSqliteEvent](./hashing-and-storage-objects/rosqliteevent.md)
*   [roSqliteStatement](./hashing-and-storage-objects/rosqlitestatement.md)
*   [roStorageAttached, roStorageDetached](./hashing-and-storage-objects/rostorageattached-rostoragedetached.md)
*   [roStorageHotplug](./hashing-and-storage-objects/rostoragehotplug.md)
*   [roStorageInfo](./hashing-and-storage-objects/rostorageinfo.md)
*   [roVirtualMemory](./hashing-and-storage-objects/rovirtualmemory.md)
----
developers\developers\brightscript\object-reference\inputoutput-objects\robtclient.md
# roBtClient

Each instance of this object represents a single BLE client. This object is not instantiated by the script; instead, when a BLE client connects to the player, the [*roBtClientManager*](../inputoutput-objects/robtclientmanager.md)  object sends an event to its attached message port and creates a *roBtClient* instance. The JavaScript equivalent is [BSBtManager](../../../../developers/player-apis/brightscript-javascript-objects/bsbtmanager.md).

The primary purpose of the *roBtClient* object is to transfer data between the player and the client via user variables (i.e. characteristics). When a client updates user-variables or sends a command, an  [*roBtClientEvent*](../inputoutput-objects/robtclientevent.md) is sent to the attached message port. The state can be retrieved using either the *roBtClient.GetUserVars()* method or the *roBtClientEvent.GetParam()* method: Updates from the *roBtClientEvent* object are queued until the script processes them, while the *roBtClient* object returns the most current state.

## ifBtClient

##### GetClientId() As String

Retrieves the UUID of the client associated with the object instance.

##### SetUserVars(data As String) As Boolean

Specifies new data for the client to retrieve.

##### GetUserVars() As String

Retrieves the latest data from the *roBtClient* state.

##### Disconnect() As Boolean

Forces the player to disconnect from the client.

## ifMessagePort

##### SetPort(a As Object)

Posts messages of type *roBtClientEvent* to the attached message port. An event is raised whenever the end of the queue is reached.

## ifUserData

##### SetUserData(a As Object)

Sets the user data that will be returned when events are raised.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()`. It will return Invalid if no data has been set.

## ifIdentity

##### GetIdentity() As Integer

Returns a unique number that can be used to identify *roBtClientEvent* objects that originate from this object.

> [!NOTE]
> The *ifIdentity* interface has been deprecated. We recommend using the *ifUserData* interface instead.

## ifFailureReason

##### GetFailureReason() As String

Returns additional useful information if a method on the *ifBtClient* interface returns False.
----
developers\developers\brightscript\object-reference\inputoutput-objects\robtclientevent.md
# roBtClientEvent

This event object is generated by an *roBtClient* object when a BLE client updates the *roBtClient* state or sends a command.

## ifBtClientEvent

##### GetEvent() As String

Returns the event name, which can currently be `"client-update"` or `"client-command"`

##### GetParam() As String

Returns the event data as a string

## ifUserData

##### SetUserData(user\_data As Object) As Void

Sets the user data

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()` (on either the event or source object). It will return `Invalid` if no data has been set.
----
developers\developers\brightscript\object-reference\inputoutput-objects\robtclientmanager.md
# roBtClientManager

This object represents a BLE GATT service, where the player acts as a peripheral and another device (phone, tablet, etc.) acts as the client/central. Unlike [*roBtManager*](../inputoutput-objects/robtmanager.md), which allows for unidirectional, non-connectable communication (i.e. beaconing), the *roBtClientManager* object is used to facilitate two-way, connectable communication. It provides an event to an attached message port when a new client connects. It also manages the client state, provides client update events, and times out the client after a period of inactivity. The JavaScript equivalent is [BSBtManager](../../../../developers/player-apis/brightscript-javascript-objects/bsbtmanager.md).

The BLE clients themselves are represented by the [*roBtClient*](../inputoutput-objects/robtclient.md) object. 

## ifBtClientManager

##### Start(params As roAssociativeArray) As Boolean

Starts BLE communication. This method accepts the following parameters:

*   `client_timeout`: The amount of time (in seconds) that a client can be inactive before being disconnected
    
*   `service_uuid`: A UUID that identifies the service
    
*   `clientid_uuid`: The client-identifier attribute. Once a client device connects to the player, it should write its unique client identifier value to this attribute.
    
*   `user_variable_uuid`: The user variables attribute. This attribute is intended to be writable by both the player and the client, providing the primary means for exchanging state data. User variables can be written as a JSON string.
    
*   `command_uuid`: The command attribute. When a client device writes to this attribute, an event containing the command string is generated by the associated *roBtClient* instance.
    
*   `device_info_uuid`: The attribute for device information. This attribute is read-only for clients.
    
*   `device_data_uuid`: The attribute for device data. This attribute can be used to communicate available commands to clients. It is read-only for clients.
    

> [!NOTE]
> There is a limit 512 bytes on each attribute.

##### Stop() As Boolean

Stops BLE communication.

##### SetDeviceInfo(a As Object) As Boolean  
 

##### SetDeviceData(a As Object) As Boolean

## ifMessagePort

##### SetPort(a As Object)

Posts messages of type [*roBtClientManagerEvent*](../inputoutput-objects/robtclientmanagerevent.md) to the attached message port.

## ifIdentity

##### GetIdentity() As Integer

Returns a unique number that can be used to identify [*roBtClientManagerEvent*](../inputoutput-objects/robtclientmanagerevent.md) objects that originate from this object.

> [!NOTE]
> The *ifIdentity* interface has been deprecated. We recommend using the *ifUserData* interface instead.

## ifUserData

##### SetUserData(user\_data As Object)

Sets the user data that will be returned when events are raised.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()`. It will return Invalid if no data has been set.

## ifFailureReason

##### GetFailureReason() As String

Returns additional useful information when a method on the *ifBtClientManager* interface returns False.
----
developers\developers\brightscript\object-reference\inputoutput-objects\robtclientmanagerevent.md
# roBtClientManagerEvent

This event object is generated by the  [*roBtClientManager*](../inputoutput-objects/robtclientmanager.md) object when a BLE client connects to or disconnects from the player.

## ifBtEvent

##### GetEvent() As String

Returns the name of the event, which can be one of the following:

*   `"client-new"`: This value is returned the first time a client connects only.
    
*   `"client-delete"`: This value is returned when a client reaches the `client-timeout` interval and is disconnected.
    

##### GetClient() As roBtClient

Returns the [*roBtClient*](../inputoutput-objects/robtclient.md) object for the client associated with the event.

## ifUserData

##### SetUserData(user\_data As Object) As Void

Sets the user data.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()` (on either the event or source object). It will return Invalid if no data has been set.
----
developers\developers\brightscript\object-reference\inputoutput-objects\robtmanager.md
# roBtManager

This object facilitates BLE one-way communication (i.e. "beaconing"): Use the *roBtManager* object to discover whether any BLE adapters are present and to send BLE advertisements using the adapters.

The JavaScript equivalent is [BSBtManager](../../../../developers/player-apis/brightscript-javascript-objects/bsbtmanager.md).

## ifMessagePort

##### SetPort(port As roMessagePort)

Posts messages of type *roBtEvent* to the attached message port. Use these messages to detect insertion or removal of Bluetooth adapters.

## ifUserData

##### SetUserData(user\_data As Object)

Sets the user data that will be returned when events are raised.

##### GetUserData() As Object

Retrieves an arbitrary object set via the `SetUserData()` method.

## ifIdentity

##### GetIdentity() As Integer

Returns a unique number that can be used to identify events that originate from the object instance.

> [!NOTE]
> The *ifIdentity* interface has been deprecated. We recommend using the *ifUserData* interface instead.

## ifBtPeripheralManager

##### GetFailureReason() As String

Returns additional diagnostic information if a method returns False.

##### GetAdapterList() As roArray

Returns an array describing all available Bluetooth adapters. Each entry in the array consists of an associative array containing adapter properties. At present, each associative array contains a single `name` property that describes the adapter name. Use this method to determine if Bluetooth adapters are connected to the player.

##### StopAdvertising() As Boolean

Stops all BLE advertisements. This method returns True on success and False on failure.

##### GetAdvertisingList() As roArray

Returns an array describing all active Bluetooth advertisements. Each entry in the array consists of an associative array describing a single advertisement. The associative-array values correspond to the properties set using the `StartAdvertising()` method, but can also include default parameter values that were not set explicitly. Note that all UUID values will be returned in lowercase.

##### StartAdvertising(data As roAssociativeArray) As Boolean

Begins transmitting a BLE "beacon" message. This method returns True on success and False on failure. Each message can contain data in a standard format or arbitrary custom values. The message format is specified using the `mode` parameter, and other required values in the associative array will depend on the value of this parameter:

*   `mode:"beacon"`: This mode uses a simple beaconing format.
    
    *   `beacon_uuid`: A string representation of a UUID, which can be in 16-bit, 32-bit, or 128-bit format. A 16-bit UUID must be exactly four hex digits with no punctuation;  a 32-bit UUID must be exactly eight hex digits with no punctuation; and a 128-bit UUID must be punctuated exactly as follows: "cd7b6f81-f738-4cad-aebf-d2a2ea36d996".
        
    *   `beacon_major`: An integer specifying the 2-byte Major value (0 to 65535)
        
    *   `beacon_minor`: An integer specifying the 2-byte Minor value (0 to 65535)
        
    *   `beacon_level`:(optional) An 8-bit signed integer (-127 to 128) that corresponds to the measurement of the Tx power level (in dBm) at 1 meter. The default level is -60.
        
    *   `beacon_manufacturer`:(optional) A 2-byte integer value (0 to 65535) specifying the beacon manufacturer. The default value is 76 (&H4C).
        
    *   `connectable`:(optional) A Boolean value indicating whether the advertisement should be connectable or not. Advertisements are non-connectable by default.
        
    *   `persistent`:(optional) A Boolean value indicating whether the advertisement should persist after every reboot. Beacon advertisements are persistent by default.
        
*   `mode:"eddystone-url"`: This mode uses the [Eddystone-URL](https://github.com/google/eddystone/tree/master/eddystone-url) format.
    
    *   `url`: The URL to encapsulate in the advertisement packet. If the URL is too long to fit in the packet, the `StartAdvertising()` call will return False and `GetFailureReason()` will report "Compressed URL is too long".
        
    *   `tx_power`:(optional)  An integer value that corresponds to the measurement of the Tx power level (in dBm) at 0 meters. The default value is -19, which corresponds to a level of -60dBm at 1 meter. The recommended calibration practice is to measure the RSSI in a circle at 1 meter from the beacon, then add 41 to the average measured signal strength to get the `tx_power` value: For example, measuring a -65dBm RSSI at 1 meter yields a **TxPower** value of -2
        
        *   Note that the `tx_power` value does not modify the power level of the Bluetooth transmitter (this requires [physical attenuation](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/2063892481/Accessories+FAQ#Can-I-modify-the-power-level-of-the-Bluetooth-module-transmitter%3F)). Rather, the `tx_power` value is transmitted to Bluetooth clients in the BLE advertisement. Clients can then compare this value to the current RSSI of the signal to determine their approximate distance from the beacon.
            
    *   `connectable`:(optional) A Boolean value indicating whether the advertisement should be connectable or not. Advertisements are non-connectable by default.
        
    *   `persistent`:(optional) A Boolean value indicating whether the advertisement should persist after every reboot. Eddystone-URL advertisements are persistent by default.
        
*   `mode:"eddystone-uid"`: This mode uses the [Eddystone-UID](https://github.com/google/eddystone/tree/master/eddystone-uid) format.
    
    *   `namespace`: A 10-byte value expressed as 20 hexadecimal digits
        
    *   `instance`: A 6-byte value expressed as 12 hexadecimal digits
        
    *   `tx_power`:(optional) An integer value specifying the Tx power level in dBm at 0 meters. The default value is -19, which corresponds to a level of -60dBm at 1 meter. The recommended calibration practice is to measure at 1 meter and add 41: For example, -65dBm RSSI leads to a value of -24.
        
    *   `connectable`:(optional) A Boolean value indicating whether the advertisement should be connectable (for GATT or other services).  Advertisements are non-connectable by default.
        
    *   `persistent`:(optional) A Boolean value indicating whether the advertisement should persist after every reboot. Eddystone-URL advertisements are not persistent by default.
        
*   `mode:"custom"`: This mode supports arbitrary custom data in a vendor-specific field. 
    
    *   `cutom_manufacturer_data`:(optional) An associative array containing two keys:
        
        *   `manufacturer`: A 2-byte integer value (0 to 65535)
            
        *   `data`: An *roByteArray* instance containing data
            
    *   `service_uuid`:(optional) A set of ServiceUUID elements, which can be specified as either an array of UUID strings or an array of associative arrays containing a `uuid` key/value pair. Each associative array can also contain a `data` key, which specifies ServiceData as an *roByteArray* instance.
        
    *   `connectable`:(optional) A Boolean value indicating whether the advertisement should be connectable or not. Advertisements are non-connectable by default.
        
    *   `persistent`:(optional) A Boolean value indicating whether the advertisement should persist after every reboot. Custom advertisements are not persistent by default.
        

To specify multiple advertisements, pass an array of associative arrays to the `StartAdvertising()` method. Advertisements will be sent in rotation. The method will fail if one or more advertisement is incorrect—try each advertisement individually and call `GetFailureReason()` to determine which advertisement is causing the error.

Calling the `StartAdvertising()` method will replace any previous advertisements. You can change a list of advertisements by modifying the array and calling `StartAdvertising()` again.

## Examples

This script uses *roBtManager.GetAdapterList()* to determine if there are any Bluetooth adapters available:

```
btm = CreateObject("roBtManager")
if btm.GetAdapterList().Count() > 0 then print "Bluetooth available"
```

This script constructs two associative arrays for advertising with the "beacon" format and then broadcasts them both:

```
adv1 = { mode : "beacon", beacon_uuid : "41fac2b21-c8cb-41e7-b011-12d1016dd39e", beacon_major : 400, beacon_minor : 22 }
adv2 = { mode : "beacon", beacon_manufacturer: &H4C, beacon_uuid : "41fac221-c8cb-41e7-b011-12d1016dd39e", beacon_major : &H1234, beacon_minor : &HFF01, beacon_level : -50 }
 
advlist = [adv1, adv2]
bm.StartAdvertising(advlist)
```

The associative array can also be constructed in parts:

```
adv1 = { mode: "beacon"}
adv1.Append({ beacon_uuid : "41fac221-c8cb-41e7-b011-12d1016dd39e" })
adv1.Append({ beacon_major : 32000, beacon_minor : 100 })
```

This script constructs an advertisement with the "Eddystone-URL" format. It uses the optional `tx_power` parameter as well:

```
adv1 = { mode: "eddystone-url", url: "http://www.brightsign.biz", tx_power: -24}
```

This script constructs a custom-formatted advertisement:

```
custom_adv = CreateObject("roByteArray")
custom_adv.FromHexString("0215434B2EB8C28F40898E7A1E644BB13B9FA000B001C5")
adv2 = { mode : "custom", custom_manufacturer_data : { manufacturer: &H4C, data : custom_adv } }
```
----
developers\developers\brightscript\object-reference\inputoutput-objects\rocecinterface.md
# roCecInterface

This object provides access to the HDMI® CEC channel.

Object Creation: The *roCecInterface* object is created with no parameters.

```
CreateObject("roCecInterface")
```

When possible, JavaScript APIs should be used instead of BrightScript-Javascript Objects. The JavaScript API equivalent to this object is [cec](../../../../developers/player-apis/javascript-apis/cec.md).

## IfCecInterface

##### SendRawMessage(packet As roByteArray) As Void

Sends a message on the CEC bus. The frame data should be provided as an *roByteArray*, with the destination address in the low 4 bits of the first octet.

The system software automatically replaces the high 4 bits of the first octet with the source address. It also copies the physical address of the player into the following messages automatically prior to transmission: ActiveSource, InactiveSource, SystemAudioModeRequest.

> [!NOTE]
> As of BrightSign OS 8.2.55, the CEC implementation for AU series 5 products will reply to these messages with the correct data, without involving the script:
> *   CEC\_MSG\_GET\_CEC\_VERSION
>     
> *   CEC\_MSG\_ABORT
>     
> *   CEC\_MSG\_GIVE\_DEVICE\_POWER\_STATUS
>     
> *   CEC\_MSG\_GIVE\_OSD\_NAME
>     
> *   CEC\_MSG\_GIVE\_DEVICE\_VENDOR\_ID
>     
> *   CEC\_MSG\_GIVE\_FEATURES
>     
> *   CEC\_MSG\_GIVE\_PHYSICAL\_ADDR
>     
> *   CEC\_MSG\_USER\_CONTROL\_PRESSED
>     
> *   CEC\_MSG\_USER\_CONTROL\_RELEASED
>     
> *   CEC\_MSG\_REPORT\_PHYSICAL\_ADDR

> [!TIP]
> **Tip**
> Use the `UseInitiatorAddressFromPacket()` method to prevent the system software from replacing source bits.

##### UseInitiatorAddressFromPacket(enable As Boolean) As Boolean

Removes the source address included in CEC messages by system software if passed `true`. This method allows you to transmit unmodified bytes via CEC.

##### GetLogicalAddress() As Integer

Returns the current logical address. This method will return the unregistered address (0x0f) to indicate that the logical address has not been negotiated. In this case, messages can still be sent, but the receivers will behave differently and may not process all messages.

##### EnableCecDebug(filename As String) As Void

Enables CEC debugging. This method will write a log of all CEC packets to the specified file.

##### GetPhysicalAddress() As roByteArray

Returns the CEC physical address, which is sometimes required when processing CEC messages.

##### PortName ()

Optional. This can be:

*   default: the default output for the platform, normally HDMI-1
    
*   HDMI-X : X is a number from 1 up to the number of HDMI outputs on the platform
    
*   eARC: on the AU335 (the default)
    

## ifUserData

##### SetUserData(user\_data As Object)

Sets the user data that will be returned when events are raised.

##### GetUserData() As Object

Returns the user data that has previously been set via SetUserData(). It will return Invalid if no data has been set.

## ifMessagePort

##### SetPort(port As roMessagePort)

Posts messages of type *roCecRxFrameEvent and roCecTxCompleteEvent* to the attached message port.
----
developers\developers\brightscript\object-reference\inputoutput-objects\rocecrxframeevent.md
# roCecRxFrameEvent

If an *roMessagePort* is attached to an *roCecInterface* instance, it may receive events of type *roCecRxFrameEvent*.

## ifCecRxFrameEvent

##### GetByteArray() As roByteArray

Returns the message data as an *roByteArray*.

## ifUserData

##### SetUserData(user\_data As Object)

Sets the user data that will be returned by `GetUserData()`.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()`. It will return Invalid if no data has been set.
----
developers\developers\brightscript\object-reference\inputoutput-objects\rocectxcompleteevent.md
# roCecTxCompleteEvent

If an *roMessagePort* is attached to an *roCecInterface* instance, it may receive events of type *roCecTxCompleteEvent*.

## ifUserData

##### SetUserData(user\_data As Object)

Sets the user data that will be returned by `GetUserData()`.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()`. It will return Invalid if no data has been set.

## ifCecTxCompleteEvent   

##### GetStatusByte() As Integer

Returns the message data as an integer.

|     |     |
| --- | --- |
| 0   | Transmission successful |
| 128 | Unable to send, CEC hardware powered down |
| 129 | Internal CEC error |
| 130 | Unable to send, CEC line jammed |
| 131 | Arbitration error |
| 132 | Bit-timing error |
| 133 | Destination address not acknowledged |
| 134 | Data byte not acknowledged |
----
developers\developers\brightscript\object-reference\inputoutput-objects\rochannelmanager.md
# roChannelManager

You can use this object to manage RF channel scanning and tuning. The *roVideoPlayer* method also has channel scanning capabilities.

Object Creation: The *roChannelManager* object is created with no parameters.

```
CreateObject("roChannelManager")
```

## ifUserData

##### SetUserData(user\_data As Object)

Sets the user data that will be returned when events are raised.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()`. It will return Invalid if no data has been set.

## ifMessagePort

##### SetPort(port As roMessagePort)

## ifChannelManager

The *ifChannelManager* interface provides both a Synchronous and Asynchronous API:

### Synchronous API

##### Scan(parameters As roAssociativeArray) As Boolean

Performs a channel scan on the RF input for both ATSC and QAM frequencies and builds a channel map based on what it finds. The *roChannelManager* object stores a list of all channels that are obtained using the `CreateChannelDescriptor()` method (described below). The list is cleared on each call to `Scan()` by default, but this behavior can be overridden.

Each channel takes approximately one second to scan; you can limit the scope of the channel scan with the following parameters:

*   \["ChannelMap"\] = "ATSC" or "QAM": Limits the frequency scan to either QAM or ATSC.
    
*   \["ModulationType"\] = "QAM64" or "QAM256": Limits the modulation type of the scan to QAM64 or QAM256.
    
*   \["FirstRfChannel"\] = Integer and/or \["LastRfChannel"\] = Integer: Limits the scan to the specified range of channels. The high end of the channel range is an optional parameter.
    
*   \["ChannelStore"\] = "DISCARD ALL" or "MERGE": Controls how the script handles previous channel scan information. The default setting is DISCARD ALL, which clears all channel data prior to scanning. On the other hand, MERGE overwrites the data only for channels specified in the scan.
    

##### GetChannelCount() As Integer

Returns the number of found channels.

##### ClearChannelData() As Boolean

Clears all stored channel scanning data, including that which persists in the registry. This method also cancels any `AsyncScan()` calls that are currently running.

##### GetCurrentSnr() As Integer

Returns the SNR (in centibels) of the currently tuned channel.

##### ExporttoXML() As String

Serializes the contents of RF channels into XML. You can write the XML to a file that can be used at a later point on the same or other units. See below for an example of XML output.

##### ImportFromXML(a As String) As Boolean

Retrieves the RF channel contents stored as XML. The formatting of the XML is controlled using version tags.

Example:

```
<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE boost_serialization>
<boost_serialization signature="serialization::archive" version="7">
<ChannelList class_id="0" tracking_level="0" version="0">
<ChannelCount>2</ChannelCount>
<Channel class_id="1" tracking_level="0" version="0">
<RfChannel>42</RfChannel>
<ModulationType>7</ModulationType>
<SpectralInversion>0</SpectralInversion>
<MajorChannelNumber>1</MajorChannelNumber>
<MinorChannelNumber>1</MinorChannelNumber>
</Channel>
<Channel>
<RfChannel>42</RfChannel>
<ModulationType>7</ModulationType>
<SpectralInversion>0</SpectralInversion>
<MajorChannelNumber>1</MajorChannelNumber>
<MinorChannelNumber>2</MinorChannelNumber>
</Channel>
</ChannelList> 
```

##### EnableScanDebug(filename As String) As Boolean

Allows all scan debugging to be written to a text file. By default, there is no debug output from a scan. You can close the debug file by passing an empty string.

Example:

```
c=CreateObject("roChannelManager")
c.EnableScanDebug("tmp:/scandebug.txt")

v = CreateObject("roVideoPlayer")
aa = CreateObject("roAssociativeArray")
aa["RfChannel"] = 12
aa["VirtualChannel"] = "24.1"
print v.PlayFile(aa)

c.EnableScanDebug("")
```

##### CreateChannelDescriptor(a As Object) As Object

Creates an associative array that can either be passed to the *roVideoPlayer.PlayFile()* method (to tune to a channel) or parsed for metadata. The generated channel object can be based on one of the following:

*   Index:
    

```
["ChannelIndex"] = 0
```

*   Virtual channel number as a string in an associative array:
    

```
["VirtualChannel"] = "12.1"
```

*   Channel name as a string:
    

```
["ChannelName"] = "KCBS"
```

> [!NOTE]
> Channels are sorted internally by virtual channel, so you could use a Channel Index script to implement standard channel up/down behavior.

These are the entries generated in the array:

*   VirtualChannel
    
*   ChannelName
    
*   CentreFrequency
    
*   ModulationType
    
*   VideoPid
    
*   VideoCodec
    
*   AudioPid
    
*   AudioCodec
    
*   SpectralInversion
    
*   ChannelMap
    
*   FirstRfChannel
    
*   LastRfChannel
    

The last three entries in this array allow you to use the same *roArray* as a parameter for `Scan()` and `PlayFile()`. The first and last RF channel values are set to the same value so that only one RF channel will be scanned. This kind of scan can be performed at the same time as playing the channel because it doesn’t require retuning.

Example:

```
c=CreateObject("roChannelManager")
aa=CreateObject("roAssociativeArray")
aa["ChannelMap"] = "QAM"
aa["FirstRfChannel"] = 10
aa["LastRfChannel"] = 15
c.Scan(aa)

cinfo  = CreateObject("roAssociativeArray")
cinfo["ChannelIndex"] = 0
desc = c.CreateChannelDescriptor(cinfo)
print desc

v = CreateObject("roVideoPlayer")
v.PlayFile(desc)
c.Scan(desc) 
```

### Asynchronous API

##### AsyncScan(parameters As roAssociativeArray) As Boolean

Begins a channel scan on the RF input and returns the results immediately. Otherwise, the behavior and parameters of this method are identical to `Scan()`. When completed or cancelled, `AsyncScan()` generates an *roChannelManagerEvent*, which supports *ifUserData* and outputs two types of event:

*   0 – Scan Complete: Generated upon the completion of a scan. No extra data is supplied.
    
*   1 – Scan Progress: Generated upon every tune that is performed during the scan. `GetData()` returns the percentage complete of the scan.
    

##### CancelScan() As Boolean

Cancels any asynchronous scans that are currently running. This method does not generate an *roChannelManagerEvent*.

Synchronous Example:

```
 c = CreateObject("roChannelManager")

' Scan the channels
aa  = CreateObject("roAssociativeArray")
aa["ChannelMap"] = "ATSC"
aa["FirstRfChannel"] = 12
aa["LastRfChannel"] = 50
c.Scan(aa)

' Start at the first channel
index = 0
cinfo  = CreateObject("roAssociativeArray")
cinfo["ChannelIndex"] = index
desc = c.CreateChannelDescriptor(cinfo)

' Play the first channel
v = CreateObject("roVideoPlayer")
v.PlayFile(desc)

' Play the second channel
index = index + 1
cinfo["ChannelIndex"] = index
desc = c.CreateChannelDescriptor(cinfo)
v.PlayFile(desc)
```

  
Asynchronous Example:

```
 c = CreateObject("roChannelManager")
p = CreateObject("roMessagePort")
c.SetPort(p)

' Scan the channels
aa  = CreateObject("roAssociativeArray")
aa["ChannelMap"] = "ATSC"
aa["FirstRfChannel"] = 12
aa["LastRfChannel"] = 50
c.AsyncScan(aa)

loop:
  msg = Wait(2000,p)
  if msg = 0 then goto scan_complete
  goto loop

scan_complete:
' Start at the first channel
index = 0
cinfo  = CreateObject("roAssociativeArray")
cinfo["ChannelIndex"] = index
desc = c.CreateChannelDescriptor(cinfo)

' Play the first channel
v = CreateObject("roVideoPlayer")
v.PlayFile(desc)

' Rescan the current channel, and update the
desc["ChannelStore"] = MERGE
c.Scan(desc)
```
----
developers\developers\brightscript\object-reference\inputoutput-objects\rocontrolport.md
# roControlPort

This object provides support for the BP200/BP900 USB button boards, GPIO ports, and side buttons on the BrightSign player. Button presses are returned as *roControlUp* and *roControlDown* events. The object is used to configure output levels on the I/O connector and monitor inputs. Typically, LEDs and buttons are attached to the GPIO connector on the BrightSign player or the BrightSign Expansion Module.

The JavaScript equivalent is [controlport](../../../../developers/player-apis/javascript-apis/controlport.md).

Object Creation: The *roControlPort* object is created with a single parameter that specifies the port being used.

```
CreateObject("roControlPort", port As String)
```

The port parameter can be one of the following:

*   `BrightSign`: Specifies the onboard GPIO connector (including the SVC (GPIO12) button).
    
*   `Expander-GPIO`: Specifies the DB-25 connector on the BrightSign Expansion Module. If no BrightSign Expansion module is attached, then object creation will fail and Invalid will be returned.
    
*   `Expander-<n>-GPIO`: Specifies a [USB-to-GPIO device](https://www.brightsign.biz/digital-signage-products/accessories/USB-C-Cables) connected to the player. Multiple USB-to-GPIO devices can be controlled using separate *roControlPort* instances: The first device corresponds to `"Expander-0-GPIO"`, the second to `"Expander-1-GPIO"`, etc.
    
*   `Expander-DIP`: Specifies the eight DIP switches on the BrightSign Expansion Module. If no BrightSign Expansion module is attached, then object creation will fail and Invalid will be returned.
    

> [!NOTE]
> Hot-plugging the BrightSign Expansion Module is not supported.

*   `Touchboard-<n>-GPIO`: Retrieves events from the specified BP200/BP900 button board. Events are handled in the same manner as events from the BrightSign port.
    
*   `Touchboard-<n>-LED-SETUP`: Sets various LED output options for the specified BP200/BP900 button board.
    
*   `Touchboard-<n>-LED`: Sets the bits for each button on the specified BP200/BP900 button board. The bits indicate whether the associated LED should be on or off.
    

> [!NOTE]
> Since multiple BP200/BP900 button boards can be connected to a player simultaneously, the <n> value specifies the port enumeration of each board. This value corresponds to the `<raw>` or `<fid>` value returned by the [*roDeviceInfo.GetUSBTopology()*](../../object-reference/system-objects/rodeviceinfo.md) method. An unspecified enumeration value is synonymous with a button board with an enumeration value of 0 (e.g. Touchboard-GPIO and Touchboard-0-GPIO are identical).

##  ifControlPort

> [!NOTE]
> The "button" numbers described below are not the same as GPIO "pin" numbers: Some pins act as power supply or ground, so they are not included in the button numbering scheme. See the [hardware manual](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370673350/Hardware) associated with your player model to view a mapping of buttons to pins.

##### GetVersion() As String

Returns the version number of the firmware (either the main BrightSign firmware or the BrightSign Expansion Module firmware) responsible for the control port.

##### EnableOutput(button As Integer) As Boolean

Marks the specified button as an output. If an invalid button number is passed, `false` will be returned. If successful, the function returns `true`. The output will be driven high or low depending on the current output state of the pin.

> [!TIP]
> **Tip**
> See [this page](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370676258/XTx43+Hardware+Interfaces#XTx43HardwareInterfaces-gpio_table) for a table of pins and corresponding buttons for the onboard GPIO connector.

##### EnableInput(button As Integer) As Boolean

Marks the specified button as an input. If an invalid button number is passed, `false` will be returned. If successful, the function returns `true`. The button will be tri-stated and can be driven high or low externally.

##### EnableAlternateFunction(button As Integer, pin\_function As String) As Boolean

Enables an alternate function on a GPIO button. This method applies to the onboard GPIO connector and is currently supported on the XTx44, XTx43, XDx34, XDx33, HDx24, HDx23, and HO523 models.

The first argument specifies the GPIO button number (between 0 and 7). The second argument specifies the alternate function setting; the following table outlines the possible alternate setting for each pin:

| GPIO Pin | Button Number | Alternate Function |
| --- | --- | --- |
| 3   | 0   | `"serial1"` (Rx) |
| 4   | 1   | `"irin1"` |
| 5   | 2   | `"irout"` (HDx23, HO523 only) |
| 6   | 3   | N/A |
| 9   | 4   | `"serial0"` (Rx - console port)\* |
| 10  | 5   | `"serial0"` (Tx)\* |
| 11  | 6   | `"serial1"` (Tx) |
| 12  | 7   | N/A |

\*Models that do not have a 3.5mm serial port (e.g. HD223, XD233) do not support serial port 0.

> [!NOTE]
> To revert a GPIO button to its primary function, specify the `pin_function` as "gpio".

##### GetWholeState() As Integer

Returns the state of all the inputs attached to the control port as bits in an integer. Individual buttons can be checked using binary operations, although it is normally easier to call `IsInputActive()` instead.

##### IsInputActive(button As Integer) As Boolean

Returns the state of the specified input. If the button is not configured as an input, then the result is undefined.

##### SetWholeState(state As Integer) As Boolean 

Specifies the desired state of all outputs attached to the control port as bits in an integer. The individual buttons can be set using binary operations, although it is normally easier to call  `SetOutputState()` instead.

##### **Example**

```
port = CreateObject("roControlPort", "BrightSign")
gpio1 = 2 '2^1
gpio3 = 8 '2^3
gpio5 = 32 '2^5
gpio7 = 128 '2^7
port.SetWholeState(gpio1 + gpio2 + gpio5 + gpio7) 'turns on ports 1, 3, 5, and 7
```

##### SetOutputState(button As Integer, level As Boolean) As Boolean

Configures the output of the specified pin, which can be either "off" (0) or "on" (1). If the button is not configured as an output, the resulting level is undefined. This method can also be used to configure LED output behavior on BP200/B900 button boards; see the [**BP200/BP900 Setup**](#) section below for more details.

##### SetOutputValue(offset As Integer, bit-mask As Integer) As Boolean

Configures a button on a BP200/BP900 button board. This method can only be used when the *roControlPort* object is instantiated with the `Touchboard-<n>-LED-SETUP` or `Touchboard-<n>-LED` parameter. See the [**BP200/BP900 Setup**](#) section below for more details.

##### SetOutputValues(values As roAssociativeArray) As Boolean

Configures buttons on a BP200/BP900 button board. This method can only be used when the *roControlPort* object is instantiated with the `Touchboard-<n>-LED-SETUP` or `Touchboard-<n>-LED` parameter. See the [**BP200/BP900 Setup**](#) section below for more details.

##### GetProperties() As roAssociativeArray

Returns an associative array of values related to the attached BP200/BP900 button board, including hardware, header, and revision. This method can only be used with an *roControlPort* instantiated with the `Touchboard-<n>-GPIO` parameter.

##### SetPulseParams(parameters As roAssociativeArray) As Boolean

Specifies a period of time, as well as the time slices within that period, for pulsing GPIO LEDs. These properties are applied to all GPIO outputs. This method is passed an associative array with the following parameters:

*   `milliseconds`: An integer specifying the time period (in ms) for pulsing
    
*   `slices`: An integer specifying the number of divisions within the milliseconds time period: For example, a 500ms time period with slices:2 is divided into two 250ms slices.
    

##### SetPulse(button As Integer, bit-field As Integer) As Boolean

Sets the off/on bit field for a particular GPIO. Use the `slices` parameter of the `SetPulseParams()` method to determine the number of bits in the bit field. For example, specifying `milliseconds:500, slices:2`, and a bit field of `10` will cause the button to turn on every other 250 millisecond period.

##### RemovePulse(button As Integer) As Boolean

Removes the specified GPIO from the set affected by the pulse.

## ifMessagePort

##### SetPort(port As Object)

Posts messages of type [*roControlUp* and *roControlDown*](../inputoutput-objects/rocontrolup-rocontroldown.md)  to the attached message port.

## ifUserData

##### SetUserData(user\_data As Object)

Sets the user data that will be returned when events are raised.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()`. It will return Invalid if no data has been set.

## ifIdentity

##### GetIdentity() As Integer

Returns an identity value that can be used to associate *roControlUp* and *roControlDown* events with this control port.

> [!NOTE]
> The *ifIdentity* interface has been deprecated. We recommend using the *ifUserData* interface instead.

##### Examples

This example script applies timed pulses to a set of GPIOs:

```
' set up button 2 and 3 to flash at 2Hz (i.e. on & off twice in a second) in an alternating ' fashion.

gpioPort = CreateObject("roControlPort", "BrightSign")

gpioPort.EnableOutput(2)
gpioPort.SetOutputState(2, true)

gpioPort.EnableOutput(3)
gpioPort.SetOutputState(3, true)

' set up pulse to have two time slices of 250ms each.
gpioPort.SetPulseParams({ milliseconds: 500, slices: 2 })

' button 2 will have slice 1 on and slice 2 off.
gpioPort.SetPulse(2, &h01)

' button 3 will have the reverse of button 2.
gpioPort.SetPulse(3, &h02)

' wait for a bit.
sleep(10000)

' stop pulsing on button 2.
gpioPort.RemovePulse(2)
```

This example script enables various alternate functions on the GPIO:

```
c = CreateObject("roControlPort", "BrightSign")
 
'Enable serial port 1 on the GPIO.
 
c.EnableAlternateFunction(0, "serial1")
c.EnableAlternateFunction(6, "serial1")

s1 = CreateObject("roSerialPort", 1, 115200)
s1.SendLine("This is serial port 1")

mp = CreateObject("roMessagePort")
s1.SetLineEventPort(mp)
? wait(10000, mp)

'Switch serial port 0 from the 3.5mm serial port to the GPIO.
'[Note: it is advised use telnet/ssh or a script when testing this]

c.EnableAlternateFunction(4, "serial0")
c.EnableAlternateFunction(5, "serial0")

s = CreateObject("roSerialPort", 0, 115200)
s.SendLine("Hello on the console?")

mp = CreateObject("roMessagePort")
s.SetLineEventPort(mp)
? wait(10000, mp)

'Restore normal operation on serial port 0.

c.EnableAlternateFunction(4, "gpio")
c.EnableAlternateFunction(5, "gpio")

'Enable IR input on the GPIO.

c = CreateObject("roControlPort", "brightsign")
? c.EnableAlternateFunction(1, "irin1")

nexus_encodings = [ "NEC", "NEC32" ]
ir_gpio = CreateObject("roIRReceiver", { source: "GPIO", encodings: nexus_encodings })

mp = CreateObject("roMessagePort")
ir_gpio.SetPort(mp)

m = wait(10000, mp)

'Enable IR output on the GPIO (HDx23, HO523 only--the XT/XD models have a dedicated 3.5mm IR socket)

c.EnableAlternateFunction(2, "irout")

ir = CreateObject("roIRTransmitter", { destination: "GPIO"} )
ir.Send("NEC32", &H12345)
```

## BP200/BP900 Setup 

To send a configuration to the BP200/BP900 button board, instantiate *roControlPort* with the `Touchboard-<n>-LED-SETUP` parameter and call the `SetOutputValue()` method. This method accepts two integers: the first integer specifies one of three command types (offsets); the second integer is a bit field consisting of 32 bits.

*   **Offset 0**: Configures the button board using a bit field that is split into four bytes of eight bits each. Each byte is a separate part of the configuration. In the script, these bytes need to be listed from right to left in hex value (i.e. Byte 1 + Byte 2 + Byte 3 + Byte 4).
    
    *   Byte 1: Specifies the configuration type for the button board. Currently, the only configuration type is for LED output, which is specified with the value &hA0.
        
    *   Byte 2: The button number(s) that will be configured. Buttons are numbered beginning from 1. The value is set to 0 (&h00) if this command is not required.
        
    *   Byte 3: The LED bit-field configuration. This value specifies how many on/off bits should be used (up to 32 bits) when `SetOutputValue()` is called on a `Touchboard-<n>-LED` instance (see the **BP200/BP900 LED Output** section below for details). Set the value to 0 (&h00) if this command is not required (the bit field will be set to eight bits by default).
        
    *   Byte 4: This value is currently always set to 0 (&h00).
        
*   **Offset 1**: Disables buttons on the button board according to values in the bit field. Each button is disabled individually by setting bits 0-10: For example, passing the hex value &h00000008 will disable button 4 only.
    
*   **Offset 2**: Disables LEDs on the button board according to values in the bit field. Each LED is disabled individually by setting bits 0-10: For example, passing the hex value &h00000080 will disable the LED on button 8 only.
    

> [!NOTE]
> Disabling a button LED will not automatically disable the button itself (and vice-versa). To disable both the button and the LED, make separate SetOutputValue() calls for Offset 1 and Offset 2.

## BP200/BP900 LED Output

To control the behavior of individual button LEDs, instantiate *roControlPort* with the `Touchboard-<n>-LED` parameter, then pass per-LED bit fields to the `SetOutputValue()` method. This method accepts two integers: the first integer specifies the button number (0-11), while the second integer uses a bit field to specify the on/off behavior of the button LED. The size of the bit field (up to 32 bits) is determined with the Offset 0 – Byte 3 value described in the section above.

Each bit specifies the on/off behavior of a single cycle, and the BP200/BP900 button boards run at approximately 11Hz. For example, if you want an LED to cycle on every other second, you would set the Offset 0 – Byte 3 value to &h16 (22 bits) and the bit field itself to &h3FF800 (0000000000011111111111).

This example script sets a BP900 to “twinkle” by turning off each button LED at a different point in the cycle:

```
led=CreateObject("roControlPort", "TouchBoard-0-LED")
led_setup=CreateObject("roControlPort", "TouchBoard-0-LED-SETUP")
led_setup.SetOutputValue(0, &h000B00A0)
led.SetOutputValue(0, &h07fe)
led.SetOutputValue(1, &h07fd)
led.SetOutputValue(2, &h07fb)
led.SetOutputValue(3, &h07f7)
led.SetOutputValue(4, &h07ef)
led.SetOutputValue(5, &h07df)
led.SetOutputValue(6, &h07bf)
led.SetOutputValue(7, &h077f)
led.SetOutputValue(8, &h06ff)
led.SetOutputValue(9, &h05ff)
led.SetOutputValue(10, &h03ff)
```

> [!NOTE]
> See [controlport#Example](../../../../developers/player-apis/javascript-apis/controlport.md) for the equivalent example (setting a BP900 to twinkle) in JavaScript.
----
developers\developers\brightscript\object-reference\inputoutput-objects\rocontrolup-rocontroldown.md
# roControlUp, roControlDown

These objects are posted by an [*roControlPort*](../inputoutput-objects/rocontrolport.md) instance to the configured message port when inputs change state. An *roControlDown* event is posted when the input level goes from high to low. An *roControlUp* event is posted when the input level goes from low to high.

## ifInt

##### GetInt() As Integer

Retrieves the pin number associated with the event.

##### SetInt(value As Integer) As Void

Sets the value of the event.

## ifUserData

##### SetUserData(user\_data As Object) As Void

Sets the user data.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()` (on either the event or source object). It will return Invalid if no data has been set.

## ifSourceIdentity

##### GetSourceIdentity() As Integer

Retrieves the identity value that can be used to associate events with the source *roControlPort* instance.

> [!NOTE]
> The *ifSourceIdentity* interface has been deprecated. We recommend using the *ifUserData* interface instead.
----
developers\developers\brightscript\object-reference\inputoutput-objects\rogpiobutton.md
# roGpioButton

This object contains the input ID from *roGpioControlPort* instances:

## ifInt

##### GetInt() As Integer

Returns the input ID of the event. 

##### SetInt(value As Integer) As Void

Sets the input ID of the event.
----
developers\developers\brightscript\object-reference\inputoutput-objects\rogpiocontrolport.md
# roGpioControlPort

> [!CAUTION]
> **Important**
> New scripts should use *roControlPort* instead of *roGpioControlPort*.

This object is used to control and wait for events on the BrightSign generic GPIO control port. Typically, LEDs or buttons are connected to the GPIO port. Turning on a GPIO output changes the voltage on the GPIO port to 3.3V. Turning off a GPIO output changes the voltage on the GPIO port to 0V.

The GPIO ports are bidirectional and must be programmed as either inputs or outputs. The IDs range from 0–7. The `SetWholeState()` method will overwrite any prior output settings. The `SetOutputState()` takes an output ID (1, 2, or 6, for example). The `SetWholeState()` method takes a mask (for example, `SetWholeState(SetWholeState(2^1 + 2^2)` will set IDs 1 and 2).

The JavaScript equivalent is [controlport](../../../../developers/player-apis/javascript-apis/controlport.md).

## ifMessagePort

##### SetPort(obj As Object) As Void

## ifGpioControlPort

##### IsInputActive(input\_id As Integer) As Boolean  
 

##### GetWholeState() As Integer  
 

##### SetOutputState(output\_id As Integer, onState As Boolean) As Void  
 

##### SetWholeState(on\_state As Integer) As Void  
 

##### EnableInput(input\_id As Integer) As Boolean  
 

##### EnableOutput(output\_id As Integer) As Boolean

  

#####
----
developers\developers\brightscript\object-reference\inputoutput-objects\roirdownevent-roirrepeatevent-roirupevent.md
# roIRDownEvent, roIRRepeatEvent, roIRUpEvent

An IR event object is generated when an IR button input (button press, button repeat, button release) is received by the *roIRReceiver* object. Use these objects to retrieve the message body of the IR input. 

> [!NOTE]
> The *roIRUpEvent* object is generated with the Iguanaworks IR transceiver only.

## ifInt

##### GetCode() As Integer

Returns the IR code received by the *roIRReceiver* instance.

##### SetCode(a As Integer)

Overrides the IR code received by the *roIRReceiver* instance, replacing it with the specified binary code. 

## ifUserData

##### SetUserData(user\_data As Object)

Sets the user data that will be returned by `GetUserData()`.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()`. It will return Invalid if no data has been set. 

## ifReceivedEvent

##### GetEncoding() As String

Returns the encodings setting of the *roIRReceiver* instance. This setting can be one of the following strings:

*   "NEC"
    
*   "RC5" (supported on the Iguanaworks IR transceiver only)
----
developers\developers\brightscript\object-reference\inputoutput-objects\roirreceiver.md
# roIRReceiver

This object supports receiving arbitrary Infrared remote control codes using the NEC and RC5 protocols. The JavaScript equivalent is [BSIRReceiver](../../../../developers/player-apis/brightscript-javascript-objects/bsirreceiver.md).

Object Creation: The *roIRReceiver* object is created with an associative array.

```
CreateObject("roIRReceiver", config As roAssociativeArray)
```

The associative array can contain the following parameters:

*   `source`: A string value indicating the source of the input.
    
    *   "IR-in": The 3.5mm IR input/output connector (available on 4Kx42 and XDx32 models)
        
    *   "GPIO": Pin 1 of the GPIO connector
        
    *   "Iguana": The [Iguanaworks](http://iguanaworks.net/) IR transceiver. This source can support both NEC and RC5 encodings simultaneously.
        
    *   “tvcontroller” : This virtual IR driver is only available on BrightSign built-in products. It reads the IR messages from UART and drives the roIRReceiver object like other IR receivers. See the Examples section.
        
*   `encodings`: An array indicating the required encodings.
    
    *   "NEC"
        
    *   "RC5" (supported on the Iguanaworks IR transceiver only)
        

NEC codes are expressed in 24 bits:

*   Bits 0-7: Button code
    
*   Bits 8-23: Manufacturer code
    

> [!NOTE]
> If the manufacturer code is zero, then the code is considered to be intended for the Roku SoundBridge remote control.

The *roIRReceiver* object can generate the following events:

*   *roIRDownEvent*: Generates when a button is pressed.
    
*   *roIRRepeatEvent*: Generates when a button repeats.
    
*   *roIRUpEvent* (Iguanaworks IR transceiver only): Generates when a button is released
    

##   
ifUserData

##### SetUserData(user\_data As Object)

Sets the user data that will be returned when events are raised.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()`. It will return Invalid if no data has been set.

## ifMessagePort

##### SetPort(port As roMessagePort)

Specifies the port that will receive events generated by the *roIRReceiver* instance.

## Examples

#### Connecting a USB-C port to an IR receiver

> [!NOTE]
> The LS424 is the *only* platform where IR input is supported on the Type C connector. Also, a special cable is required: either an adapter (3.5mm plug to 3.5mm socket crossover), or custom all-in-one cable (LiteOn PN 306300009327).

```
'2-3-23 - V1.12 Test IR input, output to system log
 
Sub Main()
scriptlog = CreateObject("roSystemLog")   'display messages in system log
msgPort = CreateObject("roMessagePort")
gpioPort = CreateObject("roGpioControlPort")
gpioPort.SetPort(msgPort)
  
configIR = CreateObject("roAssociativeArray")
'Built-in IR via usb c
configIR.source = "TypeC"
configIR.encodings = CreateObject("roArray", 1, false)
configIR.encodings[0] = "NEC"
IRRecep = CreateObject("roIRReceiver", configIR)
  
if (type(IRRecep) = "roIRReceiver") then
    IRRecep.SetPort(msgPort)
    scriptlog.SendLine(" @@@@ Please press a button on remote control to display IR code... ")
else if IRRecep = invalid then
    scriptlog.SendLine(" @@@@ IR receiver not detected, Please connect IR receiver and reboot player... ")
end if
  
Eventloop(msgport)
 
End Sub
 
 
Sub Eventloop(msgport as object)
    scriptlog = CreateObject("roSystemLog")   'display messages in system log
    while true
        event = wait(0, msgPort)
        scriptlog.SendLine("@@@@ Received event"+ type(event))  
        if (type(event) = "roIRDownEvent") then       
                IrData$ = stri(event)
                scriptlog.SendLine(" @@@@ "+IrData$)
        end If    
    End while
end Sub
```

#### Creating a tvcontoller IR Receiver

```
configIR = CreateObject("roAssociativeArray")
'tvcontroller IR type
configIR.source = "tvcontroller"
configIR.encodings = CreateObject("roArray", 0, false)
IRRecep = CreateObject("roIRReceiver", configIR)
```
----
developers\developers\brightscript\object-reference\inputoutput-objects\roirremote.md
# roIRRemote

This object supports receiving and transmitting arbitrary Infrared remote control codes using the NEC protocol. You can also use this object to send PHC (Pronto Hex Code) commands. The best way to determine the required send values is to capture the codes received by *roIRRemote* when the remote buttons of the device are pressed and then send the same codes. 

> [!CAUTION]
> **Important**
> The *roIRRemote* object cannot be used to receive input over the 3.5mm IR port on the 4Kx42 and XDx32 series—use the *roIRReceiver* object instead.

NEC codes are expressed in 24 bits:

*   Bits 0-7: Button code
    
*   Bits 8-23: Manufacturer code
    

> [!NOTE]
> **Note**
> If the manufacturer code is zero, then the code is considered to be intended for the Roku SoundBridge remote control.

## ifMessagePort

##### SetPort(port As roMessagePort)

Posts messages of type *roIRRemotePress* to the attached message port.

## ifIRRemote

##### Send(protocol as String, code as Dynamic) As Boolean

Sends the specified code using the IR blaster. The system currently supports two IR transmission protocols: "NEC" and "PHC" (Pronto Hex Code). This method returns True if the code was successfully transmitted, but there is no way to determine from BrightScript if the controlled device actually received it.

## Pronto Hex Format 

Raw captures of Pronto Hex commands will likely not work with the inbuilt IR blaster, though they should work with [Iguanaworks](http://iguanaworks.net/) IR transceivers. This is a result of the trailing *off* periods, which are too long to be ecoded properly. Changing the *off* periods to all zeros ("0000") will fix this issue.

The following example sends an "ON" command to a Panasonic television using a single string of Pronto Hex Code. You can also provide Pronto Hex Code as an *roArray* of hex values, which results in less work for the script engine.

```
ir = CreateObject("roIRRemote")  

pronto_hex_Panasonic_on_str = " 0000 0071 0000 0032 0080 003F 0010 0010 0010 0030 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0030 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0030 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 0030 0010 0030 0010 0030 0010 0030 0010 0030 0010 0010 0010 0010 0010 0010 0010 0030 0010 0030 0010 0030 0010 0030 0010 0030 0010 0010 0010 0030 0010 0000"

ir.Send("PHC", pronto_hex_lg_on_str)
```
----
developers\developers\brightscript\object-reference\inputoutput-objects\roirremotepress.md
# roIRRemotePress

Messages of the type *roIRRemotePress* are generated upon key presses from a Roku Soundbridge remote.

## ifInt

##### GetInt() As Integer

Returns the event ID. 

##### SetInt(value As Integer) As Void

Sets the value of the event. 

For the Roku SoundBridge remote control, the Integer returned can have one of the following values:

|     |     |     |     |
| --- | --- | --- | --- |
| **Integer** | **Command** | **Integer** | **Command** |
| 0   | West | 8   | Search |
| 1   | East | 9   | Play |
| 2   | North | 10  | Next |
| 3   | South | 11  | Previous |
| 4   | Select | 12  | Pause |
| 5   | Exit | 13  | Add |
| 6   | Power | 14  | Shuffle |
| 7   | Menu | 15  | Repeat |
| 8   | Search | 16  | Volume up |
| 9   | Play | 17  | Volume down |
| 10  | Next | 18  | Brightness |
----
developers\developers\brightscript\object-reference\inputoutput-objects\roirtransmitcompleteevent.md
# roIRTransmitCompleteEvent

This event object is generated by the *roIRTransmitter.ASyncSend()* method. It does not return any information other than user data.

## ifUserData

##### SetUserData(user\_data As Object)

Sets the user data that will be returned by `GetUserData()`.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()`. It will return Invalid if no data has been set.
----
developers\developers\brightscript\object-reference\inputoutput-objects\rokeyboard.md
# roKeyboard

This object is used to wait for events from a USB keyboard. It can also be used to configure the localization of the keyboard. The JavaScript equivalent is [keyboard](https://docs.brightsign.biz/display/DOC/keyboard).

Object Creation: The *roKeyboard* object is created with no parameters.

```
CreateObject("roKeyboard")
```

## ifMessagePort

##### SetPort(port As roMessagePort)

Posts messages of type *roKeyboardPress* to the attached message port.

## ifUserData

##### SetUserData(user\_data As Object)

Sets the user data that will be returned when events are raised.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()`. It will return Invalid if no data has been set.

## ifKeyboardConfig

##### IsPresent() As Boolean

Returns True if a USB keyboard is connected to the player. This method counts a connected device as a keyboard if it reports having the following keys: "A", "Z", "0", "9", ".", and Enter.

##### SetNumLock(on\_off As Boolean) As Boolean

Sets the numlock state for the attached USB keyboard if passed true. Resets the state if passed false.

##### SetLayout(layout As String) As Boolean

Specifies the localized layout for the attached USB keyboard. This setting takes effect immediately and persists in the registry after a reboot. The following table lists valid keymap parameters (players are set to "us" by default): 

|     |     |     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- | --- | --- |
| af  | Afghanistan | es  | Spain | kh  | Cambodia | pk  | Pakistan |
| al  | Albania | et  | Ethiopia | kr  | Korea, Republic of | pl  | Poland |
| am  | Armenia | fi  | Finland | kz  | Kazakhstan | pt  | Portugal |
| at  | Austria | fo  | Faroe Islands | la  | Laos | ro  | Romania |
| az  | Azerbaijan | fr  | France\* | lk  | Sri Lanka | rs  | Serbia |
| ba  | Bosnia and Herzegovina | gb  | United Kingdom | lt  | Lithuania | ru  | Russia |
| bd  | Bangladesh | ge  | Georgia | lv  | Latvia | se  | Sweden |
| be  | Belgium | gh  | Ghana | ma  | Morocco | si  | Slovenia |
| bg  | Bulgaria | gn  | Guinea | md  | Moldova | sk  | Slovakia |
| br  | Brazil | gr  | Greece | me  | Montenegro | sn  | Senegal |
| bt  | Bhutan | hr  | Croatia | mk  | Macedonia | sy  | Syria |
| bw  | Botswana | hu  | Hungary | ml  | Mali | th  | Thailand |
| by  | Belarus | ie  | Ireland | mm  | Myanmar | tj  | Tajikistan |
| ca  | Canada | il  | Israel | mn  | Mongolia | tm  | Turkmenistan |
| cd  | Congo (DRC) | in  | India | mt  | Macao | tr  | Turkey |
| ch  | Switzerland | iq  | Iraq | mv  | Maldives | tw  | Taiwan |
| cm  | Cameroon | ir  | Iran | ng  | Nigeria | tz  | Tanzania |
| cn  | China | is  | Iceland | nl  | Netherlands | ua  | Ukraine |
| cz  | Czech Republic | it  | Italy | no  | Norway | us  | United States\*\* |
| de  | Germany | jp  | Japan | np  | Nepal | uz  | Uzbekistan |
| dk  | Denmark | ke  | Kenya | pc  | Pitcairn | vn  | Vietnam |
| ee  | Estonia | kg  | Kyrgyzstan | ph  | Philippines | za  | South Africa |

\*Equivalent to the AZERTY keyboard layout

\*\*The default setting
----
developers\developers\brightscript\object-reference\inputoutput-objects\rokeyboardpress.md
# roKeyboardPress

This is an event object resulting from the user pressing a key on a USB keyboard. The returned integer value is equivalent to the ASCII code of the key that was pressed.

## ifInt

##### GetInt() As Integer

Returns the ASCII value of the key press. 

##### SetInt(a As Integer)

Sets the value returned by the `GetInt()` method.

The returned *roInt32* can have one of the following values:

|     |     |     |     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| **Letter Keys** |     | **Number Keys** | **Function Keys** | **Misc Keys** | **Special Keys** |     |     |     |
| A - 97 | R  - 114 | 0 - 48 | F1 - 32826 | Del  - 127 | "-" | 45  | :   | 58  |
| B  - 98 | S  - 115 | 1 - 49 | F2 - 32827 | Backspace - 8 | "=" | 61  | "   | 34  |
| C  - 99 | T  - 116 | 2 - 50 | F3 - 32828 | Tab - 9 | \\  | 92  | <   | 60  |
| D  - 100 | U  - 117 | 3 - 51 | F4 - 32829 | Enter - 13 | \`  | 96  | \>  | 62  |
| E  - 101 | V  - 118 | 4 - 52 | F5 - 32830 | Print Scrn - 32838 | \[  | 91  | ?   | 63  |
| F  - 102 | W  - 119 | 5 - 53 | F6 - 32831 | Scrl Lock - 32839 | \]  | 93  | !   | 33  |
| G  - 103 | X  - 120 | 6 - 54 | F7 - 32832 | Pause/Brk - 32840 | ;   | 59  | @   | 64  |
| H  - 104 | Y  - 121 | 7 - 55 | F8 - 32833 | INS - 32841 | " ' " | 39  | #   | 35  |
| I  - 105 | Z  - 122 | 8 - 56 | F9 - 32834 | Home - 32842 | ,   | 44  | $   | 36  |
| J  - 106 |     | 9 - 57 | F11 - 32836 | Page Up - 32843 | .   | 46  | %   | 37  |
| K  - 107 |     |     | F12 - 32837 | Page Down - 32846 | /   | 47  | ^   | 94  |
| L  - 108 |     |     |     | End - 32845 | \_  | 95  | &   | 38  |
| M  - 109 |     |     |     | Caps - 32811 | "+" | 43  | \*  | 42  |
| N  - 110 |     |     |     | Left Arrow - 32848 | \|  | 124 | (   | 40  |
| O  - 111 |     |     |     | Right Arrow  - 32847 | ~   | 126 | )   | 41  |
| P  - 112 |     |     |     | Up Arrow - 32850 | {   | 123 |     |     |
| Q  - 113 |     |     |     | Down Arrow - 32849 | }   | 125 |     |     |
----
developers\developers\brightscript\object-reference\inputoutput-objects\ropowerevent.md
# roPowerEvent

The *roPowerEvent* object triggers if you switch between plugged in AC and PoE.

Object Creation: The *roPowerEvent* object is created as follows:

```
CreateObject("roPowerEvent", a As String, b As String) As Object
```

## IfPowerEvent

`GetData() As Object`

Returns current state and requested state when it has switched from the current state to the requested state.
----
developers\developers\brightscript\object-reference\inputoutput-objects\ropowermanager.md
# roPowerManager

The *roPowerManager* object is used to report the battery state of the device.  

Object Creation: The *roPowerManager* object is created as follows:

```
CreateObject("roPowerManager")
```

## ifPowerManager

##### GetPowerSource() As String

Returns either "Battery", "AC", or "Ethernet", depending on the power source.

##### GetBatteryStatus() As Object

Returns the following values:

*   `state` string: Returns the device battery status as either "charging", "discharging", "charge-complete", or "charge-fault"
    
*   `soc_percent` int: The level of charge of the battery as a percentage.
    
*   `hardware_version` string: The hardware version number
    

##### PowerOff()

Indicates that the charger should cut the power

##### SetPowerSwitchMode(as A String)

Takes either "hard" or "soft"

##### GetPowerSwitchMode() As String

Returns whether it is set to "hard" or "soft"

## ifMessagePort

##### SetPort(as A Object)

Which message port should be used to get messages from the power manager.
----
developers\developers\brightscript\object-reference\inputoutput-objects\rosequencematcher.md
# roSequenceMatcher

This object is used to send *roSequenceMatchEvent* events when the specified byte sequence patterns are matched. Once a pattern has been matched and the event has been posted, all contributing bytes are discarded. As a result, if one pattern is a prefix of another pattern, then the second, longer pattern will never be matched by the object.

This object provides both a standard interface and an overloaded interface for sending events to a message port.

## ifMessagePort

##### SetPort(port As roMessagePort)

Posts messages of type *roSequenceMatchEvent* to the attached message port.

## ifSequenceMatcher

##### SetPort(a As Object)

Specifies the message port where *roSequenceMatchEvent* objects will be posted.

##### Add(pattern As Object, user\_data As Object) As Boolean

Adds a pattern to be matched by the *roSequenceMatcher* object instance. The pattern should be specified as an object that is convertible to a byte sequence (e.g. *roByteArray*, *roString*). For the user data, pass the object that should be returned if the specified pattern is matched.

## Example

```
Function FromHex(hex as String) as Object
    bytes = CreateObject("roByteArray")
    bytes.FromHexString(hex)
    return bytes
End Function
 
Sub Main()
    serial = CreateObject("roSerialPort", 1, 115200)
    mp = CreateObject("roMessagePort")
 
    button1_seq = FromHex("080a01040001e000")
    button2_seq = FromHex("080e01040001e000")
 
    matcher = CreateObject("roSequenceMatcher")
    matcher.SetMessagePort(mp)
    matcher.Add(button1_seq, { name: "button1" })
    matcher.Add(button2_seq, { name: "button2" })
    matcher.Add("flibbet", { name: "flibbet" })
    matcher.Add("flobbet", { name: "flobbet" })
 
    if not serial.SetMatcher(matcher) then
       stop
    end if
 
    finished = false
    while not finished
       ev = mp.WaitMessage(10000)
       if ev = invalid then
           finished = true
       else if type(ev) = "roSequenceMatchEvent" then
           print "Got button: "; ev.GetUserData().name
       else
           print "Unexpected event: "; type(ev)
       end if
    end while
End Sub
```
----
developers\developers\brightscript\object-reference\inputoutput-objects\rosequencematchevent.md
# roSequenceMatchEvent

  

This object is generated whenever *roSequenceMatcher* matches a specified byte sequence pattern. 

## ifUserData

##### SetUserData(user\_data As Object)

Sets the user data that will be returned by `GetUserData()`.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()`. It will return Invalid if no data has been set.
----
developers\developers\brightscript\object-reference\inputoutput-objects\roserialport.md
# roSerialPort

  

This object controls the serial port on the player, allowing you to transmit and receive serial data. The JavaScript equivalent is [BSSerialPort](../../../../developers/player-apis/brightscript-javascript-objects/bsserialport.md).

> [!NOTE]
> If the *serial\_with\_telnet* registry key is set to 1, serial communication via roSerialPort in scripts will be highly unreliable. See [this page](../../../../developers/brightsign-registry-keys.md) for more information about *serial\_with\_telnet*.

Object Creation: The *roSerialPort* object is created with two parameters.

```
CreateObject("roSerialPort", port As Dynamic, baud_rate As Integer)
```

*   `port As Integer`: The port enumeration of the serial device:
    
    *   Most standard serial devices (including the USB-serial port on the [LS424](https://docs.brightsign.biz/display/DOC/LS424+Hardware+Interfaces#LS424HardwareInterfaces-usb_serial)) enumerate on port 0, though port 1 may be available on the GPIO connector on some models if enabled. See [roControlPort.EnableAlternateFunction](https://docs.brightsign.biz/display/DOC/roControlPort#roControlPort-EnableAlternateFunction(buttonAsInteger,pin_functionAsString)AsBoolean).
        
    *   If more than one USB serial device is attached then the first one will be port 2, the second will be port 3, etc.
        
    *   To communicate with the serial port of an OPS display (i.e. with the HO523), use port 1.
        
    *   To communicate with a USB-serial device (such as a GPS receiver), use port 2.
        
*   `port As String`: If multiple USB-serial devices are connected to the player, the device can be specified with a friendly name (`"USB:<friendly_name>"`). This value corresponds to the `<fid>` value returned by the [roDeviceInfo.GetUSBTopology()](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370673305/roDeviceInfo#GetUSBTopology(return-As-roAssociativeArray)-As-Dynamic-[inlineExtension]) method. The BrightSign shell `usblist` command can be used to discover friendly names. Note that RAW names are not guaranteed to stay the same between products or OS versions, so they are not recommended.
    
*   `baud_rate As Integer`: The baud rate for serial communication. The serial port supports the following baud rates: 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400, 4800, 9600, 19200, 38400, 57600, 115200, 230400.
    

##### **Example**

```
serial1 = CreateObject("roSerialPort", 0, 115200)
serial2 = CreateObject("roSerialPort", "USB:A/1", 57600) 
```

The *roSerialPort* object sends the following event types:

*   *roStreamLineEvent*: The line event is generated whenever the end of line string set using *SetEol* is found and contains a string for the whole line. This object implements the *ifString* and *ifUserData* interfaces.
    
*   *roStreamByteEvent*: The byte event is generated on every byte received. This object implements the *ifInt* and *ifUserData* interfaces.
    

## ifStreamSend

##### SetSendEol(eol\_sequence As String) As Void

Sets the EOL sequence when writing to the stream. The default value is CR (ASCII value 13). If you need to set this value to a non-printing character, use the `chr()` [global function](../../object-reference/global-functions.md).

##### SendByte(byte As Integer) As Void

Writes the specified byte to the stream.

##### SendLine(string As String) As Void

Writes the specified characters to the stream followed by the current EOL sequence.

##### SendBlock(a As Dynamic) As Void

Writes the specified characters to the stream. This method can support either a string or an *roByteArray*. If the block is a string, any null bytes will terminate the block.

##### Flush()

## ifStreamReceive

##### SetLineEventPort(port As Object) As Void

Sets the message port that *roStreamLineEvent* events will be posted to.

##### SetByteEventPort(port As Object) As Void

Sets the message port that *roStreamByteEvent* events will be posted to.

##### SetByteArrayEventPort(port As Object) As Void

This method works like *SetByteEventPort* but causes *roStreamByteArrayEvent* messages to be posted to the message port when data is received. For some object types (for example, *roTCPStream*), this can be much more efficient since data no longer needs to be delivered to BrightScript a byte at a time, but since serial ports are comparatively slow it's possible that each event will still contain only a single character. 

##### SetReceiveEol(eol\_sequence As String)

Sets the sequence that will signify the end of line and cause a *roStreamLineEvent* to be delivered to the message port set by *SetLineEventPort*. If you need to set this value to a non-printing character, use the `chr()` [global function](../../object-reference/global-functions.md) or an *roByteArray*. If the sequence contains NUL bytes it must be passed as an *roByteArray* since strings may not contain NUL bytes.

To use a NUL byte as a line terminator:

```
eol = CreateObject("roByteArray")
eol.Push(0)
mp = CreateObject("roMessagePort")
client = CreateObject("roSerialPort", 0, 115200)
client.SetReceiveEol(eol)
client.SetLineEventPort(mp)
```

##### SetMatcher(matcher As Object) As Boolean

Instructs the stream to use the specified matcher. This method returns True if successful. Pass Invalid to this method to stop using the specified matcher.

## ifSerialControl

##### SetBaudRate(baud\_rate As Integer) As Boolean

Sets the baud rate of the device. The supported baud rates are as follows: 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400, 4800, 9600, 19200, 38400, 57600, 115200, 230400.

##### SetMode(mode As String) As Boolean

Sets the serial mode in "8N1" syntax. The first character is the number of data bits. It can be either 5, 6, 7, or 8. The second number is the parity. It can be "N"one, "O"dd, or "E"ven. The third is the number of stop bits. It can be 1 or 2.

##### SetEcho(enable As Boolean) As Boolean

Enables or disables serial echo. It returns True on success and False on failure.

##### SetEol(a As String)  
 

##### SetFlowControl(enable As Boolean) As Boolean

Enables or disable RTS/CTS handshaking over the serial port. This feature is currently only available on 4Kx42, XDx32, and HDx22 models.

##### SetInverted(inverted As Boolean) As Boolean

Inverts the TX/RX signal levels on the serial port. This allows the player to communicate with devices that use -12V to 12V signaling. Inversion is supported on the DE-9 (more commonly referred to as DB-9) and USB ports only. Passing True to the method enables inversion, whereas passing False disables it.

##### SendBreak(duration\_in\_ms As Integer) as Boolean

Sends a serial break or sets the serial break condition. This method returns True upon success and False upon failure.

*   `duration_in_ms = -1`: Sends a continuous break.
    
*   `duration_in_ms = 0`: Clears the break state.
    
*   `duration_in_ms >= 100`: Sets the break condition for the specified period of milliseconds (note that this integer is only accurate to the tenth of a second).
    

## ifUserData

##### SetUserData(user\_data As Object)

Sets the user data that will be returned when events are raised.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()`. It will return Invalid if no data has been set.

## Example

This example script waits for a serial event and echoes the input received on the serial port to the shell:

```
serial = CreateObject("roSerialPort", 0, 9600)
p = CreateObject("roMessagePort")
serial.SetLineEventPort(p)

serial_only:
msg = Wait(0,p) ' Wait forever for a message.
if(type(msg) <> "roStreamLineEvent") goto serial_only 'Accept serial messages only.
serial.SendLine(msg) ' Echo the message back to serial.
```
----
developers\developers\brightscript\object-reference\inputoutput-objects.md
# Input/Output Objects

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

This section describes objects that enable input/output functions on hardware interfaces.

*   [roBtClient](./inputoutput-objects/robtclient.md)
*   [roBtClientEvent](./inputoutput-objects/robtclientevent.md)
*   [roBtClientManager](./inputoutput-objects/robtclientmanager.md)
*   [roBtClientManagerEvent](./inputoutput-objects/robtclientmanagerevent.md)
*   [roBtManager](./inputoutput-objects/robtmanager.md)
*   [roCecInterface](./inputoutput-objects/rocecinterface.md)
*   [roCecRxFrameEvent](./inputoutput-objects/rocecrxframeevent.md)
*   [roCecTxCompleteEvent](./inputoutput-objects/rocectxcompleteevent.md)
*   [roChannelManager](./inputoutput-objects/rochannelmanager.md)
*   [roControlPort](./inputoutput-objects/rocontrolport.md)
*   [roControlUp, roControlDown](./inputoutput-objects/rocontrolup-rocontroldown.md)
*   [roGpioButton](./inputoutput-objects/rogpiobutton.md)
*   [roGpioControlPort](./inputoutput-objects/rogpiocontrolport.md)
*   [roIRDownEvent, roIRRepeatEvent, roIRUpEvent](./inputoutput-objects/roirdownevent-roirrepeatevent-roirupevent.md)
*   [roIRReceiver](./inputoutput-objects/roirreceiver.md)
*   [roIRRemote](./inputoutput-objects/roirremote.md)
*   [roIRRemotePress](./inputoutput-objects/roirremotepress.md)
*   [roKeyboard](./inputoutput-objects/rokeyboard.md)
*   [roKeyboardPress](./inputoutput-objects/rokeyboardpress.md)
*   [roPowerEvent](./inputoutput-objects/ropowerevent.md)
*   [roPowerManager](./inputoutput-objects/ropowermanager.md)
*   [roSequenceMatcher](./inputoutput-objects/rosequencematcher.md)
*   [roSequenceMatchEvent](./inputoutput-objects/rosequencematchevent.md)
*   [roSerialPort](./inputoutput-objects/roserialport.md)
*   [roIRTransmitCompleteEvent](./inputoutput-objects/roirtransmitcompleteevent.md)
*   [roIRTransmitter](./inputoutput-objects/roirtransmitter.md)
*   [roUsbFilesystem](./inputoutput-objects/rousbfilesystem.md)
*   [roUsbHidEmulator](./inputoutput-objects/rousbhidemulator.md)
*   [roUsbHidLedEmulatorEvent](./inputoutput-objects/rousbhidledemulatorevent.md)
*   [roUsbPowerControl](./inputoutput-objects/rousbpowercontrol.md)
----
developers\developers\brightscript\object-reference\legacy-objects.md
# Legacy Objects

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

This section describes objects that are still offered by BrightScript, even though their primary functionality has been replaced by more modern objects.

*   [roRtspStreamEvent](./legacy-objects/rortspstreamevent.md)
*   [roSyncPool](./legacy-objects/rosyncpool.md)
*   [roSyncPoolEvent](./legacy-objects/rosyncpoolevent.md)
*   [roSyncPoolFiles](./legacy-objects/rosyncpoolfiles.md)
*   [roSyncPoolProgressEvent](./legacy-objects/rosyncpoolprogressevent.md)
----
developers\developers\brightscript\object-reference\networking-objects.md
# Networking Objects

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

This section describes objects related to networking, client/server applications, and feeds.

*   [roConfigurationElements](./networking-objects/roconfigurationelements.md)
*   [roDatagramEvent](./networking-objects/rodatagramevent.md)
*   [roDatagramReceiver](./networking-objects/rodatagramreceiver.md)
*   [roDatagramSender](./networking-objects/rodatagramsender.md)
*   [roDatagramSocket](./networking-objects/rodatagramsocket.md)
*   [roHttpEvent](./networking-objects/rohttpevent.md)
*   [roHttpServer](./networking-objects/rohttpserver.md)
*   [roKeyStore](./networking-objects/rokeystore.md)
*   [roMediaServer](./networking-objects/romediaserver.md)
*   [roMediaStreamer](./networking-objects/romediastreamer.md)
*   [roMediaStreamerEvent](./networking-objects/romediastreamerevent.md)
*   [roMimeStream](./networking-objects/romimestream.md)
*   [roMimeStreamEvent](./networking-objects/romimestreamevent.md)
*   [roNetworkAdvertisement](./networking-objects/ronetworkadvertisement.md)
*   [roNetworkAttached](./networking-objects/ronetworkattached.md)
*   [roNetworkConfiguration](./networking-objects/ronetworkconfiguration.md)
*   [roNetworkDetached](./networking-objects/ronetworkdetached.md)
*   [roNetworkDiscovery](./networking-objects/ronetworkdiscovery.md)
*   [roNetworkHotplug](./networking-objects/ronetworkhotplug.md)
*   [roNetworkStatistics](./networking-objects/ronetworkstatistics.md)
*   [roOpenVpn](./networking-objects/roopenvpn.md)
*   [roPtp](./networking-objects/roptp.md)
*   [roPtpEvent](./networking-objects/roptpevent.md)
*   [roRssArticle](./networking-objects/rorssarticle.md)
*   [roRssParser](./networking-objects/rorssparser.md)
*   [roRtspStream](./networking-objects/rortspstream.md)
*   [roSnmpAgent](./networking-objects/rosnmpagent.md)
*   [roSnmpEvent](./networking-objects/rosnmpevent.md)
*   [roStreamByteEvent](./networking-objects/rostreambyteevent.md)
*   [roStreamConnectResultEvent](./networking-objects/rostreamconnectresultevent.md)
*   [roStreamEndEvent](./networking-objects/rostreamendevent.md)
*   [roStreamLineEvent](./networking-objects/rostreamlineevent.md)
*   [roSyncManager](./networking-objects/rosyncmanager.md)
*   [roSyncManagerEvent](./networking-objects/rosyncmanagerevent.md)
*   [roTCPConnectEvent](./networking-objects/rotcpconnectevent.md)
*   [roTCPServer](./networking-objects/rotcpserver.md)
*   [roTCPStream](./networking-objects/rotcpstream.md)
*   [roUPnPActionResult](./networking-objects/roupnpactionresult.md)
*   [roUPnPController](./networking-objects/roupnpcontroller.md)
*   [roUPnPDevice](./networking-objects/roupnpdevice.md)
*   [roUPnPSearchEvent](./networking-objects/roupnpsearchevent.md)
*   [roUPnPService](./networking-objects/roupnpservice.md)
*   [roUPnPServiceEvent](./networking-objects/roupnpserviceevent.md)
*   [roUrlEvent](./networking-objects/rourlevent.md)
*   [roUrlTransfer](./networking-objects/rourltransfer.md)
----
developers\developers\brightscript\object-reference\presentation-and-widget-objects\roaudioconfiguration.md
# roAudioConfiguration

This object allows for mixing and leveling of audio streams before they are passed to audio outputs.

Object Creation: The *roAudioConfiguration* object is created with no parameters.

```
CreateObject("roAudioConfiguration")
```

## ifAudioConfiguration

##### ConfigureAudio(audio\_routing As roAssociativeArray) As Boolean

Configures the audio routing. This method will fail if called when audio resources are in use (i.e. there are active *roVideoPlayer* or *roAudioPlayer* instances). It returns `true` on success and `false` on failure. The passed associative array can have the following parameters:

*   `mode` string: Sets the audio routing mode:
    
    *   `"dynamic"`: The default mode. Mixing audio streams with differing sampling rates will cause playback to fail; differing volume levels will not be normalized; and audio streams cannot be added to an output that currently has audio playing on it. Other parameters in the associative array are ignored.
        
    *   `"prerouted"`: This setting was implemented in firmware 7.0. You can add and remove audio streams on an output that currently has audio playing on it; additional audio routing behavior is determined with the `autolevel`, `pcmonly`, and `srcrate` parameters. 
        
*   `autolevel` string: Enables (`"on"`) or disables (`"off"`) volume leveling for audio outputs in the `"prerouted"` audio mode. When this setting is enabled, all PCM audio streams on a particular output will play at a similar volume.
    
*   `pcmonly` string: Enables (`"true"`) or disables (`"false"`) compressed audio support in the `"prerouted"` audio mode.
    
*   `srcrate` int: Sets the sample rate to which all PCM audio streams are converted in the the `"prerouted"` audio mode. This value can be either 44100 or 48000.
    

##### GetConfiguration() As roAssociativeArray

Returns audio configuration information as an associative array:

*   `mode` string: The audio routing mode (`"dynamic"` or `"prerouted"`)
    
*   `decoder_count` int: The number of available decoders
    
*   `compressed_capable_count` int: The number of decoders that can route compressed audio
    
*   `autolevel` boolean: A flag indicating whether the volume leveling setting is enabled
    
*   `pcmonly` boolean: A flag indicating whether the compressed audio support setting is enabled
    
*   `srcrate` int: The sample rate to which all PCM audio streams are converted
    

> [!NOTE]
> If the mode is `"dynamic"`, the associative array will contain the `mode` and `decoder_count` parameter only.

##### GetClockStatus() As roAssociativeArray

Returns audio clock information about the I2C, SPDIF, and HDMI® outputs.
----
developers\developers\brightscript\object-reference\presentation-and-widget-objects\roaudioeventmx.md
# roAudioEventMx

The *roAudioPlayerMx* object can generate *roAudioEventMx* messages with the following values:

*   8 EVENT\_MEDIAENDED
    
*   14 EVENT\_OVERLAY\_MEDIAENDED
    
*   16 EVENT\_MEDIAERROR
    
*   17 EVENT\_OVERLAY\_MEDIAERROR
    

"Media ended" events are sent when a track finishes and there are no more queued tracks for the player, while "Media error" events are sent when a queued file is not found (e.g. when it does not exist). 

## ifInt

##### GetInt() As Integer

Returns the event ID 

##### SetInt(value As Integer) As Void

Sets the value of the event

## ifAudioUserData

##### SetUserData(user\_data As String)

Sets the user data.

##### GetUserData() As String

Returns the user data that has previously been set via `SetUserData()` (either on the source or event object). It will return Invalid if no data has been set.

## ifSourceIdentity

##### GetSourceIdentity() As Integer  
 

##### SetSourceIdentity() As Integer

> [!NOTE]
> The *ifSourceIdentity* interface has been deprecated. We recommend using the *ifAudioUserData* interface instead.
----
developers\developers\brightscript\object-reference\presentation-and-widget-objects\roaudiooutput.md
# roAudioOutput

This object allows individual control of audio outputs on the player. The JavaScript equivalent is [audiooutput](../../../../developers/player-apis/javascript-apis/audiooutput.md).

Object Creation: The *roAudioOutput* object requires a single output parameter upon creation.

```
CreateObject("roAudioOutput", output As String)
```

The `output` parameter can take the following strings:

*   `“none”`
    
*   `"hdmi”` or `"hdmi-1"`, `"hdmi-2"`, `"hdmi-3"`, or `"hdmi-4`" for Series 5 players with multiple outputs
    
*   `“usb”`
    
*   `“spdif”`
    
*   `"analog"` 
    
*   `“analog:N”` (N specifies the port enumeration, which is useful for models with multiple analog-audio ports; you can also use `"analog:1"` to specify the analog output on a model with a single analog-audio port)
    
*   `"earc"` (AU335 only)
    
*   Support for multiple USB outputs using the USB port naming terminology. See [roDeviceInfo-getusbtopology](../../object-reference/system-objects/rodeviceinfo.md)
    

You can create any number of *roAudioOutput* objects. There can be multiple instances of this object that represent the same audio output, but in these cases one object will override another.

## ifAudioOutput

##### SetVolume(a As Integer) As Boolean

Sets the volume of the specified output as a percentage represented by an integer between 0 and 100.

##### SetTone(treble As Integer, bass As Integer) As Boolean

Sets the treble and bass of the specified output. The treble and bass integers can range from -1000 to 1000, with 0 indicating no modification to the audio signal. Each increment represents a change of 0.01db.

##### SetMute(a As Boolean) As Boolean

Mutes the specified output if True. This method is set to False by default.

##### GetOutput() As String

Returns the string with which the *roAudioOutput* object was created.

##### SetAudioDelay(delay\_in\_milliseconds As Integer) As Boolean

Delays the audio for a specific audio output by lagging decoded samples before they reach that output. Delays are limited to 150ms or less. Currently, the system software only supports positive delays; therefore, if you need to set the audio ahead of the video, you will need to use *roVideoPlayer.SetVideoDelay()* instead.

##### SetPlugState( ) As Boolean

This function returns `true` if the corresponding output has a plug in it, `false` if it does not, or `Invalid` if the plug state cannot be determined on the current hardware or OS version. This is supported in BOS 9.0.163 onwards.

The `SetVolume()` and `SetMute()` methods work in conjunction with the volume and mute functionality offered by *roAudioPlayer*. The *roAudioPlayer* volume settings affect the audio decoder volume. The audio stream is then sent to the assigned outputs, which have an additional level of volume control enabled by *roAudioOutput*.

The *roAudioOutput* object affects the absolute volume (as well as mute settings) for an audio output. If two players are streaming to the same output, both will be affected by any settings implemented through *roAudioOutput*.

> [!NOTE]
> To control which audio outputs connect to audio player outputs generated by *roAudioOutput*, use the SetPcmAudioOutputs() and SetCompressedAudioOutputs() methods, which can be used for *roVideoPlayer* and *roAudioPlayer*. See the *roAudioPlayer* entry for further explanation of these methods.
----
developers\developers\brightscript\object-reference\presentation-and-widget-objects\roaudioplayer.md
# roAudioPlayer

An audio player is used to play back audio files using the generic *ifMediaTransport* interface. If the message port is set, the object will send events of the type *roAudioEvent*. All object calls are asynchronous. In other words, audio playback is handled in a different thread from the script. The script may continue to run while audio is playing. The JavaScript equivalent is to use the HTML audio tag.

## ifMessagePort

##### SetPort(port As roMessagePort) As Void

Posts messages of type *roAudioEvent* to the attached message port.

## ifUserData

##### SetUserData(user\_data As Object)

Sets the user data that will be returned when events are raised.

##### GetUserData() As Object

Returns the user data that has previously been set via SetUserData(). It will return Invalid if no data has been set.

## IfIdentity

##### GetIdentity() As Integer

> [!NOTE]
> The *ifIdentity* interface has been deprecated. We recommend using the *ifUserData* interface instead.

## ifMediaTransport 

See [*roVideoPlayer*](https://docs.brightsign.biz/display/DOC/roVideoPlayer) for a description of *ifMediaTransport* methods.

## ifAudioControl

##### SetPcmAudioOutputs(outputs As Dynamic) As Boolean

Specifies which audio connectors should output PCM audio. This method accepts an *roAudioOutput* instance or an array of *roAudioOutput* instances.

##### SetCompressedAudioOutputs(outputs As Dynamic) As Boolean

Specifies which audio connectors should output compressed audio (e.g. Dolby AC3 encoded audio). This method accepts an *roAudioOutput* instance or an array of *roAudioOutput* instances. 

> [!NOTE]
> When the `SetPcmAudioOutputs()` or `SetCompressedAudioOutputs()` method is  called, it will override the settings of the following *ifAudioControl* methods: `SetAudioOutput(), MapStereoOutput(), SetUsbAudioPort(), MapDigitalOutput()`.

##### SetMultichannelAudioOutputs(array As Object) As Boolean

##### SetAudioMode(audio\_mode As Integer) As Boolean

Sets the audio mode of the *roAudioPlayer* object. This method accepts the following values:

*   `0`: AC3 Surround 
    
*   `1`: AC3 mixed down to stereo 
    
*   `2`: No audio
    
*   `3`: Left
    
*   `4`: Right 
    

Options 0 and 1 only apply to video files, while options 2, 3, and 4 apply to all audio sources.

##### SetVolume(volume As Dynamic) As Boolean

Specifies the volume of the audio output as either a percentage or decibel amount. To use a percentage measurement, pass an integer value between 0 and 100. To use a decibel measurement, pass an *roAssociativeArray* containing a single `{db:<value As Float>`} parameter. The decibel measurement is an absolute value: passing 0 specifies no change to the audio output, and the effective range of measurements is from approximately -80 to 20 decibels.

The volume value is clipped prior to use (i.e. `SetVoume(101)` will set the volume to 100 and return True). The volume is the same for all mapped outputs and USB/SPDIF/analog.

> [!NOTE]
> Separate volume levels are stored for *roAudioPlayer* and *roVideoPlayer*.

##### SetChannelVolumes(channel\_mask As Integer, volume As Integer) As Boolean

You can control the volume of individual audio channels. This volume command takes a hex channel mask, which determines the channels to apply the volume to, and a level, which is a percentage of the full scale. The volume control works according to audio channel rather than the output. The channel mask is a bit mask with the following bits for MP3 output:

*   `&H01`: Left
    
*   `&H02`: Right
    
*   `&H03`: Both left and right
    

##### SetPreferredAudio(description As String) As Boolean

Selects which audio track to use if there are multiple audio tracks in the stream. See the [**Preferred Streams**](../presentation-and-widget-objects/rovideoplayer.md) section on the *roVideoPlayer* page for more details.

##### ConfigureAudioResources() As Boolean  

##### SetAudioDelay(delay\_in\_milliseconds As Integer) As Boolean

Adds a presentation time stamp (PTS) offset to the audio. This makes it possible to adjust for file multiplexing differences. Delays are limited to 150ms or less. Currently, the system software only supports positive delays; therefore, if you need to set the audio ahead of the video, you will need to use `SetVideoDelay()` instead.

##### SetVideoDelay(delay\_in\_milliseconds As Integer) As Boolean

Adds a presentation time stamp (PTS) offset to the video. This makes it possible to adjust for file multiplexing differences. Delays are limited to 150ms or less.

##### StoreEncryptionKey(a As String, b As String) As Boolean  
 

##### StoreObfuscatedEncryptionKey(a As String, b As String) As Boolean

#### **Deprecated Methods**

##### SetAudioOutput(audio\_output As Integer) As Boolean

##### MapStereoOutput(mapping As Integer) As Boolean

##### MapDigitalOutput(mapping As Integer) As Boolean

##### SetStereoMappingSpan(a As Integer) As Boolean

##### SetAudioStream(stream\_index As Integer) As Boolean

##### SetSpdifMute(a As Boolean) As Boolean

##### SetUsbAudioPort(a As Integer) As Boolean

##### SetAudioOutputAux(audio\_output As Integer) As Boolean

##### SetAudioModeAux(audio\_mode As Integer) As Boolean

##### MapStereoOutputAux(mapping As Integer) As Boolean  
  
SetVolumeAux(volume As Integer) As Boolean

##### SetChannelVolumesAux(channel\_mask As Integer, volume As Integer) As Boolean

##### SetAudioStreamAux(stream\_index As Integer) As Boolean

## Configuring Audio Outputs

If a audio/video file is playing or has played, you need to call `Stop()` before changing the audio output.

The following script shows how to use the `SetPcmAudioOutputs()` and `SetCompressedAudioOutputs()` methods in conjunction with [*roAudioOutput*](#). The audio/video player is configured to output decoded audio to the analog output or compressed audio to the HDMI**®** and SPDIF outputs.

```
ao1=CreateObject("roAudioOutput", "Analog")
ao2=CreateObject("roAudioOutput", "HDMI")
ao3=CreateObject("roAudioOutput", "SPDIF")

a1=CreateObject("roAudioPlayer")
a1.SetPcmAudioOutputs(ao1)
 
ar = CreateObject("roArray", 2, true)
ar[0] = ao2
ar[1] = ao3
a1.SetCompressedAudioOutputs(ar)
```

> [!CAUTION]
> **Important**
> In most cases, rerouting audio outputs during audio/video playback will cause playback to stop. The system software will still be responsive, so you can use commands to exit playback during or after an audio output modification.

This script sets audio output to the third analog audio port:

```
analog3 = CreateObject("roAudioOutput", "analog:3")
video = CreateObject("roVideoPlayer")
video.SetPcmAudioOutputs(analog3)
```

This script configures multiple outputs for an audio player:

```
analogOut = CreateObject("roAudioOutput", "analog")
hdmiOut = CreateObject("roAudioOutput", "hdmi")

audio = CreateObject("roAudioPlayer")
audio.SetPcmAudioOutputs([analogOut, hdmiOut])
```

This script sets the volume level for individual channels:

```
audio = CreateObject("roAudioPlayer")
audio.SetChannelVolumes(&H01, 60)      'left channel to 60%
audio.SetChannelVolumes(&H02, 75)      'right channel to 75%
audio.SetChannelVolumes(&H03, 65)      'all channels to 65%
```

## Playing Multiple Audio Files Simultaneously

Multiple MP3 files, as well as the audio track of a video file, can be played to any combination of the following:

*   Analog outputs
    
*   SPDIF / HDMI
    
*   USB
    

Only a single file can be sent to an output at any given time. For example, two *roAudioPlayers* cannot simultaneously play to the SPDIF output. The second one to attempt a *PlayFile* will get an error. To free an output, the audio or video stream must be stopped (using the *ifMediaTransport* `Stop` or `StopClear` calls).

Note the following about multiple audio-file functionality:

*   The onboard analog audio output and HDMI output are clocked by the same sample-rate clock. Therefore, if different content is being played out of each, the content must have the same sample rate.
    
*   Currently, only a single set of USB speakers is supported.
    
*   Each audio and video stream played consumes some of the finite CPU resources. The amount consumed depends on the bitrates of the streams. Testing is the only way to determine whether a given set of audio files can be played at the same time as a video. The maximum recommended usage is a 16Mbps video file with three simultaneous MP3 160kbps streams.
    

This script plays a video with audio over HDMI and an MP3 file to the onboard analog port:

```
hdmiOut = CreateObject("roAudioOutput", "hdmi")
analogOut = CreateObject("roAudioOutput", "analog")

video = CreateObject("roVideoPlayer")
video.SetPcmAudioOutputs(hdmiOut)

audio = CreateObject("roAudioPlayer")
audio.SetPcmAudioOutputs(analogOut)

video.PlayFile("video.mpg")
audio.PlayFile("audio.mp3")
```
----
developers\developers\brightscript\object-reference\presentation-and-widget-objects\roaudioplayermx.md
# roAudioPlayerMx

This object allows you to mix audio files, as well as HLS audio streams. Each roAudioPlayerMx object contains two internal audio players: The main audio playlist consists of queued audio tracks that play sequentially, while the audio overlay plays files on top of the main playlist. A fade will not occur if it is called while an overlay is playing, but the next audio track will start playing as expected. 

Tracks are queued to `PlayFile()` with their fade parameters specified in an [associative array](../../object-reference/brightscript-core-objects/roassociativearray.md). These are the parameters you can pass to `PlayFile()`:

*   `Filename`: The filename of the track
    
*   `FrontPorch`: The length (in milliseconds) to skip from the start of the track. This value is 0 by default.
    
*   `FadeOutLocation`: The location (in milliseconds) of the fade out relative to the value of the FrontPorch. If the FrontPorch value is 0 (which is the default setting), and the FadeOutLength value is non-zero, then the fade out is calculated back from the end of the file.
    
*   `FadeOutLength`: The length of the fade out (in milliseconds). This value is 0 by default.
    
*   `SegueLocation`: The location (in milliseconds) of the event that triggers the next audio file to play. This location is relative to the first audio file that is played. If the SegueLocation parameter is not included, the value defaults to the FadeOutLocation.
    
*   `BackPorchLocation`: The location (in milliseconds) of the termination point for the audio track. This location is relative to the first audio file that is played. If the BackPorchLocation parameter is not included, the audio file plays to the end. The value is 0 by default, which disables the back porch.
    
*   `TrackVolume`: The relative volume of of the audio track, measured as a percentage. Specify the percentage using values between 0 and 100.
    
*   `EventID`: The ID for an audio event.
    
*   `EventTimeStamp`: The timestamp for the audio event. There can only be one event per audio file.
    
*   `QueueNext`: The queuing of an audio track. Set the parameter value to 1 to queue an audio file to play after the current track.
    
*   `Overlay`: The overlay specification of an audio track. Set the parameter value to 1 to fade down the main audio playlist while playing the audio track as an overaly. Overlays have additional parameters:
    
    *   `AudioBedLevel`: The volume-level percentage of the main audio playlist while the overlay is playing. Specify the percentage using values between 0 and 100.
        
    *   `AudioBedFadeOutLength`: The fade-out length of the main audio playlist.
        
    *   `AudioBedFadeInLength`: The fade-in lenth for the length of the underlying audio track once the segue is triggered.
        
*   `FadeCurrentPlayNext`: A fade command. Set the parameter value to 1 to fade out the current main audio playlist track and fade in the designated audio file.
    
*   `CrossfadeCurrentPlayNext`: A crossfade command. Set the parameter value to 1 to force an immediate crossfade between the current main audio playlist track and the designated audio file.
    
*   `UserString`: A string that can be set to a unique value for each *roAudioPlayerMx* instance. This string is returned with every event generated by the instance. Since all current platforms can support multiple *roAudioPlayerMx* instances running at the same time, the UserString allows the script to distinguish between event returns.
    

The following diagram illustrates how some of these timing parameters work together:

![](./attachments/ORM.roAudioPlayerMX.png)

The following script illustrates a simple crossfade between audio tracks:

```
a = CreateObject("roAudioPlayerMx")
 
track1 = CreateObject("roAssociativeArray")
track1["Filename"] = "file1.mp3"
track1["FadeInLength"] = 4000
track1["FadeOutLength"] = 4000
track1["QueueNext"] = 1
 
track2 = CreateObject("roAssociativeArray")
track2["Filename"] = "file2.mp3"
track2["FadeInLength"] = 4000
track2["FadeOutLength"] = 4000
track2["QueueNext"] = 1
 
a.PlayFile(track1)
a.PlayFile(track2)
```

## ifMediaTransport

See *roVideoPlayer* for a description of *ifMediaTransport* methods.

## ifAudioControl

See *roAudioPlayer* for a description of *ifAudioControl* methods.

## ifSetMessagePort

##### SetPort(a As Object)

## ifUserData

##### SetUserData(user\_data As Object)

Sets the user data that will be returned when events are raised.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()`. It will return Invalid if no data has been set.

## ifIdentity

##### GetIdentity() As Integer

> [!NOTE]
> The *ifIdentity* interface has been deprecated. We recommend using the *ifUserData* interface instead.

## ifAudioControlMx

##### SetDecoderCount(a As Integer) As Boolean
----
developers\developers\brightscript\object-reference\presentation-and-widget-objects\rocanvaswidget.md
# roCanvasWidget

This object composites background color, text, and images into a single rectangle, allowing you to layer images on a z-axis.

Object Creation: Like other widgets, *roCanvasWidget* is created with an *roRectangle* to set its size and position on the screen.

```
CreateObject ("roCanvasWidget", r As roRectangle) As Object
```

## ifCanvasWidget

##### Hide() As Boolean

Hides the widget.

##### Show() As Boolean

Shows the widget.

##### Raise() As Void

Sends the widget to the top of the z-order on the graphics plane (i.e. in front of all other surfaces that implement the *ifWidget* interface). By default, new widgets are placed at the top of the graphics z-order.

> [!NOTE]
> Some surfaces are always drawn at the top of the graphics z-order, including the mouse cursor, closed captions, and [scrolling tickers](../presentation-and-widget-objects/rotextwidget.md).

> [!TIP]
> **Tip**
> You can use the `PauseGraphics()`/ `ResumeGraphics()` methods on the [*roVideoMode*](../presentation-and-widget-objects/rovideomode.md) object to ensure multiple changes to the graphics z-order occur simultaneously.

##### Lower() As Void

Sends the widget to the bottom of the z-order on the graphics plane (i.e. behind all other surfaces that implement the *ifWidget* interface). By default, new widgets are placed at the top of the graphics z-order.

##### SetRectangle(r As roRectangle) As Boolean

Changes the size and positioning of the widget rectangle using the passed *roRectangle* object.

##### SetLayer(content As Object, z-level As Integer) As Boolean

Sets the contents of a layer within the widget. The lowest z-level is drawn first, and the highest z-level is drawn last. The object content is described below.

##### ClearLayer(z-level As Integer) As Boolean

Clears the specified layer.

##### Clear() As Boolean

Clears all of the layers

##### EnableAutoRedraw(enable As Boolean) As Boolean

Enables or disables the automatic redrawing of the widget.

*   When this function is enabled, each call to SetLayer, ClearLayer, or Clear results in a redraw. If you need to change multiple layers, then you should disable auto redraw while calling the SetLayer function.
    
*   SetLayer enables or disables redrawing of the widget when layer content is changed. When auto-redraw is enabled, each call to SetLayer, ClearLayer, or Clear results in a redraw. To batch multiple updates together, you should first suspend drawing using EnableAutoRedraw(false), then make the changes to the content, and finally re-enable drawing using EnableAutoRedraw(true). The redraw happens in a separate thread, so EnableAutoRedraw returns almost immediately.
    

## Object Content

The content specified in each layer can consist of one or more objects. Each object is defined by an [*roAssociativeArray*](#) . If there is more than one object, then each is placed into an [*roArray*](#) prior to passing to the `SetLayer()` method. Currently, there are four object types. 

### Background color

*   `color`: The #\[aa\]rrggbb hex value of the background color
    
*   `targetRect`: A target rectangle, which is another *roAssociativeArray* consisting of x, y, w, and h values. These values are relative to the top left corner of the widget.
    

### Text

*   `text`: A string of text to display
    
*   `targetRect`: The rectangle in which the text is displayed
    
*   `textAttrs`: An *roAssociativeArray* containing attributes to be applied to the text. The attributes can be any of the following:
    
    *   `font`: A string indicating whether the text should be displayed as "small"/"medium"/"large"/"huge"
        
    *   `fontSize`: A point size that is used directly when creating the font. If the value is set to 0, then the font automatically resizes to fit the targetRect.
        
    *   `fontfile`: The filename for a non-system font to use
        
    *   `hAlign`: A string indicating the "left"/"center"/"right" alignment of the text on a line
        
    *   `vAlign`: A string indicating the "top"/"center"/"bottom" alignment of the text perpendicular to the line
        
    *   `rotation`: A string indicating the "0"/'90"/"180"/"270" degree rotation of the text
        
    *   `color`: The #\[aa\]rrggbb hex value of the text
        

### Image

*   `filename`: The filename of the image
    
*   `encryptionalgorithm`: The file-encryption algorithm. Currently the options are "AesCtr" and "AesCtrHmac".
    
*   `encryptionkey`: The key to decrypt the image file. This is a byte array consisting of 128 bits of key, followed by 128 bits of IV.
    

> [!NOTE]
> See the [Image Decryption](../presentation-and-widget-objects/roimageplayer.md) section in the *roImagePlayer* entry for details on displaying encrypted images.

*   `targetRect`: The rectangle in which the image is displayed. The image will be automatically resized to fit into the target area.
    
*   `sourceRect`: The source rectangle to clip from a source image
    
*   `compositionMode`: Enter either source or source\_over. The latter alpha blends with underlying objects. The former replaces the underlying values completely.
    
*   `imgAttrs`: An *roAssociativeArray* containing attributes to be applied to the image:
    
    *   `rotation`: A string indicating the "0"/'90"/"180"/"270" degree rotation of the image
        

### QR Codes

QR (quick response) codes appear as squares of black dots on a white background. They are used to encode URLs, email addresses, etc, and they can be scanned using readily available software for smart phones. Although the codes usually appear as black on white, you can, in theory, use any two contrasting colors.

*   `targetRect`: The rectangle in which the QR code is displayed. Regardless of the aspect ratio of this rectangle, the QR code itself will always be squared with the background color that fills the gaps.
    
*   `QrCode` (simple form): Contains the string to encode into the QR code.
    
*   `QrCode` (complex form): Contains an array of parameters for the QR code. The parameters can be any of the following:
    
    *   `color`: The foreground color in the QR code (the default is black)
        
    *   `backgroundColor`: The background color in the QR code (the default is white)
        
    *   `rotation`: A string indicating the "0"/'90"/"180"/"270" degree rotation of the code. The code will scan regardless of rotation.
        
    *   `qrText`: Contains the text to encode into the QR code.
        

## Example

This code contains most of the *roCanvasWidget* features outlined above:

```
rect=CreateObject("roRectangle", 0, 0, 1920, 1080)
cw=CreateObject("roCanvasWidget", rect)

aa=CreateObject("roAssociativeArray")
aa["text"] = "Primal Scream"
aa["targetRect"] = { x: 280, y: 180, w: 500, h: 30 }
aa["textAttrs"] = { Color:"#AAAAAA", font:"Medium", HAlign:"Left", VAlign:"Top"}

aa1=CreateObject("roAssociativeArray")
aa1["text"] = "Movin' on up, followed by something else, followed by something else, followed by something else, followed by something else"
aa1["targetRect"] = { x: 282, y: 215, w: 80, h: 500 }
aa1["textAttrs"] = { Color:"#ffffff", font:"Large", fontfile:"usb1:/GiddyupStd.otf", HAlign:"Left", VAlign:"Top", rotation:"90"}

array=CreateObject("roArray", 10, false)
array.Push({ color: "5c5d5f" })
array.Push({ filename: "transparent-balls.png" })
array.Push(aa)

aa2=CreateObject("roAssociativeArray")
aa2["filename"] = "transparent-balls.png"
aa2["CompositionMode"] = "source_over"
aa2["targetRect"] = { x: 400, y: 200, w: 200, h: 200 }

aa3=CreateObject("roAssociativeArray")
aa3["QrCode"] = "www.brightsign.biz"
aa3["targetRect"] = { x: 100,  y: 100,  w: 400, h: 400  }

aa4=CreateObject("roAssociativeArray")
aa4["QrCode"] = { qrText:"www.brightsign.biz", rotation:"90" }
aa4["targetRect"] = { x: 1200,  y: 100,  w: 400, h: 600  }

aa5=CreateObject("roAssociativeArray")
aa5["QrCode"] = { color:"#964969", backgroundColor:"#FFFF77", qrText:"www.brightsign.biz", rotation:"180" }
aa5["targetRect"] = { x: 100,  y: 600,  w: 400, h: 400  }

cw.Show()
cw.EnableAutoRedraw(0)
cw.SetLayer(array, 0)
cw.SetLayer(aa1, 1)
cw.SetLayer(aa1, 2)
cw.SetLayer(aa3, 3)
cw.SetLayer(aa4, 4)
cw.SetLayer(aa5, 5)
cw.EnableAutoRedraw(1)

cw.ClearLayer(0) 
```

##
----
developers\developers\brightscript\object-reference\presentation-and-widget-objects\roclockwidget.md
# roClockWidget

This object places a clock on the screen. It has construction arguments only.

Object Creation: The *roClockWidget* object is created with several parameters.

```
CreateObject("roClockWidget", rect As roRectangle, res As roResourceManager, display_type As Integer)
```

*   `rect`: The rectangle in which the clock is displayed. The widget picks a font based on the size of the rectangle.
    
*   `res`: A *resources.txt* file that allows localization via the *roResourceManager* object (see below for further details).
    
*   `display_type`: Use 0 for date only, and 1 for clock only. To show both on the screen, you need to create two widgets.
    

**Example**

```
rect=CreateObject("roRectangle", 0, 0, 300, 60)
res=CreateObject("roResourceManager", "resources.txt")
c=CreateObject("roClockWidget", rect, res, 1)
c.Show()
```

The resource manager is passed into the widget, which uses the following resources within the *resources.txt* file to display the time and date correctly. Here are the "eng" entries:

```
[CLOCK_DATE_FORMAT]
eng "%A, %B %e, %Y"
[CLOCK_TIME_FORMAT]
eng "%l:%M"
[CLOCK_TIME_AM]
eng "AM"
[CLOCK_TIME_PM]
eng "PM"
[CLOCK_DATE_SHORT_MONTH]
eng "Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec"
[CLOCK_DATE_LONG_MONTH]
eng
"January|February|March|April|May|June|July|August|September|October|November|December"
[CLOCK_DATE_SHORT_DAY]
eng "Sun|Mon|Tue|Wed|Thu|Fri|Sat"
[CLOCK_DATE_LONG_DAY]
eng "Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday"
```

## Control Characters

The following are the control characters for the date/time format strings:

```
// Date format
//
// %a Abbreviated weekday name
// %A Long weekday name
// %b Abbreviated month name
// %B Full month name
// %d Day of the month as decimal 01 to 31
// %e Like %d, the day of the month as a decimal number, but without leading zero
// %m Month name as a decimal 01 to 12
// %n Like %m, the month as a decimal number, but without leading zero
// %y Two digit year
// %Y Four digit year

// Time format
//
// %H The hour using 24-hour clock (00 to 23)
// %I The hour using 12-hour clock (01 to 12)
// %k The hour using 24-hour clock (0 to 23); single digits are preceded by a blank.
// %l The hour using 12-hour clock (1 to 12); single digits are preceded by a blank.
// %M Minutes (00 to 59)
// %S Seconds (00 to 59)
```

## ifWidget

##### SetForegroundColor(color As Integer) As Boolean

Sets the foreground color in ARGB format. Hex color values should be converted to integers before being passed to this method (e.g. the value `&hFFFFFFFF` should be passed as 4294967295). You can use the `HexToInteger()` method (available in the [core library extension](../../../brightscript/language-reference/core-library-extension.md)) to convert a hex string to an integer.

##### SetBackgroundColor(color As Integer) As Boolean

Sets the background color in ARGB format. Hex color values should be converted to integers before being passed to this method (e.g. the value `&hFFFFFFFF` should be passed as 4294967295). You can use the `HexToInteger()` method (available in the [core library extension](../../../brightscript/language-reference/core-library-extension.md)) to convert a hex string to an integer.

> [!NOTE]
> The top 8 bits of the `SetForegroundColor()` and `SetBGackgroundColor()` values are "alpha" parameters. Zero is equivalent to fully transparent and 255 to fully non-transparent. This feature allows for effects similar to subtitles. For example, you can create a semi-transparent black box containing text over video.

##### SetFont(font\_filename As String) As Boolean

Sets the *font\_filename* using a TrueType font (for example, `SD:/Arial.ttf`).

##### SetBackgroundBitmap(bitmap\_filename As String, stretch As Boolean) As Boolean

Sets the background bitmap image. If stretch is True, then the image is stretched to the size of the window.

##### SetBackgroundBitmap(parameters As roAssociativeArray, stretch As Boolean) As Boolean

Sets the background bitmap image. If *stretch* is True, then the image is stretched to the size of the window. The associative array can contain the following parameters:

*   `Filename`: The name of the image file
    
*   `EncryptionAlgorithm`: The file-encryption algorithm. Currently the options are "AesCtr" and "AesCtrHmac".
    
*   `EncryptionKey`: The key to decrypt the image file. This is a byte array consisting of 128 bits of key, followed by 128 bits of IV.
    

> [!NOTE]
> See the [Image Decryption](../presentation-and-widget-objects/roimageplayer.md) section in the *roImagePlayer* entry for details on displaying encrypted images.

##### SetSafeTextRegion(region As roRectangle) As Boolean

Specifies the rectangle within the widget where the text can be drawn safely.

##### Show() As Boolean

Displays the widget. After creation, the widget is hidden until `Show()` is called.

##### Hide() As Boolean

Hides the widget.

##### Raise() As Void

Sends the widget to the top of the z-order on the graphics plane (i.e. in front of all other surfaces that implement the *ifWidget* interface). By default, new widgets are placed at the top of the graphics z-order.

> [!NOTE]
> Some surfaces are always drawn at the top of the graphics z-order, including the mouse cursor, closed captions, and [scrolling tickers](../presentation-and-widget-objects/rotextwidget.md).

> [!TIP]
> **Tip**
> You can use the `PauseGraphics()`/ `ResumeGraphics()` methods on the [*roVideoMode*](../presentation-and-widget-objects/rovideomode.md) object to ensure multiple changes to the graphics z-order occur simultaneously.

##### Lower() As Void

Sends the widget to the bottom of the z-order on the graphics plane (i.e. behind all other surfaces that implement the *ifWidget* interface). By default, new widgets are placed at the top of the graphics z-order.

##### GetFailureReason() As String

Yields additional useful information if a function return indicates an error.

##### SetRectangle(r As roRectangle) As Boolean

Changes the size and positioning of the widget rectangle using the passed *roRectangle* object.
----
developers\developers\brightscript\object-reference\presentation-and-widget-objects\rohdmiinputchanged-rohdmioutputchanged.md
# roHdmiInputChanged, roHdmiOutputChanged

The *roVideoMode* object generates an *roHdmiInputChanged* or *roHdmiOutputChanged* event object whenever the hotplug status of the HDMI® input or output changes. The JavaScript equivalent is *videoinput.VideoInputConfiguration.hdmiinputchanged* or *videooutput.VideoOutputConfiguration.hotplugevent.*

At least one *roHdmiOutputChanged* event object will always be generated for a hotplug event, even for very quick disconnect/connect hotplug events. In most cases, a disconnect/connect hotplug event will generate two event objects.

## ifInt

##### GetInt() As Integer

Returns the event ID. 

##### SetInt(value As Integer) As Void

Sets the value of the event. 

## ifUserData

##### SetUserData(user\_data As Object)

Sets the user data that will be returned when events are raised.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()`. It will return Invalid if no data has been set.
----
developers\developers\brightscript\object-reference\presentation-and-widget-objects\rohtmlwidget.md
# roHtmlWidget

This object embeds the Chromium HTML rendering engine, which can be rendered at full screen or as a widget. You can display multiple *roHtmlWidget* instances at the same time. The JavaScript equivalent is [htmlwidget](../../../../developers/player-apis/javascript-apis/htmlwidget.md).

> [!TIP]
> **Tip**
> Use the [*roKeyStore*](../../object-reference/networking-objects/rokeystore.md) object to provide client certificates for websites. Use the [*roVirtualMemory*](../../object-reference/hashing-and-storage-objects/rovirtualmemory.md) object to set up a virtual memory repository for Chromium.

## Object Creation 

The *roHtmlWidget* object is initialized with an *roRectangle* object, which specifies the size and positioning of the widget on the screen, and an optional associative array, which defines properties for the widget. 

```
CreateObject("roHtmlWidget", rect As roRectangle, properties As roAssociativeArray)
```

The properties of an *roHtmlWidget* instance can be set with an associative array at initialization or with equivalent methods after initialization. Because many *roHtmlWidget* properties cannot be changed without reloading the page (and can produce unpredictable results if changed while the page is running), we recommend setting properties at initialization when possible, rather than using the equivalent methods.

> [!CAUTION]
> **Important**
> Defining initialization properties for an *roHtmlWidget* instance disables some methods for that instance (e.g. `SetTransform()`, `AddFont()`, `SetUserStylesheet()`). See the “Available Methods with Initialization” section below for a list of available methods.

## Initialization Parameters

The associative array passed during initialization can have the following parameters: 

`nodejs_enabled` bool: Enables [Node.js®](../../../../developers/html-development/nodejs.md) on the widget. This value is `false` by default.

> [!NOTE]
> Reloading a page which has Node.js enabled can be classified as an undefined behavior. The recommended method for restarting a Node instance is to destroy and rebuild the *roHtmlWidget*

`focus_enabled` bool: Enables focus for mouse/touchscreen events. This value is `true` by default.

`mouse_enabled` bool: Enables mouse/touchscreen events. This value is `false` by default.

`scrollbar_enabled` bool: Enables automatic scrollbars for content that does not fit into the viewport. This value is `false` by default.

The browser defaults to desktop-style scrollbars, but they can be [configured for mobile style](../../../../developers/html-development/displaying-html-without-brightauthor.md) as well.

`pinch_to_zoom_enabled` bool: Enables pinch-to-zoom functionality. This value is `false` by default.

`force_gpu_rasterization_enabled` bool: Enables GPU rasterization for HTML graphics. By default, the decision to use GPU rasterization is based on [internal Chromium logic](https://www.chromium.org/developers/design-documents/chromium-graphics/how-to-get-gpu-rasterization).

> [!NOTE]
> This setting has been deprecated. As of OS8, GPU rasterization is enabled by default and setting this property has no effect.

`canvas_2d_acceleration_enabled` bool: Enables 2D canvas acceleration. This will improve the framerate of most HTML pages that use 2D animations, but can cause out-of-memory issues with pages that use a large number of off-screen canvas surfaces.

> [!NOTE]
> This setting has been deprecated. As of OS8, Canvas acceleration is enabled by default and can be disabled by setting this flag to `false`.

`javascript_enabled` bool: Enables JavaScript on the widget. This value is `true` by default.

`brightsign_js_objects_enabled` bool: Enables [BrightScript-JavaScript objects](../../../../developers/player-apis/brightscript-javascript-objects.md). This value is `false` by default.

In OS 8.2.55.4 and later, html widgets that are loaded from HTTP/HTTPS protocols do not share the same local storage database (html widgets that are loaded via file protocol act as they did in previous releases). These flags allow you to change the default behavior of widgets loaded through HTTP/HTTPS from "unshared" to "shared", or to change the default behavior of widgets with locally loaded files to "unshared" from "shared":

`force_shared_storage` bool: Allows HTML widgets loaded via HTTP/HTTPS protocol to share local storage if they are loaded from the same domain.

`force_unshared_storage` bool: Prevents HTML widgets loaded via FILE protocol from sharing storage.

`transform` string: Sets the screen orientation of content in the widget (note that the coordinates and dimensions of the *roRectangle* containing the widget are not affected by rotation). The following values are accepted:

*   `"identity"`: There is no transform (i.e. the widget content is oriented as landscape). This is the default setting.
    
*   `"rot90"`: The widget content is rotated to portrait at 90 degrees (clockwise).
    
*   `"rot180"`: The widget content is rotated to portrait at 180 degrees (clockwise).
    
*   `"rot270"`: The widget content is rotated to portrait at 270 degrees (clockwise).
    

`user_agent` string: Modifies the default user-agent string for the *roHtmlWidget* instance.

`url` string: The URL to use for display. See the [SetUrl()](https://docs.brightsign.biz/display/DOC/roHtmlWidget#roHtmlWidget-SetURL(URLAsString)AsBooleanseturl()) entry below for more information on using URIs to access files from local storage.

`language` string: Specifies the language to load the web page in.

`user_stylesheet` string: Applies the specified user stylesheet to pages in the widget. The parameter is a [URI](https://docs.brightsign.biz/display/DOC/roHtmlWidget#roHtmlWidget-SetURL(URLAsString)AsBooleanseturl()) specifying any `file:` resource in the storage. The stylesheet can also be specified as inline data.

`hwz_default` string: Specifies the default [HWZ](../../../../developers/html-development/html-video.md) behavior. This value is `off` by default. To enable it, set it to `on`.

`storage_path` string: Creates a "Local Storage" subfolder in the specified directory. This folder is used by local storage applications such as the JavaScript *storage* class. 

`storage_quota` string or double: Sets the total size (in bytes) allotted to all local storage applications (including IndexedDB). A BrightScript integer is only guaranteed to be able to represent a count of bytes up to 2GB so avoid using integers when calculating the size: Use float or double instead since they can represent values over 2GB (string can also be used but is not recommended). If the storage path is specified without a storage quota, Chromium defaults to reserving 1GB plus 10% of the total size of the storage device.

`port` roMessagePort: Configures the message port to which the *roHtmlWidget* instance will send events. When using initialization parameters, the `port` parameter should be used instead of the `SetPort()` method to ensure the script can catch `load-started`, `load-finished`, and `load-error` events.

`fonts` roArray: Specifies a list of font files that can be accessed by the webpage. Font files are specified as an array of string filenames. Supported font types include TrueType Font files (*.ttf*) and Web Open Font files (*.woff*, *.woff2*).

`pcm_audio_outputs` roArray: Configures the PCM audio output for the HTML widget. Outputs are specified as an array of strings, each string being the name of an output. (See [*roAudioOutput* documentation](../presentation-and-widget-objects/roaudiooutput.md) for a list of acceptable names.)

`compressed_audio_outputs` roArray: Configures compressed audio output (e.g. Dolby AC3 encoded audio) for the HTML widget. Outputs are specified as an array of *roAudioOutput* instances. 

`multi_channel_audio_outputs` roArray: Configures multi-channel audio output for the HTML widget. Outputs are specified as an array of *roAudioOutput* instances.

`inspector_server` roAssociativeArray: Configures the [Chromium Inspector](../../../../developers/html-development/html-best-practices.md) for the widget.Starting in BrightSign OS 8.5.31 you will need to also set the enable\_web\_inspector registry key (in the "html" section) to enable the JavaScript console. In “enable\_web\_inspector”, "1" will allow the inspector and "0" or not present will disable it.  A reboot will be needed for these changes to take effect (if you enable/disable this through the LDWS UI it may trigger a reboot to apply the changes).

*   `ip_addr` string: The Inspector IP address. This value is useful if the player is assigned more than one IP address (i.e. there are multiple network interfaces) and you wish to limit the Inspector server to one. The default value is `"0.0.0.0"`, which allows the Inspector to accept connections using either IP address.
    
*   `port` int: The port for the Inspector server
    

> [!CAUTION]
> **Important**
> For security reasons, **enable\_web\_inspector** should only be used in non-production presentations. Make sure to disable JavaScript console before publishing to a production environment. In the Chromium version found in BOS 8.5.31 and beyond, the JavaScript console will log information in memory even when you are not connected to the inspector. This will consume memory until the player runs out, which will result in a crash.

  

  

`security_params` roAssociativeArray: Enables or disables Chromium security checks for cross-origin requests, local video playback from HTTP, etc. 

*   `websecurity` bool: Enables Chromium security checks for cross-origin requests. 
    
*   `camera_enabled` bool: Enables webpage access to USB cameras connected to the player (access is disabled by default). This allows support for WebRTC applications.
    
*   `insecure_https_enabled` bool: Instructs the widget to ignore security errors when connecting to insecure HTTPS hosts (insecure HTTPS is disabled by default). Enabling this feature makes the player insecure; it is not suitable for production environments and should only be used for testing.\]
    
*   `audio_capture_enabled` bool: Gives access to audio input devices and lets Chromium enumerate all audio input and output devices
    

With BOS 8.2 and later (Chromium69 and later), several new CORS checks have been added: `security_params.websecurity` or `enableSecurity(false)` do not disable all these checks. Use the following registry setting instead:

`registry write html disable-web-security 1`

To write this to the registry using [roRegistrySection](../../object-reference/hashing-and-storage-objects/roregistrysection.md):

```
RegHtml = CreateObject("roRegistrySection", "html")
RegHtml.Write("disable-web-security", "1")
RegHtml.Flush()
```

This flag will take effect on all `roHtmlWidget` instances, as opposed to previous flags which are only effective on the instance they are called on.

> [!NOTE]
> The `camera_enabled` parameter is currently supported on the XTx44/43, XDx34/33, HDx24/23, LS424/LS423, and 4Kx42 models.

`javascript_injection` roAssociativeArray: Specifies JavaScript code to inject at different initialization points (JavaScript code can also be injected during runtime using the `InjectJavaScript()` method). The associative array can contain three parameters (described below). Each parameter value is an array of associative arrays, each containing a single key/value pair. The array must contain a `source` key. The `source` value is a string that can contain any of the following: pure JavaScript code, a path to a JavaScript file, or a base64-encoded string (i.e. beginning with  `data:text/javascript;charset=utf-8;base64,` ). Mutliple `source` keys can be included, but the load order will be unpredictable. The array can also contain the optional `world` key, which can be assigned one of the following values: `"application"`, `"user"`, or `"main"`(see [this page](http://doc.qt.io/archives/qt-5.6/qwebenginescript.html#ScriptWorldId-enum) for more details); if the `world` parameter is not included in the array, `"application"` is selected by default.

*   `document_creation`: The script will run as soon as the document is created. This behavior is not suitable for any DOM operation.
    
*   `document_ready`: The script will run as soon as the DOM is ready. This behavior is equivalent to the `DOMContentLoaded` event firing in JavaScript. 
    
*   `deferred`: The script will run when the page load finishes.
    

```
config = {
      javascript_injection: { 
         document_creation: [{source: "0.js" }], 
         document_ready: [{source: "1a.js" }, {source: "1b.js" }], 
         deferred: [{source: "2.js" }] 
      },
      url: "..."
   }
```

`assets` roArray: Allows the *roHtmlWidget* instance to [access one or more asset pools](https://docs.brightsign.biz/display/DOC/roHtmlWidget#roHtmlWidget-MapFilesFromAssetPool(asset_poolAsroAssetPool,asset_collectionAsroAssetCollection,pool_prefixAsString,uri_prefixAsString)AsBooleanmapfilesfromassetpool). If a file exists in multiple specified asset pools, the asset pool with the lowest index in the array has precedence. Each array entry is an associative array containing information about an asset pool:

*   `pool` roAssetPool: An asset pool containing files 
    
*   `collection` roAssetCollection: A manifest identifying the files in the pool
    
*   `uri_prefix` string: The URI prefix of the webpage resources to retrieve from the pool
    
*   `pool_prefix` string: The pool prefix that will replace the URI prefix when looking up the resource in the pool
    

## ifHtmlWidget

##### GetFailureReason() As String

Gives more information when a member function returns `false`.

##### Hide() As Boolean

Hides the widget.

##### Show() As Boolean

Shows the widget.

##### raise()

Raises the html widget above all other graphical elements on screen (including other html widgets).

##### lower()

Lowers the html widget below all graphical elements on screen.

##### SetRectangle(r As roRectangle) As Boolean

Changes the size and positioning of the widget rectangle using the passed *roRectangle* object.

##### SetURL(URL As String) As Boolean 

Displays content from the specified URL. When using this method to retrieve content from local storage, specify the file location as follows: `"file:/<drive>:/<directory>/<filename>"`. For example, an *index.html* file in the "Content" folder on the SD card can be selected with the string `"file:/SD:/Content/index.html"`. You can also omit the drive specification to select the currently active drive (i.e. whichever drive the current autorun as loaded from).

##### AddAuthenticationCredentials (url As String, username As String, password As String) As Boolean

Tells Chromium to use  the specified username and password when retrieving the given URL.

##### MapFilesFromAssetPool(asset\_pool As roAssetPool, asset\_collection As roAssetCollection, pool\_prefix As String, uri\_prefix As String) As Boolean 

Sets the mapping between the URL space and the pool files. HTML content that has been deployed via BrightAuthor will typically reside in the pool and have encrypted SHA1-based filenames. A mapping mechanism is required to allow any relative URIs contained in the HTML content to continue working and to locate the appropriate resources in their respective pool locations.

You can use this method to bind part of the resource URI space onto pool locations. This method accepts the following arguments: an *roAssetPool* object containing assets, an *roAssetCollection* object identifying the assets, and two semi-arbitrary strings (URI\_PREFIX and POOL\_PREFIX).

Any URI in the form `"file:/[URI_PREFIX][RESOURCE_ID]"` will be rewritten into the form `"[POOL_PREFIX][RESOURCE_ID]"`. It will then be located in the pool as if that name had been passed to the *roAssetPoolFiles.GetPoolFilePath()* method. This binding occurs for every instance of *roHtmlWidget*, so different mappings can be used for different bundles of content.

##### SetZoomLevel(scale\_factor as Float) As Boolean

Adjusts the scale factor for the displayed page (the default equals 1.0).

##### EnablePinchToZoom(enable as Boolean) As Boolean

Enables or disables pinch-to-zoom functionality, which is disabled by default.

##### EnableSecurity(enable As Dynamic) As Boolean 

Deprecated. Use [security\_params](https://docs.brightsign.biz/display/DOC/roHtmlWidget#roHtmlWidget-%5BroAssociativeArray%5Dsecurity_params) in initialization parameters instead.

##### EnableMouseEvents(enable As Boolean) As Boolean

Deprecated. Use [mouse\_enabled](https://docs.brightsign.biz/display/DOC/roHtmlWidget#roHtmlWidget-%5Bboolean%5Dmouse_enabled) in initialization parameters instead.

##### SetPortrait(portrait\_mode As Boolean) As Boolean

Deprecated. Use [transform](https://docs.brightsign.biz/display/DOC/roHtmlWidget#roHtmlWidget-%5Bstring%5Dtransformtransform) in initialization parameters instead.

##### SetTransform(transform As String) As Boolean

Sets the screen orientation of content in the widget (note that the coordinates and dimensions of the *roRectangle* containing the widget are not affected by rotation). This method accepts the following strings:

*   `"identity"`: There is no transform (i.e. the widget content is oriented as landscape). This is the default setting.
    
*   `"rot90"`: The widget content is rotated to portrait at 90 degrees (clockwise).
    
*   `"rot270"`: The widget content is rotated to portrait at 270 degrees (counter-clockwise).
    

> [!NOTE]
> The JavaScript `onload` event will report landscape dimensions for a window that is rotated with the `SetPortrait()` or `SetTransform()` method. If your application relies on the `onload` event to retrieve window dimensions, we recommend instead using the [roHtmlWidget#transform](https://brightsign.atlassian.net/wiki/pages/resumedraft.action?draftId=370672896#roHtmlWidget-transform) initialization parameter, which ensures the HTML window is initialized with portrait dimensions.

##### SetAlpha(alpha As Integer) As Boolean

Sets the overall alpha level for the widget (the default equals 255).

##### EnableScrollbars(scrollbars As Boolean) As Boolean

Deprecated. Use [scrollbar\_enabled](https://docs.brightsign.biz/display/DOC/roHtmlWidget#roHtmlWidget-%5Bboolean%5Dscrollbar_enabled) in initialization parameters instead.

##### AddFont(filename As String) As Boolean

Deprecated. Use [fonts](https://docs.brightsign.biz/display/DOC/roHtmlWidget#roHtmlWidget-%5BroArray%5Dfonts) in initialization parameters instead.

##### SetPcmAudioOutputs(outputs As roArray) As Boolean

Deprecated. Use [pcm\_audio\_outputs](https://docs.brightsign.biz/display/DOC/roHtmlWidget#roHtmlWidget-%5BroArray%5Dpcm_audio_outputs) in initialization parameters instead.

##### SetCompressedAudioOutputs(outputs As roArray) As Boolean

Deprecated. Use [compressed\_audio\_outputs](https://docs.brightsign.biz/display/DOC/roHtmlWidget#roHtmlWidget-%5BroArray%5Dcompressed_audio_outputs) in initialization parameters instead.

##### SetMultichannelAudioOutputs(outputs As roArray) As Boolean

Deprecated. Use [multi\_channel\_audio\_outputs](https://docs.brightsign.biz/display/DOC/roHtmlWidget#roHtmlWidget-%5BroArray%5Dmulti_channel_audio_outputs) in initialization parameters instead. 

##### SetHWZDefault(default As String) As Void 

Deprecated. Use [hwz\_default](https://docs.brightsign.biz/display/DOC/roHtmlWidget#roHtmlWidget-%5Bstring%5Dhwz_default) in initialization parameters instead.

##### SetVideoPlayerDefaults(defaults As roAssociativeArray) As Boolean

Sets default playback settings for `<video>` elements in the widget. Available parameters are identical to the [*roVideoPlayer.PlayFile()*](../presentation-and-widget-objects/rovideoplayer.md) method. Default settings will be overwritten by parameters specified in individual `<video>` elements.

##### ForceGpuRasterization(enable As Boolean) As Boolean

Deprecated. As of OS8, GPU rasterization is enabled by default and calling this method has no effect.

##### EnableCanvas2dAcceleration(enable As Boolean) As Boolean

Deprecated. Use [canvas\_2d\_acceleration\_enabled](https://docs.brightsign.biz/display/DOC/roHtmlWidget#roHtmlWidget-%5Bboolean%5Dcanvas_2d_acceleration_enabled) in initialization parameters instead.

##### SetUserStylesheet(URI As String) As Boolean 

Deprecated. Use [user\_stylesheet](https://docs.brightsign.biz/display/DOC/roHtmlWidget#roHtmlWidget-%5Bstring%5Duser_stylesheet) in initialization parameters instead.

##### FlushCachedResources() As Boolean

Discards any resources that Chromium has cached in memory.

> [!CAUTION]
> Changing the storage path after an URL is loaded can cause the storage database to be irretrievably lost and/or damaged. Users should avoid using SetLocalStorageDir, SetWebDatabaseDir and SetAppCacheDir APIs when writing BrightScript applications.
> Since the BOS 6.0 release, BrightSign uses a single storage path for WebDatabase, LocalStorage and AppCache. This should be set by the `storage_path` parameter in roHtmlWidget static initialization parameters.
> With the BOS 8.2.35.4 release, if SetLocalStorageDir, SetWebDatabaseDir, or SetAppCacheDir are called, roHtmlWidget will use the path as the first one that is set. This directory will only set once and will be used for the subsequent use of roHtmlWidget as well.

##### SetLocalStorageDir(file\_path As String) As Boolean

Configures the HTML storage path. This method takes effect when a new *roHtmlWidget* instance is created; it doesn't apply to the *roHtmlWidget* instance on which it is called.

> [!NOTE]
> As of OS8, the `SetLocalStorageDir()`, `SetWebDatabaseDir()`, and `SetAppCacheDir()` methods all configure the same HTML database. See the [HTML Best Practices](../../../../developers/html-development/html-best-practices.md) page for more details.

##### SetWebDatabaseDir(file\_path As String) As Boolean

Configures the HTML storage path. See the `SetLocalStorageDir()` entry above for details.

This method takes effect when a new *roHtmlWidget* instance is created; it doesn't apply to the *roHtmlWidget* instance on which it is called.

##### SetAppCacheDir(file\_path As String) As Boolean 

Configures the HTML storage path. See the `SetLocalStorageDir()` entry above for details.

This method takes effect when a new *roHtmlWidget* instance is created; it doesn't apply to the *roHtmlWidget* instance on which it is called.

##### SetLocalStorageQuota(maximum As Dynamic) As Boolean

Sets the total size (in bytes) for all persistent HTML storage on the player. This method can accept a string, double, or integer. A number literal can only represent byte numbers up to 2GB; use a string to specify larger amounts. If the storage path is specified without a storage quota, Chromium defaults to reserving 1GB plus 10% of the total size of the storage device.

This method takes effect when a new *roHtmlWidget* instance is created; it doesn't apply to the *roHtmlWidget* instance on which it is called.

> [!NOTE]
> As of OS8, the `SetLocalStorageQuota()`, `SetWebStorageQuota()`, and `SetAppCacheQuota()` methods all configure a single storage quota, which applies to all persistent HTML storage on the player. See the [HTML Best Practices](../../../../developers/html-development/html-best-practices.md) page for more details.

##### SetWebDatabaseQuota(maximum As Dynamic) As Boolean

Sets the total size (in bytes) for all persistent HTML storage on the player. See the `SetLocalStorageQuota()` entry above for details.

This method takes effect when a new *roHtmlWidget* instance is created; it doesn't apply to the *roHtmlWidget* instance on which it is called.

##### SetAppCacheSize(maximum As Integer) As Boolean

Sets the maximum size (in bytes) for the application cache. Changing the storage size of the application cache will clear the cache and rebuild the cache storage. Depending on database-specific attributes, you will only be able to set the size in units that are equal to the page size of the database, which is established at creation. These storage units will occur only in the following increments: 512, 1024, 2048, 4096, 8192, 16384, 32768.

##### EnableJavaScript(enable As Boolean) As Boolean

Deprecated. Use [javascript\_enabled](https://docs.brightsign.biz/display/DOC/roHtmlWidget#roHtmlWidget-%5Bboolean%5Djavascript_enabled) in initialization parameters instead.

##### AllowJavaScriptURLs(url\_collection As roAssociativeArray)

Deprecated.  If `javascript_enabled` is set to `true` in the initialization parameters, JavaScript objects are enabled for all sites.

##### PostJSMessage(data As roAssociativeArray) As Boolean

Posts a collection of key:value pairs to the *BSMessagePort* JavaScript class (see the [JavaScript Objects for BrightScript tech note](https://docs.brightsign.biz/display/DOC/BSMessagePort) for more details). This method does not support passing nested associative arrays.

##### InjectJavaScript(code As String) As Boolean

Immediately injects a user script into the JavaScript engine. The passed string can contain any of the following: pure JavaScript code, a path to a JavaScript file, or a base64-encoded string (i.e. beginning with  `data:text/javascript;charset=utf-8;base64,` ). 

This method can be used to simulate the `bind_ready` option:

```
if type(event) = "roHtmlWidgetEvent" then               
   if event.GetData().reason = "load-finished" then
      h.InjectJavascript("fillPasswordFields()")      
  end if
end if
```

> [!NOTE]
> Changing the DOM is only possible at `bind_dom_loaded` and `bind_ready`. Also, since JavaScript is only guaranteed to be ready at `bind_ready`, your callbacks must use this event if they invoke any global functions.

##### StartInspectorServer(port As Integer) As Boolean

Deprecated. Use [inspector\_server](https://docs.brightsign.biz/display/DOC/roHtmlWidget#roHtmlWidget-%5BroAssociativeArray%5Dinspector_server) in initialization parameters instead.

##### SetUserAgent(user\_agent As String) As Boolean

Deprecated. Use [user\_agent](https://docs.brightsign.biz/display/DOC/roHtmlWidget#roHtmlWidget-%5Bstring%5Duser_agent) in initialization parameters instead.

##### GetUserAgent() As String

Returns the currently active user-agent string for the *roHtmlWidget* instance.

##### SetUserAgentSuffix(suffix As String) As Boolean

Deprecated. Use [user\_agent](https://docs.brightsign.biz/display/DOC/roHtmlWidget#roHtmlWidget-%5Bstring%5Duser_agent) in initialization parameters instead.

##### SetProxy(proxy as String) As Boolean

Sets the name or address of the proxy server that the *roHtmlWidget* instance will use to make HTTP requests. This method takes effect immediately. It does not affect network operations performed by other components in the firmware. The string can be used to specify either the proxy URL or the location of a *.pac* proxy file:

*   **Proxy URL**: The proxy address should be formatted as "[http://user:password@hostname:port](http://user:password@hostnameport)". The hostname can contain up to four "\*" characters; each "\*" character can be used to replace one octet from the current IP address. For example, if the IP address is currently 192.168.1.2, and the proxy is set to "proxy-\*-\*", then the player will attempt to use a proxy named "proxy-192.168".
    
*   **Proxy File**: The *.pac* proxy file can be located on either the local file system or the network. If the file is local, there are no file-name restrictions; if the file is located on the network, the file name should have a *.pac* extension. If the URL is a hostname only, it will be considered a proxy-server address rather than a file URL.
    

> [!TIP]
> **Example**
>  The following are examples of valid location formats for *.pac* files:
> *   [file:///storage/sd/asset\_pool/a/b/ababababababa](#)
>     
> *   [http://example:8080/setup/proxy.pac](http://example:8080/setup/proxy.pac)
>     
> *   [https://example/encrypted/proxy.pac](https://example/encrypted/proxy.pac)
>     
> *   [https://example:433/encrypted/proxy.pac](https://example:433/encrypted/proxy.pac)
>     
> *   [ftp://example/files/proxy.pac](ftp://example/files/proxy.pac)
>     
> *   [file:///storage/sd/myproxypac.txt](#)

##### SetProxyBypass(hostnames As String) As Boolean

Exempts the specified hosts from the proxy configuration on the *roHtmlWidget* instance. The passed array should consist of one or more hostnames. The player will attempt to reach the specified hosts directly rather than using the proxy that has been specified with the `SetProxy()` method. For example, the hostname "[example.com](http://example.com)" would exempt "[example.com](http://example.com)", "[example.com](http://example.com):80", and "[www.example.com](http://www.example.com)" from the proxy setting.

##### AddProxyAuthenticationCredentials(hostname As String, username As String, password As String)

Allows the user to set up one or more proxies. If proxy pac files are included, this method must be used to specify authentication parameters.

##### roHtmlWidget.acceptdialog(response as String) 

Accept any dialog request with the given string, if there is any such request. This parameter was added in BOS 8.5.16.

##### roHtmlWidget.rejectdialog()

Reject any dialog request. This parameter was added in BOS 8.5.16.

## ifMessagePort

##### SetPort(port As roMessagePort)

Posts messages of type *roHtmlWidgetEvent* to the attached message port.

## ifUserData

##### SetUserData(user\_data As Object)

Sets the user data that will be returned when events are raised.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()`. It will return Invalid if no data has been set.

## Available Methods with Initialization 

If the properties of an *roHtmlWidget* object are configured at initialization, most *ifHtmlWidget* methods will be disabled. However, the following methods are still functional:

*   `Hide()`
    
*   `Show()`
    
*   `EnablePinchToZoom()`
    
*   `FlushCachedResources()`
    
*   `SetUserAgent()`
    
*   `GetUserAgent()`
    
*   `SetUserAgentSuffix()`
    
*   `PostJSMessages()`
    

## Examples 

The following examples show how to use either an associative array or object methods to configure an *roHtmlWidget* instance using local storage to cache the files.

Note that these techniques are mutually exclusive.

Example (with initialization properties):

```
x = 0
y = 0
width = 1920
height = 1080
url = "http://www.brightsign.biz"
 
rect = CreateObject("roRectangle", x, y, width, height)
 
config = {
url: url,
mouse_enabled: true,
storage_path: "/local/",
}
 
html = CreateObject("roHtmlWidget", rect, config)
 
html.Show()
```

Example (with methods):

```
x = 0
y = 0
width = 1920
height = 1080
url = "http://www.brightsign.biz"

rect = CreateObject("roRectangle", x, y, width, height)
html = CreateObject("roHtmlWidget", rect)


html.SetUrl(url)
html.EnableMouseEvents(true)
html.SetLocalStorageDir("/local/")
html.Show()
```
----
developers\developers\brightscript\object-reference\presentation-and-widget-objects\rohtmlwidgetevent.md
# roHtmlWidgetEvent

If an *roMessagePort* is attached to an *roHtmlWidget*, it will receive *roHtmlWidgetEvent* objects when something happens to the parent *roHtmlWidget* instance. 

## ifUserData

##### SetUserData(user\_data As Object)

Sets the user data that will be returned when events are raised.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()`. It will return Invalid if no data has been set.

## ifHTMLWidgetEvent

##### GetData() As roAssociativeArray

Returns the event data as an associative array with the following key/value pairs:

*   `reason` string: The cause of the event, which can be one of the following:
    
    *   `"load-started"`: The HTML widget has started loading a page.
        
    *   `"load-finished"`: The HTML widget completed loading a page.
        
    *   `"load-error"`: The HTML widget failed to load a page. Use the `uri` key to identify the failing resource and the `message` key to retrieve some explanatory text.
        
    *   `"download-request"`: The HTML widget instance has received a download request. The Chromium instance does not process download requests for MIME types it doesn't recognize (e.g. PDFs); instead, it passes this event, along with the `mime-type` and `url` parameters to the BrightScript autorun for processing.
        
    *   `"new-window-request"`: The HTML widget instance has received a request to open a URI in a new window. This request will normally come from HTML anchors with `"target=_blank"`/`"target=_top"` or the JavaScript `Window.open()` method. The requested URI is specified in the `uri` parameter.
        
*   `javascript-dialog` string: If the HTML widget instance has received a JavaScript alert, confirmation, etc., BrightScript will respond by calling the roHtmlWidget `acceptdialog(responseasString)` and `rejectdialog()` methods. See [roHtmlWidget#roHtmlWidget.acceptdialog(responseasString)](../presentation-and-widget-objects/rohtmlwidget.md). If no response is provided within one second, roHtmlWidget auto rejects the dialog attempt, and if these APIs are called when there is no dialog request on roHtmlWidget, they have no effect. This parameter was added in BOS 8.5.16.
    
*   `message` string: The message that the JavaScript dialog will display (applicable for `reason:"javascript-dialog"` only), or explanatory text related to the load failure (applicable for reason:"load-error" only). This property exists for multiple event types, but it has different meanings for different event types.
    
*   `default_text` string:  If a JavaScript prompt dialog asks the user to enter text, this default text will be displayed in the input field. This field will be empty for other dialog types (applicable for `reason:"javascript-dialog"` only). This parameter was added in BOS 8.5.16.
    
*   `type` int: The dialog type for the `“javascript-dialog”` event: either 0 for alert, 1 for confirm, 2 for prompt, 3 for an "onbeforeunload Event" (applicable for `reason:"javascript-dialog"` only). This parameter was added in BOS 8.5.16.
    
*   `security_origin` string: The security origin of the request (applicable for `reason:"javascript-dialog"` only). This parameter was added in BOS 8.5.16.
    
*   `uri` string: The URI of the failing resource or new-window request (applicable for `reason:"load-error"` or `reason:"new-window-request"`)
    
*   `mime-type` string: The MIME type of the download request (applicable for `reason:"download-request"` only)
    
*   `url` string: The URL of the download request (applicable for `reason:"download-request"` only)
    

## Example

The following event loop waits for an HTML widget event. If the event indicates that a PDF download request has been received, the script passes the relevant data to a *CreatePdfRenderer()* function that is not defined here:

```
while true
	ev = wait(0, gaa.mp)
	print "=== BS: Received event ";type(ev)
	if type(ev) = "roHtmlWidgetEvent" then
		eventData = ev.GetData()
		if type(eventData) = "roAssociativeArray" and type(eventData.reason) = "roString" then
			if eventData.reason = "load-error" then
				print "=== BS: HTML load error: "; eventData.message
			else if eventData.reason = "load-finished" then
				print "=== BS: Received load finished"
				receivedLoadFinished = true
			else if eventData.reason = "message" then
				' To use this: msgPort.PostBSMessage({text: "my message"});
			else if eventData.reason = "load-started" then
				print "=== BS: Received load started"
			else if eventData.reason = "download-request" then
				print "=== BS: Received a download request"
				if eventData.mime_type = "application/pdf" then
					CreatePdfRenderer("file:///index.html?file=" + eventData.url)
				endif
			else
				print "======= UNHANDLED HTML EVENT ========="
				print eventData.reason
			endif
		else
			print "=== BS: Unknown eventData: "; type(eventData)
		endif
	endif
endwhile
```
----
developers\developers\brightscript\object-reference\presentation-and-widget-objects\roimagebuffer.md
# roImageBuffer

This object allows you to access decoded image-file data. You can then copy or manipulate that data.

Object Creation: An *roImageBuffer* object is instantiated with an *roImagePlayer* object and a string specifying the file path of an image file. If an *roImagePlayer* object is not needed, `Invalid` can be substituted for it.

```
CreateObject("roImageBuffer", image_player As Object, file_path As String)
```

Example:

```
imgBuffer = CreateObject("roImageBuffer", Invalid, "SD:/content/image.png")
```

## ifImageBufferControl

##### DisplayBuffer(x As Integer, y As Integer) As Boolean

Displays the image on screen. The `x` and `y` integers specify the coordinates of the top-left corner of the image.

> [!CAUTION]
> **Important**
> The `DisplayBuffer`() method has been deprecated. As of OS8, the end point exists but does not perform any function.

##### GetBufferByteArray() As roByteArray

Returns the decoded image-file data as an *roByteArray*.

##### GetBufferMetadata() As roAssociativeArray

Returns an associative array containing information about the image file. The associative array contains the following keys:

*   `width`: The width of the image file
    
*   `height`: The height of the image file
    
*   `acceptable`: A Boolean integer value indicating whether the image can be displayed by the *roImagePlayer* instance
    
*   `format`: The color space (ARGB/CMYK) of the image file
    

##### ConvertFormat(a As String) As Object

#####
----
developers\developers\brightscript\object-reference\presentation-and-widget-objects\roimageplayer.md
# roImagePlayer

This object displays static bitmap images on the video display. The simplest way to use *roImagePlayer* is to make calls to `DisplayFile()` with the filename as a String. Alternatively, you can use `PreloadFile()` in conjunction with `DisplayPreload()` to have more control. For more pleasing aesthetics when generating an image player, use the *roImageWidget* object. The JavaScript equivalent is the [<img> tag in HTML](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img).

Object Creation: The image player is displayed by first creating *roRectangle* and *roImagePlayer* instances, then calling `SetRectangle()` using the *roRectangle* instance as the argument.

```
rectangle = CreateObject("roRectangle", 0, 0, 1024, 768)
i = CreateObject("roImagePlayer")
i.SetRectangle(rectangle)
```

## ifImageControl 

##### DisplayFile(image\_filename As String) As Boolean

Displays the image with the specified filename. The image\_filename string must point to a *.png*, *.jpeg*, or 8-bit, 24-bit, or 32-bit *.bmp* file. Note that *.jpeg* image files with CMYK color profiles are not supported.

##### DisplayFile(parameters As roAssociativeArray) As Boolean

Displays an image using an associative array of display parameters:

*   `Filename`: The name of the image file
    
*   `Mode`: The image mode. See the entry for SetDefaultMode() below for more details.
    
*   `Transition`: The image transition setting. See the entry for SetDefaultTransition() below for more details.
    
*   `EncryptionAlgorithm`: The file-encryption algorithm. Currently the options are "AesCtr" and "AesCtrHmac".
    
*   `EncryptionKey`: The key to decrypt the image file. This is a byte array consisting of 128 bits of key, followed by 128 bits of IV.
    

See the [Image Decryption](https://docs.brightsign.biz/display/DOC/roImagePlayer#roImagePlayer-ImageDecryptionimage_decryption) section below for details on displaying encrypted images.

> [!CAUTION]
> **Important**
> The image player no longer accepts "{A|A}" AES encryption keys (i.e. where the top and bottom 64 bits of the key are identical).

##### PreloadFile(image\_filename As String) As Boolean

Loads the specified image file into an offscreen memory buffer.

##### PreloadFile(parameters As roAssociativeArray) As Boolean

Loads an image file into an offscreen memory buffer. Image display properties are determined by an associative array of parameters:

*   `Filename`: The name of the image file
    
*   `Mode`: See the entry for SetDefaultMode() below for more details.
    
*   `Transition`: See the entry for SetDefaultTransition() below for more details.
    

##### DisplayPreload() As Boolean

Uses the on-screen memory buffer to display the image stored in the offscreen memory buffer using `PreloadFile()`. There are only two memory buffers: one is displayed on screen; and the other is used for preloading images. `PreloadFile()`can be called multiple times before `DisplayPreload()` is called, and will keep loading into the same off-screen buffer. The `DisplayFile()` method calls `PreloadFile()` followed immediately by `DisplayPreload()`, so any previously preloaded image will be lost. If no image is preloaded, `DisplayPreload()` will have no effect.

##### StopDisplay() As Boolean

Removes an image from the display.

##### DisplayFileEx(filename As String, mode As Integer, x As Integer, y As Integer) As Boolean  
 

##### PreloadFileEx(filename As String, mode As Integer, x As Integer, y As Integer) As Boolean

##### SetDefaultMode(mode As Integer) As Boolean

Sets the default image display mode for DisplayFile() and PreloadFile(). If SetDefaultMode() is not called, then the default mode is set to 0 (equivalent to the image being centered without scaling). The supported display mode are listed below:

*   **0 – Center image**: No scaling takes place. Cropping only occurs if the image is bigger than the window.
    
*   **1 – Scale to fit**: The image is scaled so that it is fully viewable, with its aspect ratio maintained.
    
*   **2 – Scale to fill and crop**: The image is scaled so that it completely fills the window, with its aspect ratio maintained.
    
*   **3 – Scale to fill**: The image is stretched so that it fills the window and the whole image is viewable. The aspect ratio will not be maintained if it is different from the window.
    

##### SetDefaultTransition(transition As Integer) As Boolean

Sets the transition to be used when the next image is displayed. The following are available transitions:

*   0: No transition: immediate blit
    
*   1-4: Wipes from top, bottom, left, or right.
    
*   5-8: Explodes from centre, top left, top right, bottom left, or bottom right.
    
*   10-11: Uses vertical or horizontal venetian-blind effect.
    
*   12-13: Combs vertical or horizontal.
    
*   14: Fades out to background color, then back in.
    
*   15: Fades between current image and new image.
    
*   16-19: Slides from top, bottom, left or right.
    
*   20-23: Slides entire screen from top, bottom, left, or right.
    
*   24-25: Scales old image in, then the new one out again (this works as a pseudo rotation around a vertical or horizontal axis).
    
*   26-29: Expands a new image onto the screen from right, left, bottom, or top.
    

##### SetTransform(transform As String) As Boolean

Applies one of eight transforms to the image. Calls to this method only take effect when the next file is displayed. Note that the image rectangle itself does not change to accommodate the new height and width ratio of a transformed image. This method can be called separately on multiple *roImagePlayer* or *roImageWidget* instances.

*   `identity`: No transformation (default behavior)
    
*   `rot90`: 90 degree clockwise rotation
    
*   `rot180`: 180 degree rotation
    
*   `rot270`: 270 degree clockwise rotation
    
*   `mirror`: Horizontal mirror transformation
    
*   `mirror_rot90`: Mirrored 90 degree clockwise rotation
    
*   `mirror_rot180`: Mirrored 180 degree clockwise rotation
    
*   `mirror_rot270`: Mirrored 270 degree clockwise rotation
    

##### OverlayImage(image\_filename As String, x As Integer, y As Integer) As Boolean

Composites the image with the specified filename on top of the primary `DisplayFile()` image. Use the `x` and `y` integers to specify its location within the image widget.

##### SetRectangle(r As roRectangle) As Boolean

Changes the size and positioning of the image rectangle using the passed *roRectangle* object.

##### GetRectangle() As roRectangle

Returns an *roRectangle* object that has the same location and dimensions as the *roRectangle* object used to define the image window.

##### CreateTestHole(hole As roRectangle) As Boolean

Creates a hole in the image with the location and dimensions specified in the passed *roRectangle* instance. Any video windows located directly beneath the image will show through. This method will disrupt image playback and should be used for test purposes only.

##### SetTransitionDuration(duration As Integer) As Boolean

Sets the amount of time it takes (in milliseconds) for a specified transition effect to take place. The default transition duration is 1000 milliseconds.

##### DisplayBuffer(a As Object, b As Integer, c As Integer) As Boolean  
 

##### Hide() As Boolean

Hides the image currently being displayed by the *roImagePlayer* widget.

##### Show() As Boolean

Shows the image currently being displayed by the *roImagePlayer* widget.

##### Raise() As Void

Sends the widget to the top of the z-order on the graphics plane (i.e. in front of all other surfaces that implement the *ifWidget* interface). By default, new widgets are placed at the top of the graphics z-order.

> [!NOTE]
> Some surfaces are always drawn at the top of the graphics z-order, including the mouse cursor, closed captions, and [scrolling tickers](../presentation-and-widget-objects/rotextwidget.md).

> [!TIP]
> **Tip**
> You can use the `PauseGraphics()`/ `ResumeGraphics()` methods on the [*roVideoMode*](../presentation-and-widget-objects/rovideomode.md) object to ensure multiple changes to the graphics z-order occur simultaneously.

##### Lower() As Void

Sends the widget to the bottom of the z-order on the graphics plane (i.e. behind all other surfaces that implement the *ifWidget* interface). By default, new widgets are placed at the top of the graphics z-order.

## X, Y

The x and y values indicate which position of the image to center as near as possible, or both x and y can be set to -1, which uses the center of the image as the point to position nearest to the center.

To display images in a zone, `SetRectangle()` must be called, and `EnableZoneSupport()` must be included in a script to use the zones functionality.

## Testing Display Modes

Here are some example shell commands you can use to test the different display modes:

```
BrightSign> image filename.bmp 0
BrightSign> image filename.bmp 1
BrightSign> image filename.bmp 2
BrightSign> image filename.bmp 3

BrightSign> image filename.bmp 0 0 0
BrightSign> image filename.bmp 2 0 0
```

## Preloading Images

The following example script uses preloaded images to improve the UI speed when the user hits a key on the keyboard. As soon as a key is struck, the display switches to the new image, which has already been preloaded. The only possible delay occurs if the key is hit while the image is preloading. In this case, the image will display as soon as it is loaded.

```
i = CreateObject("roImagePlayer")
p = CreateObject("roMessagePort")
k = CreateObject("roKeyboard")
k.SetPort(p)

i.PreloadFile("one.bmp")

loop:
i.DisplayPreload
i.PreloadFile("two.bmp")
Wait(0,p)
i.DisplayPreload
i.PreloadFile("one.bmp")
Wait(0,p)
goto loop
```

## Image Decryption 

The *roImagePlayer*, *roImageWidget*, *roClockWidget*, *roTextWidget*, and *roCanvasWidget* objects can be used to display encrypted images. Each object has an image playback method that accepts an associative array, which can include the `EncryptionAlgorithm` and `EncryptionKey` decryption parameters.

> [!NOTE]
> Contact [support@brightsign.biz](mailto:support@brightsign.biz) to learn more about generating a key for obfuscation and storing it on the player.

You can call `roDeviceInfo.HasFeature("media_decryption")`  to determine if a player model and firmware version supports image decryption.

Example:

```
print "Play ENCRYPTED image in an image widget"

imagePlayer = CreateObject("roImageWidget", r1)

aa=CreateObject("roAssociativeArray")
aa.filename = "sd:/images_enc.jpg"
aa.encryptionalgorithm = "AesCtr"
aa.encryptionkey = CreateObject("roByteArray")
aa.encryptionkey.fromhexstring("01030507090b0d0f00020406080a0c0e00000000000000000000000000000000")

imagePlayer.DisplayFile(aa)
sleep(10000)
imagePlayer.Hide()

print "Play ENCRYPTED image with PlayStaticImage"

videoPlayer = CreateObject("roVideoPlayer")

aa=CreateObject("roAssociativeArray")
aa.filename = "sd:/images_enc.jpg"
aa.encryptionalgorithm = "AesCtr"
aa.encryptionkey = CreateObject("roByteArray")
aa.encryptionkey.fromhexstring("01030507090b0d0f00020406080a0c0e00000000000000000000000000000000")

videoPlayer.PlayStaticImage(aa)
sleep(10000)
videoPlayer = invalid

print "Show CLOCK image"

resourceManager = CreateObject("roResourceManager", "sd:/resources.txt")

clockWidget = CreateObject("roClockWidget", r1, resourceManager, {})

aa=CreateObject("roAssociativeArray")
aa.filename = "sd:/images_enc.jpg"
aa.encryptionalgorithm = "AesCtr"
aa.encryptionkey = CreateObject("roByteArray")
aa.encryptionkey.fromhexstring("01030507090b0d0f00020406080a0c0e00000000000000000000000000000000")

clockWidget.SetBackgroundBitmap(aa, True)
clockWidget.Show()
sleep(10000)
clockWidget.Hide()

print "Text widget with encrypted background image"

twParams = CreateObject("roAssociativeArray")
twParams.LineCount = 1
twParams.TextMode = 1
twParams.Rotation = 0
twParams.Alignment = 1

tw=CreateObject("roTextWidget",r1,1,2,twParams)
tw.SetBackgroundColor(&h00ff0000)
tw.SetForegroundColor(&hff00ff00)
tw.PushString("Encrypted Background")
'tw.SetRectangle(r)

aa=CreateObject("roAssociativeArray")
aa.filename = "sd:/images_enc.jpg"
aa.encryptionalgorithm = "AesCtr"
aa.encryptionkey = CreateObject("roByteArray")
aa.encryptionkey.fromhexstring("01030507090b0d0f00020406080a0c0e00000000000000000000000000000000")

tw.SetBackgroundBitmap(aa, True)
tw.Show()
sleep(10000)
tw.Hide()

cw=CreateObject("roCanvasWidget", rect)
canvas_aa=CreateObject("roAssociativeArray")
canvas_aa.Filename = "sd:/images_enc.jpg"
canvas_aa.Encryptionalgorithm = "AesCtr"
canvas_aa.EncryptionKey = CreateObject("roByteArray")
canvas_aa.EncryptionKey.FromHexString("01030507090b0d0f00020406080a0c0e00000000000000000000000000000000")
cw.SetLayer(canvas_aa, 1)
cw.Show() 
```
----
developers\developers\brightscript\object-reference\presentation-and-widget-objects\roimagewidget.md
# roImageWidget

This object can be used in place of *roImagePlayer* in cases where the image is displayed within a rectangle. Using an *roImageWidget* can result in more pleasing aesthetics for image player creation; it can also be used to display images in a multi-screen array. Beyond this, *roImageWidget* behaves identically to *roImagePlayer*. The JavaScript equivalent is the [<img> tag in HTML](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img).

Object Creation: The image widget area is generated using an *roRectangle* object.

```
rectangle = CreateObject("roRectangle", 0, 0, 1024, 768)
i = CreateObject("roImageWidget", rectangle)
```

## ifImageControl 

##### DisplayFile(image\_filename As String) As Boolean

Displays the image with the specified filename. The image\_filename string must point to a *.png*, *.jpeg*, or 8-bit, 24-bit, or 32-bit *.bmp* file. Note that *.jpeg* image files with CMYK color profiles are not supported.

##### DisplayFile(parameters As roAssociativeArray) As Boolean

Displays an image using an associative array of display parameters:

*   `Filename`: The name of the image file
    
*   `Mode`: The image mode. See the entry for SetDefaultMode() below for more details.
    
*   `Transition`: The image transition setting. See the entry for SetDefaultTransition() below for more details.
    
*   `EncryptionAlgorithm`: The file-encryption algorithm. Currently the options are "AesCtr" and "AesCtrHmac".
    
*   `EncryptionKey`: The key to decrypt the image file. This is a byte array consisting of 128 bits of key, followed by 128 bits of IV.
    

See the [Image Decryption](../presentation-and-widget-objects/roimageplayer.md) descrption in the *roImagePlayer* entry for details on displaying encrypted images.

##### PreloadFile(image\_filename As String) As Boolean

Loads the specified image file into an offscreen memory buffer.

##### PreloadFile(parameters As roAssociativeArray) As Boolean

Loads an image file into an offscreen memory buffer. Image display properties are determined by an associative array of parameters:

*   `Filename`: The name of the image file
    
*   `Mode`: See the entry for SetDefaultMode() below for more details.
    
*   `Transition`: See the entry for SetDefaultTransition() below for more details.
    

##### DisplayPreload() As Boolean

Uses the on-screen memory buffer to display the image stored in the offscreen memory buffer using `PreloadFile()`. There are only two memory buffers: one is displayed on screen; and the other is used for preloading images. `PreloadFile()`can be called multiple times before `DisplayPreload()` is called, and will keep loading into the same off-screen buffer. The `DisplayFile()` method calls `PreloadFile()` followed immediately by `DisplayPreload()`, so any previously preloaded image will be lost. If no image is preloaded, `DisplayPreload()` will have no effect.

##### StopDisplay() As Boolean

Removes an image from the display.

##### DisplayFileEx(filename As String, mode As Integer, x As Integer, y As Integer) As Boolean  
 

##### PreloadFileEx(filename As String, mode As Integer, x As Integer, y As Integer) As Boolean

##### SetDefaultMode(mode As Integer) As Boolean

Sets the default image display mode for DisplayFile() and PreloadFile(). If SetDefaultMode() is not called, then the default mode is set to 0 (equivalent to the image being centered without scaling). The supported display mode are listed below:

*   **0 – Center image**: No scaling takes place. Cropping only occurs if the image is bigger than the window.
    
*   **1 – Scale to fit**: The image is scaled so that it is fully viewable, with its aspect ratio maintained.
    
*   **2 – Scale to fill and crop**: The image is scaled so that it completely fills the window, with its aspect ratio maintained.
    
*   **3 – Scale to fill**: The image is stretched so that it fills the window and the whole image is viewable. The aspect ratio will not be maintained if it is different from the window.
    

##### SetDefaultTransition(transition As Integer) As Boolean

Sets the transition to be used when the next image is displayed. The following are available transitions:

*   0: No transition: immediate blit
    
*   1-4: Wipes from top, bottom, left, or right.
    
*   5-8: Explodes from centre, top left, top right, bottom left, or bottom right.
    
*   10-11: Uses vertical or horizontal venetian-blind effect.
    
*   12-13: Combs vertical or horizontal.
    
*   14: Fades out to background color, then back in.
    
*   15: Fades between current image and new image.
    
*   16-19: Slides from top, bottom, left or right.
    
*   20-23: Slides entire screen from top, bottom, left, or right.
    
*   24-25: Scales old image in, then the new one out again (this works as a pseudo rotation around a vertical or horizontal axis).
    
*   26-29: Expands a new image onto the screen from right, left, bottom, or top
    

##### SetTransform(transform As String) As Boolean

Applies one of eight transforms to the image. Calls to this method only take effect when the next file is displayed. Note that the image rectangle itself does not change to accommodate the new height and width ratio of a transformed image. This method can be called separately on multiple *roImagePlayer* or *roImageWidget* instances.

*   `identity`: No transformation (default behavior)
    
*   `rot90`: 90 degree clockwise rotation
    
*   `rot180`: 180 degree rotation
    
*   `rot270`: 270 degree clockwise rotation
    
*   `mirror`: Horizontal mirror transformation
    
*   `mirror_rot90`: Mirrored 90 degree clockwise rotation
    
*   `mirror_rot180`: Mirrored 180 degree clockwise rotation
    
*   `mirror_rot270`: Mirrored 270 degree clockwise rotation
    

##### OverlayImage(image\_filename As String, x As Integer, y As Integer) As Boolean

Composites the image with the specified filename on top of the primary `DisplayFile()` image. Use the `x` and `y` integers to specify its location within the image widget.

##### SetRectangle(r As roRectangle) As Boolean

Changes the size and positioning of the image rectangle using the passed *roRectangle* object.

##### GetRectangle() As roRectangle

Returns an *roRectangle* object that has the same location and dimensions as the *roRectangle* object used to define the image window.

##### CreateTestHole(hole As roRectangle) As Boolean

Creates a hole in the image with the location and dimensions specified in the passed *roRectangle* instance. Any video windows located directly beneath the image will show through. This method will disrupt image playback and should be used for test purposes only.

##### SetTransitionDuration(duration As Integer) As Boolean

Sets the amount of time it takes (in milliseconds) for a specified transition effect to take place. The default transition duration is 1000 milliseconds.

##### DisplayBuffer(a As Object, b As Integer, c As Integer) As Boolean

##### Hide() As Boolean

Hides the image currently being displayed by the *roImageWidget* instance.

##### Show() As Boolean

Shows the image currently being displayed by the *roImageWidget* instance.

## Multiscreen Images

This object includes overloaded `PreloadFile()` and `DisplayFile()` methods. These methods receive an [*roAssociativeArray*](#) object that stores various options to be passed. They must be used when displaying images across multiple screens in an array, or displaying a portion of an image—though they can also be used in place of the original method calls in all cases.

The following code uses the `PreloadFile()` method for a multiscreen display:

```
i=CreateObject("roImageWidget")
a=CreateObject("roAssociativeArray")
a["Filename"] = "test.jpg"
a["Mode"] = 1
a["Transition"] = 14
a["MultiscreenWidth"] = 3
a["MultiscreenHeight"] = 2
a["MultiscreenX"] = 0
a["MultiscreenY"] = 0
i.PreloadFile(a)
i.DisplayPreload
```

The `filename`, `mode`, and `transition` values are the same as those documented for the `DisplayFile()` and `PreloadFile()` methods above. The `MultiscreenWidth` and `MultiscreenHeight` parameters specify the width and height of the multi-screen matrix. For example, 3x2 would be three screens wide and two screens high. The `MultiscreenX` and `MultiscreenY` specify the position of the current screen within that matrix.

In the above case, on average only 1/6 of the image is drawn on each screen, though the image mode still applies so that, depending on the shape of the image, it may have black bars on the side screens. It is relatively simple, therefore, for an image widget to display part of an image based on its position in the multiscreen array. The following are default values for the parameters:

*   Mode = 0
    
*   Transition = 0
    
*   MultiscreenWidth = 1
    
*   MultiscreenHeight = 1
    
*   MultiscreenX = 0
    
*   MultiscreenY = 0
    

This code uses `DisplayFile()` to display a portion of an image:

```
i=CreateObject("roImageWidget")
a=CreateObject("roAssociativeArray")
a["Filename"] = "test.JPG"
a["Mode"] = 0
a["SourceX"] = 600
a["SourceY"] = 600
a["SourceWidth"] = 400
a["SourceHeight"] = 400
i.DisplayFile(a)
```

This displays just a portion of the image test JPG starting at coordinates `SourceX`, `SourceY`, and `SourceWidth` by `SourceHeight` in size. The `viewmode` is still honored as if it were displaying the whole file.
----
developers\developers\brightscript\object-reference\presentation-and-widget-objects\ronodejs.md
# roNodeJs

*roNodeJs* is a BrightScript object that allows the launching of a Node.js® instance. These Node.js instances will have access to all BrightSign Node.js modules as built in modules. roNodeJs also provides mechanisms to communicate between JavaScript and BrightScript environments for more complex applications.

## Object Creation

*roNodeJs* is instantiated with a filename and optional parameters. 

```
node = CreateObject("roNodeJs", "index.js", {message_port:my_message_port, arguments: ["arg1", "arg2"]})
```

In OS 8.2.17 and later versions, you can also pass an optional *node\_arguments* parameter which provides arguments to the node interpreter itself (as opposed to *arguments* which provides arguments to the JavaScript application being run inside Node):

```
node = CreateObject("roNodeJs", "index.js", {message_port:my_message_port, node_arguments: ["arg"], arguments: ["arg1", "arg2"]})
```

*   `message_port:` Optional. Allows communication with JavaScript applications. 
    
*   `arguments:` Optional. Passes arguments to the node instance. 
    
*   `node_arguments:` Optional. Passes arguments to the node.js executable, for example, to enable remote inspector for node.js. *Node\_arguments* can take multiple arguments.
    
*   `env_vars:` Optional. Passes environment variables (supplied as an associative array) to the node.js application. **Note:** Environment variable names are case-sensitive, but *roAssociativeArray* is case-insensitive by default and the BrightScript literal syntax for associative arrays forces all key names to lower case. To ensure correct behavior, call `SetModeCaseSensitive()` and use the `AddReplace()` method to add variables to the array. Or you can use the following example, which is slightly less verbose than `AddReplace():`
    

```
a={}
a.SetModeCaseSensitive()
a["KeY"] = 1
a["key"] = 2
print a  ' returns both key and KeY
```

## PostJsMessage()

`PostJsMessage (data as AssociativeArray) As Boolean`  
Posts a collection of key:value pairs to the BrightScript *MessagePort* JavaScript class. This method takes an associative array but it doesn't support nested associative arrays. See [JavaScript to BrightScript](https://docs.brightsign.biz/display/DOC/messageport) for more details.

## roNodeJs Events

See this [page](https://docs.brightsign.biz/display/DOC/roNodeJsEvent) for information about roNodeJs events.

## Examples

To enable inspector using node\_arguments:

```
node_js = CreateObject("roNodeJs", "main.js", {message_port: msgPort, node_arguments: ["--inspect=0.0.0.0:2999"], arguments:["node_application_argument1", "node_application_argument2"})
```

To change a directory to the directory of the current JavaScript file:

```
proc.chdir(__dirname)
```

To set a timer to stop node from exiting:

```
setInterval(function(){console.log("ping"}, 10000)
```

To pass arguments to roNodeJs:

```
node = CreateObject("roNodeJs", "index.js",
{node_arguments: ["-r", "dotenv/config"], arguments: ["dotenv_config_path=/storage/sd/.env"]})
```

Note that "node\_arguments" are arguments that come before the filename, while "arguments" come after the filename.
----
developers\developers\brightscript\object-reference\presentation-and-widget-objects\ronodejsevent.md
# roNodeJsEvent

If an *roMessagePort* is attached to an *roNodeJs*, it will receive *roNodeJsEvent* objects when something happens to the parent *roNodeJs* instance.

## ifUserData

`SetUserData(user_data As Object)`  
Sets the user data that will be returned when events are raised.

`GetUserData() As Object`  
Returns the user data that has previously been set via `SetUserData()`. It will return `Invalid` if no data has been set.

## ifNodeJsEvent

`GetData() As roAssociativeArray`  
Returns the event data as an associative array with the following key/value pairs:

*   `reason` string: The cause of the event, which can be one of the following:
    
    *   `process_exit`: The nodeJs instance has exited.
        
    *   `message`: The nodeJs instance has sent a message*.*
        
*   `exit_code` number:  This field is only present if the value of the `reason` field value is `process_exit`. It will return the exit code from the Node.js® process, as described at [https://nodejs.org/api/process.html#process\_exit\_codes](https://nodejs.org/api/process.html#process_exit_codes).  The `exit_code` field is only defined from OS 8.2 onwards. Note that the Node.js script could also use these codes for its own purposes. 
    
*   `message` string: If the `reason` field value is `message`, this field returns the contents of the message.
    

## Example

The following event loop waits for a nodeJs event and reports the events:

```
while true
    ev = wait(0, gaa.mp)
    print "=== BS: Received event ";type(ev)
    if type(ev) = "roNodeJsEvent" then
        eventData = ev.GetData()
        if type(eventData) = "roAssociativeArray" and type(eventData.reason) = "roString" then
            if eventData.reason = "process_exit" then
                print "=== BS: Node.js instance exited with code " ; eventData.exit_code
            else if eventData.reason = "message" then
                print "=== BS: Received message "; eventData.message
                ' To use this: msgPort.PostBSMessage({text: "my message"});
            else
                print "======= UNHANDLED NODEJS EVENT ========="
                print eventData.reason
            endif
        else
            print "=== BS: Unknown eventData: "; type(eventData)
        endif
    endif
endwhile
```
----
developers\developers\brightscript\object-reference\presentation-and-widget-objects\rorectangle.md
# roRectangle

This object is passed to various video and graphics widgets (*roVideoPlayer*, *roImageWidget*, *roHtmlWidget*, etc.) to specify their size and positioning.

Object Creation: This object is created with coordinate and dimension parameters.

```
CreateObject("roRectangle", x As Integer, y As Integer, width As Integer, height As Integer)
```

`SetRectangle()` calls made by widget objects (e.g. *roImageWidget.SetRectangle()*) honor the view-mode or aspect-ratio conversion mode set by the user. If the user has set the video player for letterboxing, it will occur if the video does not fit in the new rectangle exactly.

### Rectangles with 4K Video Modes 

When the player is using a 4K video mode (e.g. 3840x2160x60p), rectangles still operate as if the total screen area is 1920x1080 (unless [full-resolution graphics](../presentation-and-widget-objects/rovideomode.md) is enabled). They are then scaled by a factor of 2 when the video is output. For example, to display a full-screen 4K video, set the *roRectangle* instance to `0,0,1920,1080`; to display an additional HD video in the top-right quadrant of the screen, set another *roRectangle* instance to `960,0,960,540`.

![](./attachments/4K%20Coordinates.png)

Note that, while 4K video is output at a 1:1 pixel ratio, graphics elements (*roImageWidget*, *roCanvasWidget*, etc.) are upscaled to match the size of the 4K video output. This occurs irrespective of the size of the original image and widget rectangle: For example, an image in a 960x540 rectangle will first be downscaled to 960x540, then upscaled to 1920x1080. If you want to display images without upscaling on 4K video modes, display them in a video window using the *roVideoPlayer.PlayStaticImage()* method (or enable [full-resolution graphics](../presentation-and-widget-objects/rovideomode.md)).

## ifRectangle

##### SetX(x As Integer) As Void

Specifies a new x coordinate for the rectangle

##### SetY(y As Integer) As Void

Specifies a new y coordinate for the rectangle

##### SetWidth(width As Integer) As Void

Specifies a new width value for the rectangle

##### SetHeight(height As Integer) As Void

Specifies a new height value for the rectangle

##### GetX() As Integer

Returns the x coordinate of the rectangle

##### GetY() As Integer

Returns the y coordinate of the rectangle

##### GetWidth() As Integer

Returns the width of the rectangle

##### GetHeight() As Integer

Returns the height of the rectangle
----
developers\developers\brightscript\object-reference\presentation-and-widget-objects\rostreamqueue.md
# roStreamQueue

This object allows you to play a list of video files seamlessly (i.e. without any blank frames or interrupts between one video and the next). You can link *roStreamQueue* to an *roVideoPlayer* instance for seamless video playback or to an *roMediaStreamer* instance for seamless video streaming. 

Object Creation: This object is created with no parameters.

```
CreateObject("roStreamQueue")
```

## File Requirements

Video files must meet the following requirements to work with the *roStreamQueue* object:

*   Files must be Transport Stream (*.ts*) formatted.
    
*   All files in a queue should have identical PIDs.
    
*   Files must begin and end with a closed GOP.
    
*   Files must have regular PCRs at intervals of 100ms or shorter. Note that the default interval for FFMPEG is 1000ms unless it is configured for CBR muxing (in which case the interval is set to 20ms). The following is an example of an appropriate command-line tp remux:
    

```
avconv -i clip_short.ts -vcodec copy -acodec copy -muxrate 15M clip_short2.ts
```

## ifStreamQueue

##### QueueFile(filename As String) As Boolean

Adds the specified video file to the queue.

##### Loop(loop As Boolean) As Boolean

Specifies that playback/streaming should return to the beginning of the queue once it reaches the end. If `Loop(false)` and `LoopLast(false)` are both called, playback/streaming will stop once the end of the queue is reached. This is also the default behavior.

##### LoopLast(loop\_last As Boolean) As Boolean

Specifies that playback/streaming should loop the last file in the queue once it reaches the end. This method has no effect if `Loop(true)` is called as well.

##### SetPreferredAudio(description As String) As Boolean

Chooses a video stream from the video input based on the [parameters](http://docs.brightsign.biz/display/DOC/roVideoPlayer#roVideoPlayer-preferred_streams) in the passed string.

##### SetPreferredVideo(description As String) As Boolean

Chooses an audio stream from the video input based on the [parameters](http://docs.brightsign.biz/display/DOC/roVideoPlayer#roVideoPlayer-preferred_streams) in the passed string.

##### KeepPadding(enabled As Boolean)

If `enabled=true`, all PIDs in the input stream (including padding packets) are passed through to the output. This allows the CBR bitstream profile to be preserved when re-streaming to the network. It cannot be used when feeding a local decoder.

##### NextFile(a As Boolean) As Boolean  
 

##### Start() As Boolean

## ifMessagePort

##### SetPort(port As roMessagePort)

Posts messages of type *roStreamQueueEvent* to the attached message port. An event is raised whenever the end of the queue is reached.

## ifUserData

##### SetUserData(user\_data As Object)

Sets the user data that will be returned when events are raised.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()`. It will return Invalid if no data has been set.

## ifIdentity

##### GetIdentity() As Integer

Returns a unique number that can be used to identify when events originate from this object.

> [!NOTE]
> The *ifIdentity* interface has been deprecated. We recommend using the *ifUserData* interface instead.

## Playing and Streaming Queues

To use *roStreamQueue* as a streaming playlist, include it as the source component in an *roMediaStreamer.SetPipeline()* call. For video playback, use an *roVideoPlayer* instance as the destination component in the `SetPipeline()` call.

##### **Example (roVideoPlayer)**

```
q=createobject("rostreamqueue")
q.queuefile("sd:/Test_Count_Up_Blue_Frames.ts")
q.queuefile("sd:/Test_Count_Up_Green_Frames.ts")
q.loop(true)
c=createobject("romediastreamer")
r=createobject("rorectangle",0,0,1920,1080)
v=createobject("rovideoplayer")
v.setrectangle(r)
c.setpipeline([q, v])
c.start()
```

##### **Example (roMediaStreamer)**

```
queue = CreateObject("roStreamQueue")
queue.queueFile("file1.ts")
queue.queueFile("file2.ts")
queue.loop(true)
m = CreateObject("roMediaStreamer")
m.setpipeline([queue, "udp://239.0.156.101:5000/?maxbitrate=0"])
m.Start()
```

> [!CAUTION]
> **Important**
> We strongly suggest appending the "maxbitrate=0" parameter to UDP streams when using *roStreamQueue.* This prevents the *roMediaStreamer* instance from rate-limiting an *roStreamQueue* stream that is already running at a precise, correct rate.
----
developers\developers\brightscript\object-reference\presentation-and-widget-objects\rostreamqueueevent.md
# roStreamQueueEvent

This event object is generated by an *roStreamQueue* object when the end of the queue is reached.

## ifUserData

##### SetUserData(user\_data As Object) As Void

Sets the user data.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()` (on either the event or source object). It will return Invalid if no data has been set.

## ifStreamQueueEvent

##### GetData() As Object

Returns an roAssociativeArray with two entries, `action` and `file`:

*   `action`  contains one of:
    
    *   `START:` indicates that playback of a queued file has been started
        
    *   `SKIP:` indicates that a file in the queue has been skipped
        
    *   `END:` indicates that a file has finished playing
        
*   `file` contains the name of the file whose state is returned in `action`.
----
developers\developers\brightscript\object-reference\presentation-and-widget-objects\rotextfield.md
# roTextField

A text field represents an area of the screen that can contain arbitrary text. This feature is intended for presenting diagnostic and usage information. Use the *roTextWidget* object to generate text for user interfaces and signage.

Object Creation: The object is created with several parameters:

```
CreateObject("roTextField", xpos As Integer, ypos As Integer, width_in_chars As Integer, height_in_chars As Integer, metadata As Object)
```

*   `xpos`: The horizontal coordinate for the top left of the text field.
    
*   `ypos`: The vertical coordinate for the top left of the text field. The top of the screen is equivalent to zero.
    
*   `width_in_chars`: The width of the text field in character cells.
    
*   `height_in_chars`: The height of the text field in character cells.
    
*   `metadata`: An optional *roAssociativeArray* containing extra parameters for the text field. You can pass zero if you do not require this.
    

The metadata associative array supports the following extra parameters:

*   "CharWidth": The width of each character cell in pixels.
    
*   "CharLength": The height of each character cell in pixels.
    
*   "BackgroundColor": The background color of the text field as an integer specifying eight bits (for each) for red, green and blue in the form &Hrrggbb.
    
*   "TextColor": The color of the text as an integer specifying eight bits (for each) for red, green and blue in the form &Hrrggbb.
    
*   "Size": An alternative to "CharWidth" and "CharLength" for specifying either normal size text (0) or double-sized text (1).
    

> [!NOTE]
> In TV modes, a border around the screen may not be displayed due to overscanning. You may want to use the *roVideoMode* object functions `GetSafeX()` and `GetSafeY()` to ensure that the coordinates you use will be visible.

## ifTextField

##### Cls() As Void

Clears the text field.

##### GetWidth() As Integer

Returns the width of the text field

##### GetHeight() As Integer

Returns the height of the text field.

##### SetCursorPos(x As Integer, y As Integer) As Void

Moves the cursor to the specified position. Subsequent output will appear at this position.

##### GetValue() As Integer

Returns the value of the character currently under the cursor

##### Raise() As Void

Sends the widget to the top of the z-order on the graphics plane (i.e. in front of all other surfaces that implement the *ifWidget* interface). By default, new widgets are placed at the top of the graphics z-order.

> [!NOTE]
> Some surfaces are always drawn at the top of the graphics z-order, including the mouse cursor, closed captions, and [scrolling tickers](../presentation-and-widget-objects/rotextwidget.md).

> [!TIP]
> **Tip**
> You can use the `PauseGraphics()`/ `ResumeGraphics()` methods on the [*roVideoMode*](../presentation-and-widget-objects/rovideomode.md) object to ensure multiple changes to the graphics z-order occur simultaneously.

##### Lower() As Void

Sends the widget to the bottom of the z-order on the graphics plane (i.e. behind all other surfaces that implement the *ifWidget* interface). By default, new widgets are placed at the top of the graphics z-order.

## ifStreamSend

##### SendByte(byte As Integer) As Void

Writes the character indicated by the specified number at the current cursor position within the text field. It then advances the cursor.

##### SendLine(string As String) As Void

Writes the characters specified at the current cursor position followed by the end-of-line sequence.

##### SendBlock(string As Dynamic) As Void

Writes the characters specified at the current cursor position and advances the cursor to one position beyond the last character. This method can support either a string or an [*roByteArray*](#) . If the block is a string, any null bytes will terminate the block.

##### SetSendEol(string As String) As Void

Sets the sequence sent at the end of a SendLine() value. You should leave this at the default ASCII value of 13 (Carriage Return) for normal use. If you need to change this value to another non-printing character, use the `chr` [global function](../../object-reference/global-functions.md).

> [!NOTE]
> The ifStreamSend interface is also described in the section documenting the various file objects. The interface is described again here in a manner more specific to the roTextField object.

## Printing a Text Field 

As with any object that implements the *ifStreamSend* interface, a text field can be written to using the PRINT #textfield syntax. See the example below for more details.

It is also possible to write to a text field using the syntax PRINT #textfield, @pos, where *pos* is the character position in the *textfield*. For example, if your *textfield* object has 8 columns and 3 rows, writing to position 17 writes to row 3, column 2 (positions 0-7 are in row 1; positions 8-15 are in row 2; and positions 16-23 are in the last row).

When output reaches the bottom of the text field, it will automatically scroll.

##### **Example**

```
meta = CreateObject("roAssociativeArray")
meta.AddReplace("CharWidth", 20)
meta.AddReplace("CharLength", 32)
meta.AddReplace("BackgroundColor", &H101010) ' Dark grey
meta.AddReplace("TextColor", &Hffff00) ' Yellow
vm = CreateObject("roVideoMode")
tf = CreateObject("roTextField", vm.GetSafeX(), vm.GetSafeY(), 20, 20, meta)
print #tf, "Hello World"
tf.SetCursorPos(4, 10)
print #tf, "World Hello"
```
----
developers\developers\brightscript\object-reference\presentation-and-widget-objects\rotextwidget.md
# roTextWidget

This object is used to display text on the screen.

Note that "Scrolling ticker" mode is limited to 10 tickers at a time. You can have 100 roTextWidgets, so long as they are in some other mode (for example, "Static text")*.*

Object Creation: This object is created using one of two variants.

**Option 1**

```
CreateObject("roTextWidget", r As roRectangle, line_count As Integer, text_mode As Integer, pause_time As Integer)
```

*   `r` : An *roRectangle* instance that contains the text
    
*   `line_count`: The number of lines of text to show within the rectangle
    
*   `text_mode`: The animation characteristics of the text:
    
    *   0: An animated view similar to teletype
        
    *   1: Static text
        
    *   2: Simple text with no queue of strings
        
    *   3: Scrolling ticker (strings are separated with a diamond by default; the separator can be modified using the `SetSeparator()` method). Note that this option is not available for LSx22, HDx20, or HDx10 models. 
        
*   `pause_time`: The length of time each string is displayed before displaying the next string. This does not apply to text mode 2 or 3 because the strings on screen are updated immediately.
    

**Option 2**

```
CreateObject("roTextWidget", r As roRectangle, line_count As Integer, text_mode As Integer, parameters As roAssociativeArray)
```

*   `r`: An *roRectangle* instance that contains the text
    
*   `line_count`: The number of lines of text to show within the rectangle
    
*   `text_mode`: The animation characteristics of the text:
    
    *   0: An animated view similar to teletype
        
    *   1: Static text
        
    *   2: Simple text with no queue of strings
        
    *   3: Scrolling ticker (strings are separated with a diamond by default; the separator can be modified using the `SetSeparator()` method). Note that this option is not available for LSx22, HDx20, or HDx10 models.
        
*   `parameters`: An associative array that can include the following values:
    
    *   `LineCount`: The number of lines of text to show within the rectangle.
        
    *   `TextMode`: The animation characteristics of the text:
        
        *   0: An animated view similar to teletype
            
        *   1: Static text
            
        *   2: Simple text with no queue of strings
            
        *   3: Scrolling ticker (strings are separated with a diamond by default; the separator can be modified using the `SetSeparator()` method). Note that this option is not available for LSx22, HDx20, or HDx10 models.
            
    *   `PauseTime`: The length of time each string is displayed before displaying the next string. This does not apply to text mode 2 or 3 because the strings on screen are updated immediately.
        
    *   `Rotation`: The rotation of the text within the widget (note that the coordinates and dimensions of the rectangle itself are not rotated):
        
        *   0: 0 degrees
            
        *   1: 90 degrees. This value can also be represented in degrees (90) or radians (.5Π).
            
        *   2: 180 degrees. This value can also be represented in degrees (180) or radians (Π).
            
        *   3: 270 degrees. This value can also be represented in degrees (270) or radians (1.5Π).
            
*   `Alignment`: The alignment of the text:
    
    *   0: Left
        
    *   1: Center
        
    *   2: Right
        

> [!TIP]
> **Tip**
> Modes 0, 1, and 3 are useful for displaying RSS feeds and ticker-type text. However, for dynamic data where immediate screen updates are required, mode 2 may be more appropriate. Mode 2 allows text to be drawn immediately to the screen.

> [!NOTE]
> Text-mode 3 (scrolling ticker) supports both right-to-left and left-to-right (e.g. Arabic, Hebrew) scrolling modes, depending on the language of the first string or file added to the widget. To change the scrolling direction, you will first need to remove all strings from the ticker.

## ifTextWidget

##### SetGlobalParameter(param As String, value as Integer) As Void

Configures parameters related to scrolling tickers (i.e. text mode 3). The following are accepted parameters: 

*   `startat`: The starting position of scrolling text, which can be any number between 0 (the left side of the screen) and the total width of the widget. To start at the right side of the screen (i.e. offscreen), specify a value of -1 or the total width of the widget. 
    
*   `autopop`: The autopop setting for the widget. If this value is set to 1, strings are automatically removed (popped from the stack) once they have scrolled offscreen. If this value is set to 0 (the default behavior), strings are not automatically removed. 
    
*   `autoaddseparator`: The separator setting for the widget. Setting this value to 0 disables string separators (useful for displaying emojis with the `PushSurface()` method), while setting this value to 1 enables string separators (the default behavior). 
    
*   `gap`: The gap (in pixels) between the string and the string separator (at both the beginning and end of strings). The default value is 0. This parameter may not be reliable if the ticker contains strings in its memory. 
    

> [!NOTE]
> Global parameters can be altered after `Show()` is called, but in some cases (e.g. the `startat` parameter) their results are undefined. The parameters `autopop` and `autoaddseparator` are intended to be used once `Show()` has been called.

##### GetGlobalParameter(param as String) As Integer

Returns the value of a parameter set using the `SetGlobalParameter()` method. This method also returns a value for the read-only "`last_string_id`" parameter, which is a unique identifier for the string most recently added to the list-list value that is identical to the integer returned by the `PushString()` and `PushSurface()` methods. 

##### PushString(str As String) As Boolean

Adds the string to the list of elements to display in modes 0, 1, and 3. Strings are displayed in order, and when the end is reached, the object loops, returning to the beginning of the list. In mode 2, the string is displayed immediately. This method returns a unique identifier, which can be used with *roTextWidgetEvent* messages to determine when the string has moved offscreen. A failure to add an element to the list returns "0". 

> [!NOTE]
> Adding too many strings without popping them from the stack will cause PushString() to return False (the exact number depends on the font size for each string). The maximum recommended number of stored strings is 64.

##### PushSurface(image as roImageBuffer) As Integer

Adds a bitmap image to the list of elements to display in modes 0, 1, and 3. Images are scaled to match the height of the ticker. This method returns a unique identifier. which can be used with *roTextWidgetEvent* messages to determine when the image/surface has moved offscreen. A failure to add an element to the list returns "0". 

> [!NOTE]
> There are currently no restrictions on formatting, but it is recommended to use the same color format as the main screen.

##### PopStrings(number\_of\_string\_to\_pop As Integer) As Boolean

Pops elements off the front of the list (using "last in, first out" ordering) in modes 0, 1, and 3. This occurs the next time the widget wraps so that elements can be added to and removed from the widget seamlessly. In mode 2, the element is cleared from the widget immediately.

##### GetStringCount() As Integer

Returns the number of elements that will exist once any pending pops have taken place.

##### Clear() As Boolean

Clears the list of elements, leaving the widget blank and able to accept more `PushString()` calls.

##### SetStringSource(file\_path As String) As Boolean

Displays the text file at the specified path as a single, continuous string. This method is only applicable to text mode 3 (scrolling ticker). When the end of the file is reached, the text widget loops to the beginning, using a diamond symbol as the separator.

##### SetAnimationSpeed(speed As Integer) As Boolean

Sets the speed at which animated text displays. This method is applicable to text modes 0 and 3 only:

*   Mode 0: The default speed value is 10000. Setting an integer above this value decreases the speed of the teletype-style ticker: For example, specifying a value of 20000 will decrease the default speed at which text displays by half, while a value of 5000 will double the default speed.
    
*   Mode 3: The default speed value is 10000. Because the speed of a scrolling ticker is measured in pixels per second (PPS), the speed must be a multiple of the current framerate, or else it will be rounded down to the nearest multiple (for example, a framerate of 60p will honor PPS values of 60, 120, 180, etc.). The software determines the speed of the scrolling ticker by performing the following calculation on the passed `speed` parameter:  
    `PPS = (speed * 60) / 10000`
    

##### SetSeparator(separator As String) As Boolean

Changes the separator between strings. The default diamond separator will be replaced by the contents of the passed string. This method applies to Text Mode 3 (smooth scrolling ticker) only. The following strings indicate special symbols: ":diamond:", ":circle:", ":square:".

##### SetSyncManager(domain As String) As Boolean

Specifies a [*roSyncManager*](../../object-reference/networking-objects/rosyncmanager.md) domain to use when executing the `SetMultiscreen()` call. When this method is called, it creates an internal domain that is based on the existing *roSyncManager* domain and uses the same network parameters. We recommend using this method instead of passing a multicast IP address and port to the `SetMultiscreen()` method itself.

##### SetMultiscreen(offset As Integer, size As Integer, ip\_address As String, port As Integer) As Boolean

Displays a smooth scrolling ticker across multiple screens. To specify network synchronization parameters, you can either call the `SetSyncManager()` method first or pass the optional `ip_address` and `port` values to the `SetMultiscreen()` method (calling `SetSyncManager()` is preferred). If you use `SetSyncManager()`, do not specify the `ip_address`/`port`; doing so may lead to unexpected behavior.

The master screen is designated as the instance with the rightmost offset of all the players in the multiscreen array; all `PushString()` and `Show()` calls (as well as any other changes) must be made on the master instance. Follower instances of the text widget will remain blank until the leader starts. This method requires the following parameters:

*   `offset`: The offset (in pixels) of the display in the multiscreen array. For example, using an offset of 1920 in a two-screen array of 1920x1080 screens would specify this player as the right-hand (master) display.
    
*   `size`: The total width (in pixels) of the multiscreen array. For example, defining a size of 3840 would specify a two-screen array of 1920x1080 screens.
    
*   `ip_address`: A string specifying the multicast IP address for the [roSyncManager](../../object-reference/networking-objects/rosyncmanager.md) network traffic (e.g. "239.192.0.0")
    
*   `port`: A string specifying the multicast port for the PTP synchronization process (e.g. 1234).
    

> [!NOTE]
> Players can support more than one multiscreen ticker at a time.

## ifWidget

##### Show() As Boolean

Displays the widget. After creation, the widget is hidden until Show() is called.

##### Hide() As Boolean

Hides the widget.

##### Raise() As Void

Sends the widget to the top of the z-order on the graphics plane (i.e. in front of all other surfaces that implement the *ifWidget* interface). By default, new widgets are placed at the top of the graphics z-order.

> [!NOTE]
> Some surfaces are always drawn at the top of the graphics z-order, including the mouse cursor, closed captions, and scrolling tickers.

> [!TIP]
> **Tip**
> You can use the `PauseGraphics()`/ `ResumeGraphics()` methods on the [*roVideoMode*](../presentation-and-widget-objects/rovideomode.md) object to ensure multiple changes to the graphics z-order occur simultaneously.

##### Lower() As Void

Sends the widget to the bottom of the z-order on the graphics plane (i.e. behind all other surfaces that implement the *ifWidget* interface). By default, new widgets are placed at the top of the graphics z-order.

##### SetForegroundColor(color As Integer) As Boolean

Sets the foreground color in ARGB format. The top 8 bits are "alpha" parameters. Zero is equivalent to fully transparent and 255 to fully non-transparent.

> [!NOTE]
> Foreground alpha values are currently unsupported with ticker mode 3 (scrolling ticker) and will be ignored by this method. This behavior may change in future firmware versions.

Hex color values should be converted to integers before being passed to this method (e.g. the value `&hFFFFFFFF` should be passed as 4294967295). You can use the `HexToInteger()` method (available in the [core library extension](../../../brightscript/language-reference/core-library-extension.md)) to convert a hex string to an integer.

##### SetBackgroundColor(color As Integer) As Boolean

Sets the background color in ARGB format. The top 8 bits are "alpha" parameters. Zero is equivalent to fully transparent and 255 to fully non-transparent. This feature allows for effects similar to subtitles. For example, you can create a semi-transparent black box containing text over video.

Hex color values should be converted to integers before being passed to this method (e.g. the value `&hFFFFFFFF` should be passed as 4294967295). You can use the `HexToInteger()` method (available in the [core library extension](../../../brightscript/language-reference/core-library-extension.md)) to convert a hex string to an integer.

##### SetFont(font\_filename As String) As Boolean

Specifies a custom font for the widget using a TrueType font file from local storage (e.g. "SD:/ComicSans.ttf").

##### SetBackgroundBitmap(bitmap\_filename As String, stretch As Boolean) As Boolean

Sets the background bitmap image. If stretch is True, then the image is stretched to the size of the widget.

##### SetBackgroundBitmap(parameters As roAssociativeArray, stretch As Boolean) As Boolean

Sets the background bitmap image. If *stretch* is True, then the image is stretched to the size of the widget. The associative array can contain the following parameters:

*   `Filename`: The name of the image file
    
*   `EncryptionAlgorithm`: The file-encryption algorithm. Currently the options are "AesCtr" and "AesCtrHmac".
    
*   `EncryptionKey`: The key to decrypt the image file. This is a byte array consisting of 128 bits of key, followed by 128 bits of IV.
    

> [!NOTE]
> See the [Image Decryption](../presentation-and-widget-objects/roimageplayer.md) section in the *roImagePlayer* entry for details on displaying encrypted images.

##### SetSafeTextRegion(region As roRectangle) As Boolean

Specifies the rectangle within the widget where the text can be drawn safely.

##### SetRectangle(r As roRectangle) As Boolean

Changes the size and positioning of the widget rectangle using the passed *roRectangle* object.

##### GetFailureReason() As String

Yields additional useful information if a function return indicates an error.
----
developers\developers\brightscript\object-reference\presentation-and-widget-objects\rotextwidgetevent.md
# roTextWidgetEvent

This event object is generated when a string or surface leaves the screen area of an *roTextWidget* instance.

## ifWidgetEvent

##### GetStringId() As Integer

Returns the ID of the string or surface that has disappeared from the screen.

## ifUserData

##### SetUserData(user\_data As Object) As Void

Sets the user data.

##### GetUserData() As Objecta

Returns the user data that has previously been set via `SetUserData()` (on either the event or source object). It will return Invalid if no data has been set.
----
developers\developers\brightscript\object-reference\presentation-and-widget-objects\rotouchevent-rotouchcalibrationevent.md
# roTouchEvent, roTouchCalibrationEvent

The *roTouchEvent* object is generated by the *roTouchScreen* object whenever a touch or mouse event is detected within a defined region. The JavaScript equivalent is `TouchEvent()`.

## ifInt

##### GetInt() As Integer

Retrieves the region ID of the event.

##### SetInt(a As Integer)

Sets the region ID of the event.

## ifPoint

The *ifPoint* interface is not available on the *roTouchCalibrationEvent* object.

##### GetX() As Integer

Retrieves the x coordinate of the mouse/touch event.

##### GetY() As Integer

Retrieves the y coordinate of the mouse/touch event.

##### SetX(a As Integer)

Sets the x coordinate of the event.

##### SetY(a As Integer)

Sets the y coordinate of the event.

## ifEvent

The *ifEvent* interface is not available on the *roTouchCalibrationEvent* object.

##### GetEvent() As Integer  
 

##### SetEvent(a As Integer)
----
developers\developers\brightscript\object-reference\presentation-and-widget-objects\rotouchscreen.md
# roTouchScreen

This object accepts inputs from touchscreen panels or mice. For each recognized input, the object will generate an *roTouchEvent* object. See the "roTouchScreen" section of the [BrightScript-JavaScript Migration Guide](../../../../developers/player-apis/brightscript-javascript-migration-guide.md) for the equivalent methods in JavaScript.

Not all touchscreens are supported. Please see [this page](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/2320728065/Supported+Touchscreens) for a full list of supported touchscreens. The *roTouchScreen* object responds to the clicks of a USB mouse in the same way it responds to touch events on a touchscreen.

To set up touchscreen/mouse interactivity, follow this outline:

1.  Create an *roTouchScreen* instance.
    
2.  Use `SetPort()` to specify an *roMessagePort* instance to receive the *roTouchScreen* events.
    
3.  Define one or more touch regions.
    
    1.  A touch region may be rectangular or circular.
        
    2.  When a touch or click occurs anywhere inside the area of a touch region, an event will be sent to the message port.
        
    3.  If touch regions overlap such that a click or touch hits multiple regions, an event for each affected region will be sent.
        
4.  Process the events.
    

The *roTouchScreen* object supports rollover regions. Rollovers are based around touch regions. When a rectangular or circular region is added, it defaults to having no rollover. You can use the `EnableRollover()` method to add an *on* and *off* image for a region. Whenever the mouse cursor is within that region, the *on* image is displayed. In all other cases, the *off* image is displayed. This allows buttons to be highlighted as the mouse cursor moves over them.

## ifTouchScreen

##### SetResolution(x As Integer, y As Integer) As Void  
 

##### AddRectangleRegion(x As Integer, y As Integer, w As Integer, h As Integer, region\_id As Integer) As Void

Adds a rectangular touch region to the screen. The region\_id is used to associate the touch region with *roTouchEvent* events and to link the region with rollover images.

##### AddCircleRegion(x As Integer, y As Integer, radius As Integer, region\_id As Integer) As Void

Adds a circular touch region to the screen. The `region_id` is used to associate the touch region with *roTouchEvent* events and to link the region with rollover images.

##### ClearRegions() As Void

Clears the list of regions added using `AddRectangleRegion()` or `AddCircleRegion()` so that any contacts in those regions no longer generate events. This call has no effect on the rollover graphics.

##### GetDeviceName() As String  
 

##### SetCursorPosition(x As Integer, y As Integer) As Void  
 

##### SetCursorBitmap(filename As String, x As Integer, y As Integer) As Void 

Specifies a BMP or PNG file as the mouse cursor icon. This method also accepts a "hot spot" (i.e. the point within the icon rectangle that will trigger events when the mouse is clicked) as a set of **x,y** coordinates. The icon can be a rectangle of any width or height.

##### EnableCursor(enable As Boolean) As Void

Displays a cursor on screen if passed True.

##### EnableRollover(region\_id As Integer, on\_image As String, off\_image As String, cache\_image As Boolean, image\_player As Object) As Void

Enables a rollover for a touch region. This method accepts the ID of the touch region, as well as two strings specifying the names of the *on* and *off* bitmap images, a cache setting, and the image player that draws the rollover. The `cache_image` parameter simply tells the script whether to keep the bitmaps loaded in memory or not. This setting uses up memory very quickly, so we recommend that `cache_image` normally be set to 0.

##### SetRollOverOrigin(region\_id As Integer, x As Integer, y As Integer) As Void

Changes the origin so that more (or less) of the screen changes when the mouse rolls in and out of the region. This means that bitmaps that are larger than the region can be drawn. The default requirement is that rollover bitmaps be the same size and position as the touch region. Note that the bitmap is square for circular regions. The default origin for circular regions is \[x - r\]**,** \[y – r\], where x**,** y is the center of the circle, and r is the radius.

> [!CAUTION]
> **Important**
> The `EnableRollover()` and `SetRollOverOrigin()` methods have been deprecated. As of OS8, the end points exist but do not perform any function.

##### EnableRegion(region\_id As Integer, enabled As Boolean) As Void

Enables or disables a rollover region. This method accepts the ID of the touch region, as well as a Boolean value (True or False). The rollover regions default to "enabled" when created, but you can set up all of the regions at the start of your script and then enable regions as required.

##### IsMousePresent() As Boolean

Returns True if a relative pointing device is attached to the player. This does not work for absolute devices like touchscreens.

##### SetMouseRotation(rotation As Integer) As Boolean

Transforms mouse-movement inputs to account for screen rotation. This method can accept the following integers:

*   0: Inputs are unchanged (i.e. landscape orientation).
    
*   1, 90: Rotated 90 degrees (i.e. clockwise portrait orientation).
    
*   2, 180: Rotated 180 degrees.
    
*   3, 270: Rotated 270 degrees (i.e. counter-clockwise portrait orientation).
    

##### EnableSerialTouchscreen(a As Integer) As Boolean  
 

##### SetSerialTouchscreenConfiguration(a As String) As Boolean

##### GetDiagnosticInfo() As String

Returns an HTML string with captured information describing hardware that was connected and events that occurred during the calibration process. This method is used by the calibration script to diagnose touchscreen issues.

## ifSetMessagePort

##### SetPort(port As roMessagePort)

Posts messages of type *roTouchEvent* and *roTouchCalibrationEvent* to the attached message port.

## ifTouchScreenCalibration

##### StartCalibration() As Boolean  
 

##### GetCalibrationStatus() As Integer  
 

##### GetDiagnosticInfo() As String  
 

##### ClearStoredCalibration() As Boolean  
 

##### StartEventLogging() As Boolean  
 

##### StopEventLogging() As Boolean  
 

##### ClearEventLogs() As Boolean

##### SetCalibrationRanges(x-min As Integer, x-max As Integer, y-min As Integer, y-max As Integer) As Boolean

Overrides the screen range values provided by the touchscreen. This method is useful when the entirety of the video output is not being displayed on the touch surface. Practical use of this method usually requires a custom calibration script, appropriate images, and a calibration setting matched to a particular setup.

## ifSerialControl

##### SetBaudRate(baud\_rate As Integer) As Boolean

Sets the baud rate of the device. The supported baud rates are as follows: 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400, 4800, 9600, 19200, 38400, 57600, 115200, 230400.

##### NotUsed1(a As String)  
 

##### SetMode(a As String) As Boolean  
 

##### NotUsed2(a As Boolean) As Boolean

## Examples

This script loops a video and waits for a mouse click or touchscreen input. It outputs the coordinates of the click or touch to the shell if it is located within the defined region.

```
v=CreateObject("roVideoPlayer")
t=CreateObject("roTouchScreen")
p=CreateObject("roMessagePort")

v.SetPort(p)
t.SetPort(p)
v.SetLoopMode(True)
v.PlayFile("testclip.mp2v")

t.AddRectangleRegion(0,0,100,100,2)

loop:
    msg=Wait(0, p)
    print "type: ";type(msg)
    print "msg=";msg
    if type(msg)="roTouchEvent" then
        print "x,y=";msg.GetX();msg.GetY()
    endif
    goto loop:
```

This script includes mouse support:

```
t=CreateObject("roTouchScreen")
t.SetPort(p)
REM Puts up a cursor if a mouse is attached
REM The cursor must be a 16 x 16 BMP
REM The x,y position is the "hot spot" point
t.SetCursorBitmap("cursor.bmp", 16, 16)
t.SetResolution(1024, 768)
t.SetCursorPosition(512, 389)
REM
REM Pass enable cursor display:  TRUE for on, and FALSE for off
REM The cursor will only enable if there is a mouse attached
REM
t.EnableCursor(true)
```

This script includes a rollover region and mouse support:

```
img=CreateObject("roImagePlayer")
t=CreateObject("roTouchScreen")
p=CreateObject("roMessagePort")
t.SetPort(p)


t.SetCursorBitmap("cursor.bmp", 16, 16)
t.SetResolution(1024, 768)
t.SetCursorPosition(512, 389)
t.EnableCursor(true)


img.DisplayFile("\menu.bmp")


REM Adds a rectangular touch region
REM Enables rollover support for that region
REM Sets the rollover origin to the same position as the touch region REM
t.AddRectangleRegion(0, 0, 100, 100, 1)
t.EnableRollOver(1, "on.bmp", "off.bmp", true, img)
t.SetRollOverOrigin(1, 0, 0)
```

#####
----
developers\developers\brightscript\object-reference\presentation-and-widget-objects\rovideoevent-roaudioevent.md
# roVideoEvent, roAudioEvent

Video and audio events are declared as separate classes. Events can have one of the following values, which are retrieved using the `GetInt()` method:

|     |     |     |
| --- | --- | --- |
| 3   | `Playing` | The current media item has started playing. |
| 8   | `MediaEnded` | The media item has completed playback. |
| 12  | `TimeHit` | A particular timecode has been reached. See the entry on [Timecode Events](../presentation-and-widget-objects/rovideoplayer.md) for more details. |
| 13  | `Overlay_Playing` | An *roAudioPlayerMx* instance has begun playback of an audio file. |
| 14  | `Overlay_MediaEnded` | An *roAudioPlayerMx* instance has completed playback of an audio file. |
| 15  | `Overlay_TimeHit` | The EventTimeStamp of an *roAudioPlayerMx* instance has been been reached. |
| 16  | `MediaError` | A media error has been detected. As opposed to code 30, this event usually indicates transient errors (e.g. low buffer levels). |
| 17  | `Overlay_MediaError` | A media error has been detected during *roAudioPlayerMx* playback. |
| 18  | `FadingOut` | The current media item has completed fading out. See the *roVideoPlayer.SetFade()* entry for more details. |
| 19  | `DecoderEOS` |     |
| 20  | `Overlay_FadingOut` | The FadeOutLocation of an *roAudioPlayerMx* instance has been reached. |
| 21  | `Overlay_DecoderEOS` |     |
| 26  | `Underflow` | The stream seems to be underflowing. This event usually indicates that the streaming latency is set too low. It will be generated every few seconds as long as underflow is detected. |
| 30  | `MediaError_NotStarted` | A fatal error has been encountered while attempting to start playback (e.g. the video format is not supported). |
|     | `ResourceShortage` | You are trying to play more video simultaneously than is allowed. If you are playing a single video by creating new video tags, reuse the existing video tag when possible to avoid race conditions when a video tag might hold onto a hardware video resource or take too long to disassociate a video player from the video tag. |

  

> [!NOTE]
> The [Diagnostic Web Server](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370673541/Diagnostic+Web+Server#DiagnosticWebServer-log) [log](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370673541/Diagnostic+Web+Server#DiagnosticWebServer-log) may return more specific information about media error states.

## ifInt

##### GetInt() As Integer

Returns the event ID as an integer value. 

##### SetInt(value As Integer) As Void

Sets the integer value. 

## ifUserData

##### SetUserData(user\_data As Object) As Void

Sets the user data.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()` (on either the event or source object). It will return Invalid if no data has been set.

## ifSourceIdentity

##### GetSourceIdentity() As Integer  
 

##### SetSourceIdentity() As Integer 

> [!NOTE]
> The *ifSourceIdentity* interface has been deprecated. We recommend using the *ifUserData* interface instead.

## ifData    

##### GetData() As Integer

##### SetData(a As Integer) 

## Example

```
vp_msg_loop:
    msg=Wait(tiut, p)    
    if type(msg)="roVideoEvent" then
        if debug then print "Video Event";msg.GetInt()
        if msg.GetInt() = 8 then
            if debug then print "VideoFinished"
            retcode=5
            return
        endif
    else if type(msg)="roGpioButton" then
        if debug then print "Button Press";msg
        if escm and msg=BM then retcode=1:return
        if esc1 and msg=B1 then retcode=2:return
        if esc2 and msg=B2 then retcode=3:return
        if esc3 and msg=B3 then retcode=4:return
    else if type(msg)="rotINT32" then
        if debug then print "TimeOut"
        retcode=6
        return
    endif

    goto vp_msg_loop
```
----
developers\developers\brightscript\object-reference\presentation-and-widget-objects\rovideoinput.md
# roVideoInput

This object allows playback of HDMI**®** input or video provided by a video capture dongle. Note that the *ifVideoInput* methods do not apply to HDMI input, which can be achieved by passing an unmodified *roVideoInput* instance to the *roVideoPlayer.PlayFile()* method (see below for examples). The JavaScript equivalent is `MediaDevices.getUserMedia()`.

Object Creation: *roVideoInput* is created with no parameters:

```
CreateObject("roVideoInput")
```

## ifVideoInput

##### GetStandards() As roArray

##### GetInputs() As roArray

These return an array of strings describing the various inputs and video standards that the video capture device supports. The following are the possible standards that can be returned: PAL-D/K, PAL-G, PAL-H, PAL-I, PAL-D, PAL-D1, PAL-K, PAL-M, PAL-N, PAL-Nc, PAL-60, SECAM-B/G, ECAM-B, SECAM-D, SECAM-G, SECAM-H, SECAM-K, SECAM-K1, SECAM-L, SECAM-LC, SECAM-D/K, NTSC-M, NTSC-Mj, NTSC-443, NTSC-Mk, PAL-B and PAL-B1. Inputs returned are s-video and composite.

##### SetStandard(standard As String) As Boolean  
 

##### GetCurrentStandard() As String  
 

##### SetInput(input As String) As Boolean  
 

##### GetCurrentInput() As String

Use the above to get and set the input and video standard.

##### GetControls() As roArray

Returns the possible controls on the input. These include "Brightness," "Contrast," "Saturation," "Hue," and others.

##### SetControlValue(control\_name As String, value As Integer) As Boolean

Sets the value of the specified control.

##### GetCurrentControlValue(control\_name As String) As roAssociativeArray

Returns an associative array with 3 members: "Value," "Minimum," and "Maximum." "Value" is the current value, and the possible range is specified by "Minimum" and "Maximum."

##### GetFormats() As Object  
 

##### SetFormat(a As String, b As Integer, c As Integer) As Boolean  
 

##### GetCurrentFormat() As String

## Examples

This script uses the HDMI Input as the video source to create a full-screen display.

```
v = CreateObject("roVideoPlayer")
i = CreateObject("roVideoInput")
p = CreateObject("roMessagePort")


vm = CreateObject("roVideoMode")
vm.SetMode("1920x1080x60p")


r = CreateObject("roRectangle", 0, 0, 1920, 1080)
v.SetRectangle(r)


v.PlayFile(i)
```

This script uses the video capture dongle as the video source to create a full-screen display.

```
v=CreateObject("roVideoPlayer")
i=CreateObject("roVideoInput")
p=CreateObject("roMessagePort")


vm=CreateObject("roVideoMode")
vm.SetMode("1280x720x60p")


r = CreateObject("roRectangle", 0, 0, 1280, 720)
v.SetRectangle(r)


i.SetInput("s-video")
i.SetStandard("ntsc-m")


v.PlayFile(i) 
```

#####
----
developers\developers\brightscript\object-reference\presentation-and-widget-objects.md
# Presentation and Widget Objects

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

This section describes objects that relate directly to audio/video playback on BrightSign players.

*   [roAudioConfiguration](./presentation-and-widget-objects/roaudioconfiguration.md)
*   [roAudioEventMx](./presentation-and-widget-objects/roaudioeventmx.md)
*   [roAudioOutput](./presentation-and-widget-objects/roaudiooutput.md)
*   [roAudioPlayer](./presentation-and-widget-objects/roaudioplayer.md)
*   [roAudioPlayerMx](./presentation-and-widget-objects/roaudioplayermx.md)
*   [roCanvasWidget](./presentation-and-widget-objects/rocanvaswidget.md)
*   [roClockWidget](./presentation-and-widget-objects/roclockwidget.md)
*   [roHdmiInputChanged, roHdmiOutputChanged](./presentation-and-widget-objects/rohdmiinputchanged-rohdmioutputchanged.md)
*   [roHtmlWidget](./presentation-and-widget-objects/rohtmlwidget.md)
*   [roHtmlWidgetEvent](./presentation-and-widget-objects/rohtmlwidgetevent.md)
*   [roImageBuffer](./presentation-and-widget-objects/roimagebuffer.md)
*   [roImagePlayer](./presentation-and-widget-objects/roimageplayer.md)
*   [roImageWidget](./presentation-and-widget-objects/roimagewidget.md)
*   [roNodeJs](./presentation-and-widget-objects/ronodejs.md)
*   [roNodeJsEvent](./presentation-and-widget-objects/ronodejsevent.md)
*   [roRectangle](./presentation-and-widget-objects/rorectangle.md)
*   [roStreamQueue](./presentation-and-widget-objects/rostreamqueue.md)
*   [roStreamQueueEvent](./presentation-and-widget-objects/rostreamqueueevent.md)
*   [roTextField](./presentation-and-widget-objects/rotextfield.md)
*   [roTextWidgetEvent](./presentation-and-widget-objects/rotextwidgetevent.md)
*   [roTextWidget](./presentation-and-widget-objects/rotextwidget.md)
*   [roTouchEvent, roTouchCalibrationEvent](./presentation-and-widget-objects/rotouchevent-rotouchcalibrationevent.md)
*   [roTouchScreen](./presentation-and-widget-objects/rotouchscreen.md)
*   [roVideoEvent, roAudioEvent](./presentation-and-widget-objects/rovideoevent-roaudioevent.md)
*   [roVideoInput](./presentation-and-widget-objects/rovideoinput.md)
*   [roVideoMode](./presentation-and-widget-objects/rovideomode.md)
*   [roVideoPlayer](./presentation-and-widget-objects/rovideoplayer.md)
----
developers\developers\brightscript\object-reference\system-objects\rodevicecustomization.md
# roDeviceCustomization

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

This object provides miscellaneous device configuration and customization methods.  

## ifFailureReason

##### GetFailureReason() As String

Returns helpful information if one of the *ifDeviceCustomization* methods fail.

## ifDeviceCustomization

##### WriteSplashScreen(filename As String) As Boolean

Removes the default splash screen (or a previously set splash screen) and replaces it with the specified image file. The image file must use a [supported format](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/2307784705/Supported+Image+Formats). This method returns `True` on success and `False` on failure.

##### EnumerateExtensions() As Array

Returns an array of the extensions that are installed on a player.

##### FactoryReset(confirm As String) As Boolean

Applies a factory reset to the player. This method must be passed the string "confirm" to work; otherwise, it will return False and do nothing. If successful, this method will reboot without a return value. The following steps will be carried out during a factory reset:

1.  All files are wiped from the `BOOT:` drive (including custom splash screens and autorun scripts).
    
2.  All values are wiped from the registry.
    
3.  The RTC is reset (if the player has an RTC).
    
4.  The `FLASH:` drive is wiped.
    

##### ConfigureAsUsbGadget(roBool gadget)

This method allows the USB OTG (On The Go) port on the AU335 to be dynamically configured to *host* or *gadget* mode. In the *host* role, the USB port follows standard behavior (it allows USB devices to be plugged into it). In the *gadget* role, the player can behave as a USB device (for example, roUsbFilesystem). This method will return false on platforms other than the AU335. 

This script switches to *gadget* role and presents *sd:/test.img* as a filesystem to a connected USB host:

```
dc=CreateObject("roDeviceCustomization")
dc.ConfigureAsUsbGadget(1)

fs = CreateObject("roUsbFilesystem")
fs.Enable({filename: "SD:test.img"})
```

If `ConfigureAsUsbGadget(1)` isn't called on an AU335, then the USB will only run in *host* mode, regardless of what is connected. 

Note that on all BrightSign players other than AU335, the USB port doesn't need any configuration to work in USB OTG mode. The USB stack switches automatically between *host* and *gadget* depending on what is connected to the port. 

##### EncryptStorage(device As String, params As roAssociativeArray) As Boolean

Encrypts the contents of a storage device using an encryption key stored in the private section of the player registry. This prevents other devices from reading the names or contents of files on the storage device (though file metadata will still be readable). The storage device can still be mounted on other devices, which can list, delete, and copy files (even though they cannot read them).

Use the `device` parameter to specify which storage drive to encrypt (see [here](../../object-reference/hashing-and-storage-objects/rostorageinfo.md) for a list of valid drive names). Encryption parameters are passed as an associative array, which can contain the following:

*   `method As String`:(Required) The encryption method, which can be one of the following:
    
    *   `"none"`: Encryption is disabled and any encryption keys for the storage device are deleted from the registry. 
        
    *   `"passphrase"`: The storage device is encrypted using an un-obfuscated passphrase.
        
    *   `"obfuscated_passphrase"`: The storage device is encrypted using an obfuscated passphrase. Contact *support@brightsign.biz* to learn more about generating a key for obfuscation and storing it on the player. 
        
    *   `"brightsign_key"`: The storage device is encrypted using an encryption key that is common to all BrightSign players, but is not shared with outside parties. 
        
    *   `"generate_key"`: The storage device is encrypted using an encryption key that is generated on-demand using a secure random generator. The private registry of the player contains the only copy of the key; if the value in the registry is erased or becomes corrupted, there will be no way to recover data from that storage device.
        
        *   Note that the private registry does not distinguish between different physical volumes of the same drive. For example, if you encrypt two SD cards, the key for the first SD card will be overwritten when the second SD card is encrypted; in the case of a randomly generated key, the data from the first SD card will be irretrievable.
            
    *   `passphrase As String`: The passphrase for encrypting the storage device. This parameter must be included if the method is specified as `"passphrase"` or `"obfuscated_passphrase"`. 
        
    *   `format As Boolean`: Setting this parameter to `true` will cause the specified storage device to be reformatted–all existing files will be deleted (but are not guaranteed to be securely erased) before the device is encrypted; however, if the device cannot be reformatted, the operation will fail. If this parameter is set to `false`, the storage device will be mounted as if it has been previously encrypted using the supplied key.
        
        *   If the storage device hasn't been previously encrypted, it will be encrypted while leaving any preexisting files unencrypted. If the storage device has been encrypted using a different key, the operation will fail.
            
        *   If the `format` parameter is not specified, the storage device will be mounted as if it has been previously encrypted using the supplied key. If the storage device hasn't been previously encrypted, the operation will fail.
----
developers\developers\brightscript\object-reference\system-objects\rodeviceinfo.md
# roDeviceInfo

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

This object provides information about the device hardware, firmware, and features. The JavaScript equivalent is [deviceinfo](../../../../developers/player-apis/javascript-apis/deviceinfo.md) .

## ifDeviceInfo

##### GetModel() As String

Returns the model name for the BrightSign device running the script as a string (for example, "HD1020" or "XD230").

##### GetVersion() As String

Returns the version number of BrightSign firmware running on the device (for example, "4.0.13").

##### GetVersionNumber() As Integer

Returns the three most significant version numbers of the BrightSign firmware running on the device in comparable numeric form: `major*65536 + minor*256 + build`

> [!CAUTION]
> **Important**
> The return value for the `GetVersionNumber()` method does not include any additional version numbers after the first three: For example, firmware version 4.0.13.4 will be returned as 262157 (as if it were "4.0.13"). For this reason, we recommend using the `GetVersion()` or `FirmwareIsAtLeast()` methods to determine the current firmware version.

##### FirmwareIsAtLeast(version As String) As Boolean

Returns True if the BrightSign firmware version on the device is greater than or equal to the version number represented by the passed string (e.g. "4.0.13").

##### GetBootVersion() As String

Returns the version number of the BrightSign boot firmware, also known as "safe mode", as a string (for example, "1.0.4").

##### GetBootVersionNumber() As Integer

Returns the three most significant version numbers of the BrightSign boot firmware, also known as "safe mode," in comparable numeric form: `major*65536 + minor*256 + build.`

> [!CAUTION]
> **Important**
> The return value for the `GetBootVersionNumber()` method does not include any additional version numbers after the first three: For example, firmware version 1.0.4.1 will be returned as 65540 (as if it were "1.0.4"). For this reason, we recommend using the `GetBootVersion()` or `BootFirmwareIsAtLeast()` methods to determine the current boot firmware version.

##### BootFirmwareIsAtLeast(version As String) As Boolean

Returns True if the BrightSign boot firmware version on the device is greater than or equal to the version number represented by the passed string (e.g. "4.4.22").

##### GetTemperature() As roAssociativeArray

Returns an associative array containing a dynamic string location key and the temperature as a floating point value.

##### GetDeviceUptime() As Integer

Returns the number of seconds that the device has been running since the last power cycle or reboot.

##### GetDeviceLifetime() As Integer

##### GetLoadStatistics(parameters As roAssociativeArray) As String

Provides current performance information related to the Linux kernel. This method accepts an associative array with a single key/value pair formatted as `item:<parameter>`; it will then return a string containing information associated with that parameter. The following are recognized parameters:

*   "loadavg": Provides information about system performance. The first three columns measure CPU and I/O utilization over the past 1, 5, and 10 minutes, respectively. The fourth column displays the number of currently running processes and the total number of processes. The last column displays the ID of the most recently used process.
    
*   "meminfo": Displays physical and swap memory usage.
    
*   "slabinfo": Provides information about memory usage at the slab level.
    
*   "stat": Provides overall statistics about the system (e.g. the number of page faults since the system booted).
    
*   "vmstat": Displays detailed virtual memory statistics from the kernel.
    
*   "zoneinfo": Provides overall statistics about the system, broken down by system Node.
    
*   "interrupts": Displays which interrupts are in use and how many of each type there have been.
    
*   "version": Provides the kernel version.
    

Example:

```
stat = CreateObject("roDeviceInfo")
print stat.GetLoadStatistics({item:"interrupts"})
```

##### GetUSBTopology(return As roAssociativeArray) As Dynamic 

Returns the USB topology of the player, including the port enumeration, PID, and VID of each USB device. Use this method to determine whether certain USB devices are connected to certain ports. The passed associative array determines the return value:

*   `{}`: Returns the USB topology as a string list.
    
*   `{format: "xml"}`:  If `true`, returns the USB topology as an XML-formatted string.
    
*   `{format: "array"}`:  Returns an array of associative arrays. Each associative array contains information about a single USB port.
    
*   `rebuild`:  If `true`, ensures that the returned information is up to date with the current hardware status.
    

Updates information and returns it in XML format:

```
di = CreateObject("roDeviceInfo")
tp = di.GetUSBTopology({format: "xml", rebuild:true})
```

String list:

```
BrightScript Debugger> di = CreateObject("roDeviceInfo")
BrightScript Debugger> topo = di.GetUSBTopology({})
BrightScript Debugger> print topo
{
 "containers": [
  {
   "category": "HUB",
   "fid": "",
   "pid": 1552,
   "raw": "1-1",
   "type": "",
   "vid": 1507
  }
 ],
 "devices": [
  {
   "category": "HID",
   "fid": "B.0",
   "ident": "usb/hiddev0",
   "pid": 60931,
   "raw": "1-1.2:1.0",
   "type": "BP900",
   "vid": 2127
  }
...
```

XML string:

```
BrightScript Debugger> di = CreateObject("roDeviceInfo")
BrightScript Debugger> topo = di.GetUSBTopology({xml: true})
BrightScript Debugger> print topo
<topology>
	<device>
  		<raw>8-1:1.0</raw>
  		<fid>C.0</fid>
  		<category>HID</category>
  		<vid>084f</vid>
  		<pid>ee03</pid>
		<ident>usb/hiddev0</ident>
  		<type>BP900</type>
	</device>
	<devices raw="2-1.4" category="HUB" vid="05e3" pid="0610" >
   		<device>
    		<raw>2-1.4.1:1.0</raw>
    		<fid>A/4.0</fid>
    		<category>AUDIO</category>
    		<vid>05a7</vid>
    		<pid>40fa</pid>
   		</device>
   		<device>
    		<raw>2-1.4.1:1.2</raw>
    		<fid>A/4.2</fid>
    		<category>HID</category>
    		<vid>05a7</vid>
    		<pid>40fa</pid>
  		</device>
...
```

Array:

```
BrightScript Debugger> di = CreateObject("roDeviceInfo")
BrightScript Debugger> topo = di.GetUSBTopology({array: true})
BrightScript Debugger> print topo[0]
vid:  05a7
pid:  40fa
fid: A.0
category: AUDIO
raw: 2-1.4.1:1.0
ident: usb/hiddev0
```

Ports that have USB devices connected to them will include a `fid` (Friendly ID) value (only array and XML-string returns include this value). Use the `fid` to determine which physical port on the player the USB device is connected to. The following table matches `fid` values to the ports on different model lines:

| Model Family | Friendly ID (fid) | Location |
| --- | --- | --- |
| LS424/LS423 | A   | Front (USB-C) |
| HDx24/HDx23 | A   | Front (USB-A) |
| HS123 | A   | N/A (M.2 connector) |
| HO523 | A   | Upper Front (USB-A) |
|     | B   | Lower Front (USB-A) |
|     | C   | Back (JAE TX-25) |
| XDx33/XDx34 | A   | Front (USB-C) |
| B   | Back (USB-A) |
| XTx43/XTx44 | A   | Back (USB-A) |
| B   | Front (USB-C) |

A `fid` value of `<port>.<int>` (e.g. "B.0") indicates that the USB device is directly connected to the player, while a value of `<port>/<int>.<int>` (e.g. "A/4.2") indicates a device connected through a USB hub. The last integer specifies the endpoint: For example, if a USB device presents as both an HID and audio device, they will be listed as separate devices with different endpoint numbers. Also note that there can be more than one layer of port numbers if multiple USB hubs are connected together (e.g. "A/4.0.0").

##### GetDeviceUniqueId() As String

Returns an identifier that, if not an empty string, is unique to the unit running the script.

##### GetFamily() As String

Returns a single string that indicates the family to which the device belongs. A device family is a set of models that are all capable of running the same firmware.

##### HasFeature(feature As String) As Boolean

Returns True if the player feature, which is passed as a case-insensitive string parameter, is present on the current device and firmware. The possible features that can be queried from the script are listed below:

> [!CAUTION]
> **Important**
>  If you pass a parameter other than one of those listed below, it may return False even if the feature is available on the hardware and firmware.

*   `"5v serial"`: A 5V serial port
    
*   `"audio1"`: The first audio output
    
*   `"audio2"`: A second audio output
    
*   `"audio3"`: A third audio output
    
*   `"brightscript1"`: BrightScript Version 1
    
*   `"brightscript2"`: BrightScript Version 2
    
*   `"component video"`: A component video output
    
*   `"ethernet"`: An Ethernet interface
    
*   `"FindMemberFunction"`: The global function of that name is available for use. See the [GlobalFunctions](https://docs.brightsign.biz/display/DOC/Global+Functions) page for details.
    
*   `"gpio connector"`: A DA15 or Phoenix-style GPIO port 
    
*   `"hdmi"`: An HDMI® output
    
*   `"hdmi input"`: An HDMI input
    
*   `"hevc_decode"`: An H.265 video decoder
    
*   `"media_decryption"`: The ability to decrypt AES-encrypted media, including video, image, and audio files.
    
*   `"nand storage"`: NAND storage for the boot loader and firmware
    
*   `"networking"`: Any form of networking capability. A False return may indicate that no network is currently available.
    
*   `"reset button"`: A reset button
    
*   `"registry"`: On-board persistent storage
    
*   `"rtc"`: A real-time clock (RTC)
    
*   `"sd"`: SD- or SDHC-compatible storage
    
*   `"sdhc"`: SDHC-compatible storage only
    
*   `"serial port 0"`: The first serial port
    
*   `"serial port 1"`: A second serial port
    
*   `"serial port 2"`: A third serial port
    
*   `"svc button"`: A service ("SVC") button. Passing the legacy term `"gpio12 button"` will yield the same result.
    
*   `"usb"`: One or more USB interfaces
    
*   `"vga"`: A VGA output
    
*   `"video_encoder"`: A video encoder/transcoder
    

Example:

```
di = CreateObject("roDeviceInfo")
print di.GetModel()
print di.GetVersion(), di.GetVersionNumber()
print di.GetBootVersion(), di.GetBootVersionNumber()
print di.GetDeviceUptime(), di.GetDeviceBootCount()
```

On a particular system, this will generate the following:

```
HD1010
3.2.41           197161
3.2.28           197148
 14353           3129 
```
----
developers\developers\brightscript\object-reference\system-objects\roelectron.md
# roElectron

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

This BrightScript object launches an Electron instance from a BrightScript runtime. 

All BrightSign JavaScript objects are available to use with Electron, and BrightSign mechanisms allow communication between JavaScript (Electron main processes) and BrightScript (BrightSign processes).

> [!NOTE]
> This object is only available on Series 5 players.

## Object Creation

roElectron takes two parameters: a filename and an options parameter.

```
aa = CreateObject("roAssociativeArray")
aa.message_port = my_message_port
aa.arguments = CreateObject("roArray")
aa.arguments[0] = "arg1"
aa.arguments[1] = "arg2"
aa.node_arguments = CreateObject("roArray")
aa.node_arguments = {"node_arg1", "node_arg2")
aa.env_vars = CreateObject("roAssociativeArray")
aa.env_vars.AddReplace("ENV_VAR_1", "test")
aa.env_vars.AddReplace("ENV_VAR_2", "true")
node = CreateObject("roElectron", "path/to/my/application", aa)
```

*   `message_port` optional: A message port to bridge the Electron and BrightScript applications.
    
*   `arguments` optional: An roArray of arguments for Electron
    
*   `node_arguments` optional: An roArray of arguments for the Electron application itself to consume.
    
*   `env_vars` optional: An roAssociativeArray of environment variables for Electron application.
    

BrightScript associative arrays are case insensitive when object-literal syntax (for example, `aa={bright:"Sign"}`) is used. Environment variables are generally considered as case sensitive. Use the `AddReplace` method with an associative array, or call `SetModeCaseSensitive()` before assigning object-literal syntax variables into an env\_vars associative array.

## Methods

##### PostJSMessage(data as AssociativeArray) as Boolean

Posts a collection of key:value pairs to the BrightScript MessagePort JavaScript class. This method takes an associative array but it doesn't support nested associative arrays. See [JavaScript to BrightScript](https://docs.brightsign.biz/display/DOC/messageport) for more details.  

## Events

See [roElectronEvent](../system-objects/roelectronevent.md) for information about roElectron events.
----
developers\developers\brightscript\object-reference\system-objects\roelectronevent.md
# roElectronEvent

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

If an *roMessagePort* is attached to an *roElectron* object, it will receive *roElectronEvent* objects when something happens to the parent *roElectron* instance.

## ifUserData

##### SetUserData(user\_data As Object)

Sets the user data that will be returned when events are raised.

##### GetUserData() As Object

Returns the user data that has previously been set via `SetUserData()`. It will return `Invalid` if no data has been set.

## ifElectronEvent

##### GetData() As roAssociativeArray

Returns the event data as an associative array with the following key/value pairs:

*   `reason` string: The cause of the event, which can be one of the following:
    
    *   `process_exit`: The Electron instance has exited.
        
    *   `message`: The Electron instance has sent a message*.*
        

*   `exit_code` number:  The value of this field is set by the Electron application when it exits ([www.electronjs.org/docs/api/app#appexitexitcode](https://www.electronjs.org/docs/api/app#appexitexitcode)). The Electron process exit code is only defined in OS 8.2 and later OS versions. Note that the Electron script can also use these codes for its own purposes. 
    
*   `message` string: If the `reason` field value is `message`, this field returns the contents of the message.
    

## Example

The following event loop waits for an Electron event and reports the events:

```
while true
    ev = wait(0, gaa.mp)
    print "=== BS: Received event ";type(ev)
    if type(ev) = "roElectronEvent" then
        eventData = ev.GetData()
        if type(eventData) = "roAssociativeArray" and type(eventData.reason) = "roString" then
            if eventData.reason = "process_exit" then
                print "=== BS: Electron instance exited with code " ; eventData.exit_code
            else if eventData.reason = "message" then
                print "=== BS: Received message "; eventData.message
                ' To use this: msgPort.PostBSMessage({text: "my message"});
            else
                print "======= UNHANDLED ELECTRON EVENT ========="
                print eventData.reason
            endif
        else
            print "=== BS: Unknown eventData: "; type(eventData)
        endif
    endif
endwhile
```
----
developers\developers\brightscript\object-reference\system-objects\roresourcemanager.md
# roResourceManager

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

The *roResourceManager* object is used to manage strings in multiple languages.

Object creation: The *roResourceManager* object is created with a single filename parameter that specifies the name of the file that contains all of the localized resource strings required by the user. This file must be in UTF-8 format.

```
CreateObject("roResourceManager", filename As String)
```

## ifResourceManager

##### SetLanguage(language\_identifier As String) As Boolean

Instructs the *roResourceManager* object to use the specified language. False is returned if there are no resources associated with the specified language.

##### GetResource(resource\_identifier As String) As String

Returns the resource string in the current language for a given resource identifier.

##### GetFailureReason() As String

Yields additional useful information if a function return indicates an error.

##### GetLanguage() As String

## Usage

At present, *roResourceManager* is primarily used for localizing the *roClockWidget*. The resource file passed in during creation has the following format for each string entry:

```
[RESOURCE_IDENTIFIER_NAME_GOES_HERE]
eng "Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec"
ger "Jan|Feb|Mär|Apr|Mai|Jun|Jul|Aug|Sep|Okt|Nov|Dez"
spa "Ene|Feb|Mar|Abr|May|Jun|Jul|Ago|Sep|Oct|Nov|Dic"
fre "Jan|Fév|Mar|Avr|Mai|Jun|Jul|Aou|Sep|Oct|Nov|Déc"
ita "Gen|Feb|Mar|Apr|Mag|Giu|Lug|Ago|Set|Ott|Nov|Dic"
dut "Jan|Feb|Mar|Apr|Mei|Jun|Jul|Aug|Sep|Okt|Nov|Dec"
swe "Jan|Feb|Mar|Apr|Maj|Jun|Jul|Aug|Sep|Okt|Nov|Dec"
```

The name in square brackets is the resource identifier. Each line after it is a language identifier followed by the resource string. Multiple *roResourceManager* objects can be created. A default "resources.txt" file, which contains a range of internationalization values for the clock widget, is available on [this page](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/2015494148/Legacy+Product+Resources).
----
developers\developers\brightscript\object-reference\system-objects\rosystemlog.md
# roSystemLog

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

This object enables recording of the system log on a BrightSign player. Note that BrightScript `print` values are not written to the system log; use the *ifStreamSend* methods to write to the log instead.

Object Creation: This object is created with no parameters:

```
CreateObject("roSystemLog")
```

## ifSystemLog

##### ReadLog() As roArray

Returns an array of strings. The strings correspond to lines in the system log, spanning from bootup to the most recent entry.

##### ReadNextLine() As String

Reads the next line of the recorded system log.

## ifStreamSend

##### SetSendEol(eol\_sequence As String) As Void

Sets the EOL sequence when writing to the stream. The default value is CR+LF. If you need to set this value to a non-printing character, use the `chr()` [global function](../../object-reference/global-functions.md).

##### SendByte(byte As Integer) As Void

Writes the specified byte to the stream.

##### SendLine(string As String) As Void

Writes the specified characters to the stream followed by the current EOL sequence.

##### SendBlock(a As Dynamic) As Void

Writes the specified characters to the stream. This method can support either a string or an *roByteArray*. If the block is a string, any null bytes will terminate the block.

##### Flush() As Void

Writes the stream to the file, blocking execution until all data is written out.

## Writing to a Remote Syslog Server

BrightSign players can write to a remote syslog server using the standard syslog protocol (RFC 3164). To configure remote logging, write the "syslog" entry to the "networking" section of the [player registry](../../object-reference/hashing-and-storage-objects/roregistrysection.md):

##### **Example**

```
registry = CreateObject("roRegistrySection", "networking")
registry.Write("syslog", "my-syslog-server")
registry.Flush()
```

You can specify the syslog using either its IP address or hostname.
----
developers\developers\brightscript\object-reference\system-objects.md
# System Objects

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

This section describes objects that interact with system software.

*   [roDeviceCustomization](./system-objects/rodevicecustomization.md)
*   [roDeviceInfo](./system-objects/rodeviceinfo.md)
*   [roElectron](./system-objects/roelectron.md)
*   [roElectronEvent](./system-objects/roelectronevent.md)
*   [roResourceManager](./system-objects/roresourcemanager.md)
*   [roSystemLog](./system-objects/rosystemlog.md)
----
developers\developers\brightscript\object-reference.md
# Object Reference

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Table of Contents

*   [Interfaces and Methods](#interfaces-and-methods)
    *   [Example](#example)
*   [Classes](#classes)
    *   [Example](#example)
*   [Object and Class Name Syntax](#object-and-class-name-syntax)
*   [Zones](#zones)
*   [Event Loops](#event-loops)
    *   [Example](#example)

BrightSign players use a standardized library of BrightScript objects to expose functionality for software development. To publish a new API for interacting with BrightSign hardware, we create a new BrightScript object. 

The pages in this section provide definitions for objects that can be used in BrightScript. A brief description, a list of interfaces, and the member functions of the interfaces are provided for each object class. While most BrightScript objects have self-contained pages, some objects are grouped on the same page if they are closely related or depend on one another for functionality.

Here is a sample of objects that are used frequently when creating applications in BrightScript:

|     |     |
| --- | --- |
| [*roVideoMode*](./object-reference/presentation-and-widget-objects/rovideomode.md) | Configures video output and interacts with displays using CEC/EDID. |
| [*roRectangle*](./object-reference/presentation-and-widget-objects/rorectangle.md) | Used to define zones/widgets on the screen. This object is passed to many other objects to define their screen area, including *roVideoPlayer*, *roImagePlayer, roImageWidget*, *roHtmlWidget*, *roClockWidget*, and *roCanvasWidget.* |
| [*roVideoPlayer*](./object-reference/presentation-and-widget-objects/rovideoplayer.md) | Plays video files, streams, and HDMI® input. |
| [*roImagePlayer*](./object-reference/presentation-and-widget-objects/roimageplayer.md) | Displays images. |
| [*roHtmlWidget*](./object-reference/presentation-and-widget-objects/rohtmlwidget.md) | Displays local or remote HTML content using the Chromium rendering engine. |
| [*roNetworkConfiguration*](./object-reference/networking-objects/ronetworkconfiguration.md) | Used to configure Ethernet, WiFi, and local network parameters. |
| [*roDeviceInfo*](./object-reference/system-objects/rodeviceinfo.md) | Used to retrieve a wide array of system information, including model type, device serial number, and firmware version. |

## Interfaces and Methods

Every BrightScript object consists of one or more "interfaces." An interface consists of one or more "methods." For example, the *roVideoPlayer* object has several interfaces, including *ifMessagePort*. The interface *ifMessagePort* has one method: `SetPort()`. 

The abstract interface *ifMessagePort* is exposed and implemented by both the *roControlPort* and the *roVideoPlayer* objects. Once the SetPort() method is called, these objects will send their events to the supplied message port. This is discussed more in the Event Loops section below.

##### **Example**

```
p = CreateObject("roMessagePort")
video = CreateObject("roVideoPlayer") 
gpio = CreateObject("roControlPort", "BrightSign")
gpio.SetPort(p)
video.SetPort(p)  
```

The above syntax makes use of a shortcut provided by the language: The interface name is optional, unless it is needed to resolve name conflicts. For example, the following two lines of code carry out the exact same function:

```
gpio.SetPort(p)
gpio.ifMessagePort.SetPort(p)
```

BrightScript Objects consist *only* of interfaces, and interfaces define *only* methods. There is no concept of a "property" or variable at the object or interface level. These must be implemented as "set" or "get" methods in an interface.

## Classes

A *class name* is used to create a BrightScript object. For example, the class name for a video playback instance is *roVideoPlayer*, so, to initialize a video playback instance, you would use code similar to the following:

##### **Example**

```
video = CreateObject("roVideoPlayer")
```

Note that "video" can be any name that follows the syntax outlined in the next section.

## Object and Class Name Syntax

Class names have the following characteristics:

*   Must start with an alphabetic character (a – z).
    
*   May consist of alphabetic characters, numbers, or the "\_" (i.e. underscore) symbol.
    
*   Are not case sensitive.
    
*   May be of any reasonable length.
    

## Zones

With the BrightSign Zones feature, you can divide the screen into rectangles and play different content in each rectangle.

Depending on the BrightSign model, zones can contain video, images, HTML content, audio, a clock, or text. 4Kx42, XDx32, and XDx30 models can display two video zones on screen, while the HDx22, HDx20, and LSx22 models can only display one. There can be multiple zones of other types on the screen. A text zone can contain simple text strings or can be configured to display an RSS feed in a ticker-type display. 

As of firmware 6.0.x, zone support is enabled by default. When zones are enabled, the image layer is on top of the video layer by default. The default behavior can be modified using the*roVideoMode.SetGraphicsZOrder()* method. 

Zone support can be disabled by calling `EnableZoneSupport(false)`. When zones are not enabled, the image layer is hidden whenever video is played, and the video layer is hidden whenever images are played.

## Event Loops 

When writing anything more than a very simple script, an "event loop" will need to be created. Event loops typically have the following structure:

1.  Wait for an event.
    
2.  Process the event.
    
3.  Return to step 1.
    

An event can be any number occurrences: a button has been pressed; a timer has been triggered; a UDP message has been received; a video has finished playing back; etc. By convention, event scripting for BrightScript objects follows this work flow:

1.  An object of the type *roMessagePort* is created by the script.
    
2.  Objects that can send events (i.e. those that support the *ifMessagePort/ifSetMessagePort* interface) are instructed to send their events to this message port using the `SetPort()` method. You can set up multiple message ports and have each event go to its own message port, but it is usually simpler to create one message port and have all the events sent to this one port.
    
3.  The script waits for an event using the built-in `Wait()` statement (or the *ifMessagePort.WaitMessage()* method).
    
4.  If multiple object instances are assigned to the same message port, the script determines from which instance the event originated, then processes it. The script then jumps back to the `Wait()` statement.
    

##### **Example**

```
'Listens for UDP messages on two different ports and displays the image file requested in the UDP message body.
mp = CreateObject("roMessagePort")

udp1 = CreateObject("roDatagramReceiver", 3000)
udp1.SetPort(mp)
udp1.SetUserData("port 3000")
 
udp2 = CreateObject("roDatagramReceiver", 5000)
udp2.SetPort(mp)
udp2.SetUserData("port 5000")
 
r = CreateObject("rorectangle",0, 0, 1920, 1080)
img = CreateObject("roImagePlayer")
img.SetRectangle(r)

loop:
event = Wait(0, mp)
if type(event) = "roDatagramEvent"
	print "Image play command received on " + event.GetUserData() + "."
	img = DisplayFile("SD:/" + event.GetString())
	endif
endif
goto loop
```
----
developers\developers\brightscript.md
# BrightScript

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Version 9 and Older Versions

*   [Version 9 (OS 9)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual_ver9.pdf?version=1&modificationDate=1681926520148&cacheVersion=1&api=v2)
    
*   [Version 8 (OS 8)](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScriptReferenceManual%20(ver%208).pdf?version=1&modificationDate=1681851693731&cacheVersion=1&api=v2)
    
*   [Version 7.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.1).pdf?version=1&modificationDate=1681851450896&cacheVersion=1&api=v2)
    
*   [Version 7.0](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%207.0).pdf?version=1&modificationDate=1681851517656&cacheVersion=1&api=v2)
    
*   [Version 6.2](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightScript%20Reference%20Manual%20(ver%206.2).pdf?version=1&modificationDate=1681851180597&cacheVersion=1&api=v2)
    
*   [Version 6.1](https://brightsign.atlassian.net/wiki/download/attachments/370674351/BrightSignReferenceManual_V6.1.pdf?version=1&modificationDate=1681851246728&cacheVersion=1&api=v2)
    
*   [Previous Versions](https://support.brightsign.biz/hc/en-us/articles/218067797-Legacy-Documentation-and-User-Guides) 
    

[BrightScriptReferenceManual_ver9.pdf](./attachments/BrightScriptReferenceManual_ver9.pdf)

> [!NOTE]
> If you're having trouble viewing the above file, make sure you are accessing this site via HTTPS (e.g. [https://docs.brightsign.biz](https://docs.brightsign.biz/)).

BrightScript is a powerful scripting language for building media and networked applications for BrightSign players. Through a library of lightweight BrightScript objects, BrightScript enables access to the player’s API (Application Programming Interface) so that users can utilize the player’s underlying components for networking, media playback, UI screens, and interactive interfaces. As an interpreted language (rather than a compiled one), BrightScript is optimized for generating feature-rich applications in an efficient and user-friendly way.

This section is divided into two categories:

*   [Language Reference](./brightscript/language-reference.md)  
    Outlines the characteristics of the BrightScript language such as syntax, operators, statements, types, core library, etc.
    
*   [Object Reference](./brightscript/object-reference.md)  
    Provides a directory of publicly available objects, interfaces, and methods that comprise the BrightScript API.
    

Refer to the [BrightScript-JavaScript Migration Guide](../developers/player-apis/brightscript-javascript-migration-guide.md) for info on mapping between BrightScript and JavaScript APIs.

See [Plugins and Parsers](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370673619/Plugins+and+Parsers) for info about plugins and parsers.
----
developers\developers\brightsign-registry-keys\igmp-behavior.md
# IGMP Behavior

In OS version 8.0.84, players accept a `force_igmp_version` registry entry in the networking section. This entry allows for customization of the player response to the IGMP network environment. It can have the following values:

*   0: The default behavior. The player will use IGMPv3 unless a querier with an older version is present, in which case the player will fall back to v2 or v1.
    
*   1: The player will always use IGMPv1.
    
*   2 : The player will use IGMPv2 if possible, but will fall back to v1 if an older querier is present.
    
*   3 : The player will only use IGMPv3 and will not fall back to v1 or v2.
    

### Example

This is a simple example which sets the value to 1. You will have to reboot the player to see registry changes. See BrightScript [roRegistry](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370673016) or JavaScript [registry](../../developers/player-apis/javascript-apis/registry.md) for more details.

```
var registryClass = require("@brightsign/registry");
var registry = new registryClass();
 
//Writes to the registry, forcing the player to always use IGMPv1
registry.write({networking:{force_igmp_version:"1"}}).then(
	function(){console.log("Write Successful");});
```
----
developers\developers\cloud-apis\postman-collections.md
# Postman Collections

[BSN%20Control%20Cloud.postman_collection.json](./attachments/BSN%20Control%20Cloud.postman_collection.json)
[bsn-control-cloud-production.postman_environment.json](./attachments/bsn-control-cloud-production.postman_environment.json)

# Control Cloud Library

The Postman library for BSN Control Cloud allows you to quickly familiarize yourself with the different APIs and processes associated with a BSN Control Cloud subscription. Follow the below steps to create a person/network, create a player setup, and provision a player on your network with the player setup.

> [!WARNING]
> This is a collection of sample endpoint calls to introduce users to our infrastructure.
> It is not a comprehensive document of our available endpoints. Please see the [BSN.cloud](../cloud-apis/bsncloud-main-apis.md), [Remote DWS](../../developers/local-and-remote-diagnostic-web-server-apis/remote-dws-apis.md), and [B-Deploy](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/378831792/B-Deploy+Device+Provisioning) endpoint documentation for a complete list of those endpoints and their usage.

## Prerequisites

*   A client ID and client secret (provided by BrightSign)
    
*   Postman
    
*   The BSN Control Cloud Library collection and bsn-control-cloud-production environment 
    
*   A BrightSign player with an active internet connection
    

## Steps

1.  Import both the Control Cloud Library collection and the bsn-control-cloud-production environment into Postman.
    
2.  Set the Postman environment to bsn-control-cloud-production using the dropdown menu in the top right.
    
3.  Select the "eye" icon and select **Edit** to edit the following variables (other variables will get their values from Postman scripts):
    
    ![Screenshot 2024-01-05 at 11.30.43 AM.png](./attachments/Screenshot%202024-01-05%20at%2011.30.43%20AM.png)
    
    *   **partnerLogin**: The email address to use for your BSN.Cloud person credentials
        
    *   **partnerEmail**: This email address, which should be the same as the Partner Login for now
        
    *   **partnerFirstName**: Your first name
        
    *   **partnerLastName**: Your last name
        
    *   **networkName**: The name of the BSN.cloud network to create. This name must be unique within the BSN.cloud database. You can change this value later if you want to create multiple networks (for example, for different customers).
        
    *   **clientId**: Provided by BrightSign
        
    *   **clientSecret**: Provided by BrightSign
        
    *   **playerSerial**: The serial number of the player to provision on your BSN.cloud network.
        
    *   **playerModel**: The model number of the player (for example, "XD1034")
        
    *   **deviceName**: The device name, which can be arbitrary
        
    *   **setupName**: The player setup name, which can be arbitrary
        
    *   **userAccessTokenLifetime**: The amount of time that a full access token for a network remains valid (the default is 15 minutes).
        
4.  Go to **BSN > User/Self > POST Self**. Select **Send** to register with BSN.cloud. This call also returns your person credentials and an auto-generated password, which Postman will store.
    
5.  Verify your email address:
    
    *   BSN.cloud will send an email to your email address. This may take a few minutes.
        
    *   Select the link in the email to verify the address.
        
    *   You don't need to follow the additional steps to create a network since these steps will be performed using APIs below.
        
6.  Select the **Token (Self)** call in the root of the library. Select **Send** to get a "Self" auth token, which Postman will store.
    
7.  Go to **BSN > User/Self > POST Self/Networks**. Select **Send** to create a BSN.cloud network with your credentials as the network owner.
    
8.  Select the **Token (Full)** call in the root of the BSN Control Cloud Library. Select **Send**.
    
    *   The server will return a "Full" auth token, stored in Postman, which will give you access to the network you created.
        
    *   To renew the "Full" access token, repeat this step. The default timeout for the token is 15 minutes.
        
9.  Select the **Token (device registration)** call in the root of the BSN Control Cloud Library. Select **Send**.
    
    *   The server will return a "device registration" auth token, which Postman will store.
        
    *   The "device registration" token is separate from a user token and allows players to provision themselves for a certain network.
        
10.  Go to **B-Deploy > POST /setup/**. Select **Send** to post a setup to the B-Deploy server and get the setup ID, which Postman will store.
    
11.  Go to **B-Deploy > POST /device/**. Select **Send**. Your device serial number is now associated with the ID of the device setup you created in the previous step.
    
12.  Power on or reboot your player. The player will reboot several times while provisioning itself for your network.
    
13.  Go to **BSN > Devices > GET Devices**. Select **Send** to get a list of the players on your network.
    
14.  Go to **Remote DWS > GET /info/**. Select **Send** to get player information.
----
developers\developers\cloud-apis\using-api-access-and-refresh-tokens.md
# Using API Access and Refresh Tokens

> [!WARNING]
> BSN.cloud is changing its authorization server to be able support SSO and other security features requested by customers, and our access and refresh token lifetimes will be changing because of this.
> **Access tokens will have a 5 minute lifetime**
> **Refresh tokens will have a 30 minute lifetime**
> **Session lifetime will be 12 hours**
> You must ensure that all of your applications and/or scripts are correctly handling and refreshing these tokens or you may find that they stop working correctly.
> All customers will be notified in advance of this change so that they have time to check and prepare their applications and scripts.

# Refresh token-based authentication workflow

To access the BSN.cloud APIs you are required to submit your credentials in order to obtain your access and refresh tokens. Access tokens are temporary credentials that grant access to a protected resource, while refresh tokens are used to obtain new access tokens when the current ones expire.

When your application or script accesses the token endpoint and authorizes successfully, it is granted an access token and a refresh token. The access token is then passed with each API request to allow the resource to be accessed.

> [!INFO]
> BSN.cloud Token Endpoint: [https://api.bsn.cloud/2022/06/REST/Token/](https://api.bsn.cloud/2022/06/REST/Token/)

After a period of time (the access token lifetime), making the API call will fail with an error because the access token has expired. At this point, your code should use the refresh token to exchange for a new access token. This is done by passing the refresh token to the token endpoint, which verifies the refresh token and issues new access and refresh tokens in the response. You should then use this new access token in your subsequent API call.

This process continues until either:

*   the refresh token is expired
    
*   the refresh token is revoked
    
*   the current session is expired
    

At this point you will need to re-authenticate with your credentials.

The following flow diagram shows this flow:

![Screenshot 2024-08-02 at 8.55.33 AM.png](./attachments/Screenshot%202024-08-02%20at%208.55.33%20AM.png)

1.  The client application authenticates with the BSN.cloud token endpoint by providing the credentials
    
2.  If the credentials are valid, an access token and a refresh token are returned in the result
    
3.  The client application makes an API call and must pass the access token
    
4.  The API component validates the access token and allows access to the resource
    
5.  Steps 3 and 4 can continue until the access token expires and the API signals this by returning an error response (this will be a `401` or `403` status code)
    
6.  When the access token expires, the client application requests a new access token by providing the refresh token
    
7.  The BSN.cloud token endpoint then issues a new access token and a *new refresh* token
    
8.  Steps 3 through 7 repeat until the refresh token expires, or is revoked, or the current session ends
    
9.  The client needs to re-authenticate with the authentication server once again and the flow repeats from step 1.
    

> [!INFO]
> [BSN.cloud API Authentication Documentation](../cloud-apis/bsncloud-main-apis/main-rest-http-api-version-202206.md)
> Person Authentication: [Main REST HTTP API version 2022/06 | Authenticating as a Person](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/1313046529/Main+REST+HTTP+API+version+2022+06#Authenticating-as-a-Person)
> Person Token Refresh: [Main REST HTTP API version 2022/06 | Person OAuth2 Token Renewal](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/1313046529/Main+REST+HTTP+API+version+2022+06#Person-OAuth2-Token-Renewal)
> User Authentication: [Main REST HTTP API version 2022/06 | Authenticating as a User](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/1313046529/Main+REST+HTTP+API+version+2022+06#Authenticating-as-a-User)
> User Token Refresh: [Main REST HTTP API version 2022/06 | User OAuth2 Token Renewal](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/1313046529/Main+REST+HTTP+API+version+2022+06#User-OAuth2-Token-Renewal)

# Refresh Tokens

**So, why do we need both access tokens and refresh tokens?** Why don’t we just set a long expiration date, like a month or a year for the access tokens? If we do that and someone manages to get hold of our access token they can use it for a long period, even if we change our password

The idea of refresh tokens is that we can make the access token short-lived so that, **even if it is compromised, the attacker gets access only for a short period**. With refresh token-based flow, the authentication server issues a one-time use refresh token along with the access token. Your application should store the refresh token safely

Every time your application sends a request to the server it sends the access token in the Authorization header and the server can identify the application using it. When the access token expires, the server will send a token expired response. When your application receives the token expired response, it must send the refresh token to obtain a new access token and refresh token

If something goes wrong, **the refresh token can be revoked** which means that when the your application tries to use it to get a new access token, that request will be rejected and you will have to enter the credentials once again and authenticate.

**Why can’t we just use Steps 1, 2 and 3 constantly instead of having to deal with refresh tokens?** Issuing many active access tokens is not an efficient process and it leads to an increase in storage and decrease in performance for our backend servers. Up until now we have permitted this approach but going forward we will be adding limitations to the number of unexpired access tokens that an application can have at any one time.
----
developers\developers\cloud-apis.md
# Cloud APIs

BrightSign cloud APIs can be categorized as follows:

*   **Basic Authorization APIs** control access to all of the BSN.cloud or BrightSignNetwork.com resources in your network.
    
*   **B-Deploy (Provisioning) APIs** provide tools for managing automated deployment packages.
    
*   **BSN.cloud and .com Service APIs** expose the functionality of our BrightAuthor and BrightAuthor:connected content management systems and let you monitor and manage BrightSign players.
    

Note that the diagrams below describe BSN.cloud servers and APIs, but [BrightSignNetwork.com](http://BrightSignNetwork.com) servers and APIs work in the same way.

## Basic Authorization APIs

![AccessAPIs.png](./attachments/AccessAPIs.png)

An [OAuth](./cloud-apis/bsncloud-main-apis/main-rest-http-api-version-202206.md) (bearer) token gives users authorization to communicate with APIs and send requests to the B-Deploy or Remote DWS APIs.

*   Use this API to get a Person OAuth2 Access/Refresh token, which returns list of networks. Then, as an authenticated user, you can send a User OAuth2 Access/Refresh token to the correct network. This allows you to access the network within the scope of what you are allowed to do. 
    
*   This API returns either a valid token that gives you access to any version of the BSN.cloud APIs, or a valid token that gives you access to any version of the BrightSignNetwork.com APIs.
    
*   The BSN.cloud and BrightSignNetwork.com base URLs are:
    
    *   *https://api.bsn.cloud/* 
        
    *   *https://api.brightsignnetwork.com/*
        

## B-Deploy (Provisioning) APIs

![SetupAPIs.png](./attachments/SetupAPIs.png)

[B-Deploy](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/378831792/B-Deploy+Device+Provisioning) APIs are available through BSN.cloud for automated deployment of players in the field. These APIs deliver the setup to players and allow creation and modification of the setup packages. They consist of Provisioning Server and Provisioning Setup Server APIs:

*   The Provisioning Server (PVS) returns an URL when given a serial number for any BSN.cloud or BSN connected device. The PVS provides only REST APIs.
    
*   The Provisioning Setup Server (PSS) stores and serves setup packages, presentation packages and firmware updates. The PSS provides a UI (in addition to REST APIs), which makes calls to PVS to add and retrieve serial numbers and URLs. 
    

## BSN.cloud and .com Service APIs

![ServiceAPIs copy.png](./attachments/ServiceAPIs%20copy.png)

These APIs expose the functionality of our BrightAuthor and BrightAuthor:connected content management systems using a standard set of endpoints, entities, and methods. Developers can use these APIs to build custom content management interfaces with some or all of the features that we have developed for our own content management system. These APIs can also be used for device/fleet management.

[BSN.cloud APIs](./cloud-apis/bsncloud-main-apis.md) allow users of our cloud-based infrastructure to interact with networked BrightSign players. Partners can use the BSN.cloud APIs with or without their own servers. 

[BrightSignNetwork.com APIs](./cloud-apis/bsncom-main-apis.md) use the older BrightSign network to interact with BrightSign players.
----
developers\developers\html-development\displaying-html-with-brightauthor.md
# Displaying HTML with BrightAuthor

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Table of Contents

*   [HTML Guidelines](#html-guidelines)
    *   [Zones](#zones)
    *   [Z-Ordering](#z-ordering)
    *   [Content Sourcing](#content-sourcing)
    *   [Using Custom Fonts](#using-custom-fonts)
    *   [Exporting an HTML5 Presentation](#exporting-an-html5-presentation)
*   [Caching and Storage](#caching-and-storage)
*   [Using HTML with Portrait Orientation](#using-html-with-portrait-orientation)
*   [Integrating Touchscreen Content](#integrating-touchscreen-content)
*   [Disguising Network Latency](#disguising-network-latency)
*   [Displaying Scrollbars](#displaying-scrollbars)

This section covers how to integrate HTML pages into BrightAuthor presentations. To add an HTML page to a presentation, click the **other** tab under **Media Library**, select the **HTML5** state, and drag it into the playlist area. You will be prompted to add local HTML files or a remote page URL to your presentation.

# HTML Guidelines

The following are general rules for using HTML content in BrightAuthor:

## Zones

*   You can have multiple zones containing HTML content in a BrightAuthor presentation.
    
*   HTML content can be inserted into a Video or Images zone or an Images Zone. You cannot use HTML content in a Video Only zone.
    
*   The dimensions of the HTML background/page must match the size of the zone in BrightAuthor: You cannot use background image scaling to fit zones of different sizes.
    

![](./attachments/BA3.5%201.png)

## Z-Ordering

*   HTML content will show at the highest Z-level of graphics zones, meaning that an HTML zone will cover all other zones that contain images and text. This behavior does not extend to touch screens (see **Integrating Touchscreen Content** below for more details).
    
*   HTML content can be placed in front of or behind zones containing video content, depending on the **Graphics plane z position** setting of the zone containing the HTML content (configurable in the **Edit > Layout** tab). 
    
*   If the HTML page contains video and the **Enable native video plane playback** option is enabled in the HTML5 state, the HTML page will *always* display over other video zones.
    

## Content Sourcing

*   HTML content can originate from a remote server, a local server, or the local storage (SD card) of the player. Presentations containing HTML content can also be downloaded onto the local storage from the BrightSign Network.
    
*   If your HTML content relies on assets from multiple locations, make sure to check the **Enable external data** box when creating or editing an HTML5 state.
    

## Using Custom Fonts

*   When creating an HTML5 state in BrightAuthor, click the **Add Font** button to add custom True Type Font (*.ttf*) files to the HTML page. This feature works for both local and remote HTML content.
    
*   When the presentation is published, the font file(s) will act as though they are located in the same file directory as the *index.html* file (i.e. they can be accessed with the standard font-family attribute in HTML/CSS).
    

## Exporting an HTML5 Presentation

*   Exporting a presentation that contains multiple HTML pages also exports in full all asset folders associated with those pages. If your pages share common asset folders, the entire contents will be duplicated multiple times. This can become problematic if your asset folders contain large content files, so you may need to prune and/or rearrange asset folders that are duplicated after export.
    

# Caching and Storage

BrightAuthor allows you to configure common browser caching and storage functions on the player. To enable these functions, open your BrightAuthor HTML presentation and navigate to **Edit > Preferences > Storage** and check **Limit storage space by function**. You can allocate space for the following functions:

*   **HTML data**: The amount of space dedicated to the HTML application cache
    
*   **HTML local storage**: The amount of space dedicated to JavaScript variables and data
    

If you select **Specify absolute size**, it is possible to specify a combined set of segments that is larger or smaller than the absolute size of your storage device. If you select **Specify percentages**, you will need to ensure that the percentages add up to 100% (which is equivalent to the absolute size of the local storage on the player).

> [!NOTE]
> The **HTML local storage** feature is only available in BrightAuthor versions 4.1.1.12 and later. A similar feature is available in the **File > Presentation Properties > HTML** section in earlier versions.

# Using HTML with Portrait Orientation

Follow these steps to create a digital-signage canvas that is portrait oriented:

> [!WARNING]
> These instructions apply to BrightAuthor versions 4.3.0.x and later.

1.  Edit the aspect ratio in your web authoring software (e.g. Dreamweaver) so that it is the reverse of your monitor/television resolution. For example, if you plan on displaying the portrait content in 1080p, set the resolution to 1080x1920 rather than 1920x1080.
    
2.  Create a new presentation for your player in BrightAuthor.
    
3.  Set the **Monitor Orientation** to **Portrait**. Click **Create**.
    
4.  When prompted to select a template, choose **Full screen**.
    
5.  Add your HTML content to the playlist.
    

![](./attachments/BA3.5%204-6.png)

# Integrating Touchscreen Content

You can enable touch-screen events for an HTML page by checking the **Enable mouse and touch events** box when creating an HTML5 state (see the [HTML5 state](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370671786/HTML5) description for more details).

> [!NOTE]
> BrightSign players are compatible with touchscreens that use standard HID drivers. Note that some manufacturers claim support for HID but still use custom drivers. See [this FAQ](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/2320728065/Supported+Touchscreens) for further discussion and a list of touchscreen models that have been tested with BrightSign players.

Note that touch events are received by both HTML pages and BrightAuthor Rectangular Touch events. Therefore, if you have a zone with an HTML page overlapping a zone containing a Rectangular Touch event, touching the area of overlap will send an event to both zones at the same time. This is the case even if one zone completely covers the other visually. Depending on the type of action triggered in each zone, touch-event overlap may cause crashing or other issues with presentation stability. Unless you are certain of the consequences, make sure that zones with touch-enabled HTML content and zones with Rectangular Touch events do not overlap.

> [!WARNING]
> Creating an overlap as shown below may have unintended consequences.

![](./attachments/BA3.5%207.png)

# Disguising Network Latency

When the BrightSign player loads HTML content from a URL, there may be a delay based on network latency. You can add a preload image to sidestep this issue. Note that this solution is not necessary if all HTML assets are located on the local storage of the player.

1.  Drag and drop an image file from your media library.
    
2.  Check the **Set as initial state** box while editing the image state.
    
3.  Add a Timeout event to this image.
    
4.  Specify the timeout for three seconds (or more if desired).
    
5.  Set the Timeout event to transition to the HTML5 state.
    

![](./attachments/BA3.5%203.png)

# Displaying Scrollbars

Browser scrollbars are disabled by default in BrightAuthor. To display scrollbars, reference this simple CSS file from your HTML page:

[ForceScrollbars.css](./attachments/ForceScrollbars.css)
----
developers\developers\html-development\displaying-html-with-brightauthorconnected.md
# Displaying HTML with BrightAuthor:connected

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Table of Contents

*   [HTML Guidelines](#html-guidelines)
    *   [Zones](#zones)
    *   [Z-Ordering](#z-ordering)
    *   [Content Sourcing](#content-sourcing)
    *   [Using Custom Fonts](#using-custom-fonts)
    *   [Exporting an HTML5 Presentation](#exporting-an-html5-presentation)
    *   [Chromium Video Playback](#chromium-video-playback)
*   [Caching and Storage](#caching-and-storage)
*   [Using HTML with Portrait Orientation](#using-html-with-portrait-orientation)
*   [Integrating Touchscreen Content](#integrating-touchscreen-content)
*   [Disguising Network Latency](#disguising-network-latency)
*   [Displaying Scrollbars](#displaying-scrollbars)

This page covers how to integrate HTML pages into BrightAuthor:connected presentations. To add an HTML page to a presentation, select the HTML5 widget in the bottom of the **Content** window and drag it into the content panel above. [This page](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/1632600407/HTML5+State) describes how to use that widget.

## HTML Guidelines

### Zones

*   You can have multiple zones containing HTML content in a BrightAuthor:connected presentation.
    
*   HTML content can be inserted into a **Video or Image** zone or an **Image** zone.
    

### Z-Ordering

*   HTML content will show at the highest Z-level of graphics zones, meaning that an HTML zone will cover all other zones that contain images and text. This behavior does not extend to touch screens.
    
*   HTML content can be placed in front of or behind zones containing video content, if you drag the **Graphics** zone(s) before or after the **Video** zone(s) (under the Zone menu in the **Zone Properties** panel). See Image 1 below.
    
*   If the HTML page contains video and the **Enable native video playback** option is enabled in the HTML5 state, the HTML page will *always* display over other video zones.
    

![](./attachments/Screenshot%202023-09-07%20at%2010.47.42%20AM.png)

### Content Sourcing

HTML content can originate from a remote server, a local server, or the local storage (SD card) of the player. Presentations containing HTML content can also be downloaded onto the local storage from the BrightSign Network.

### Using Custom Fonts

To use custom fonts, specify the font in your script. If the font file is in the same directory as your JS and CSS files, it will be used in BrightAuthor:connected. 

### Exporting an HTML5 Presentation

Exporting a presentation that contains multiple HTML pages also exports in full all asset folders associated with those pages. If your pages share common asset folders, the entire contents will be duplicated multiple times. This can become problematic if your asset folders contain large content files, so you may need to prune and/or rearrange asset folders that are duplicated after export.

### Chromium Video Playback

The HTML5 widget has an **Enable Native Chromium video playback** option in versions 1.19.2 and later of BrightAuthor:connected. This feature is only available for XC5 players and is explained on [this page](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/1632600407/HTML5+State).

> [!NOTE]
> Partners using a custom CMS can use [HTML Playback Options on Series 5 Players](../html-development/html-playback-options-on-series-5-players.md) for more guidance on setting this option in their CMS.

## Caching and Storage

BrightAuthor:connected allows you to configure common browser caching and storage functions on the player. To enable these functions in your BrightAuthor:connected presentation, select **Enable Limit Storage** under **Admin > Application Preferences**, allocate the space as you wish, and select **Apply**. You can allocate space for the following functions:

*   **HTML Data**: The amount of space dedicated to the HTML application cache
    
*   **HTML Local Storage**: The amount of space dedicated to JavaScript variables and data
    
*   **HTML Indexed DB**: The amount of space dedicated to IndexedDB content
    

![](./attachments/HTMLLimitOptions.png)

## Using HTML with Portrait Orientation

To create a digital-signage canvas that is portrait oriented, simply create a portrait presentation and then insert an HTML5 widget.

## Integrating Touchscreen Content

You can enable touch-screen events for an HTML page by checking the **Enable mouse and touch events** box when creating an HTML5 state .

## Disguising Network Latency

When the BrightSign player loads HTML content from a URL, there may be a delay based on network latency. You can add a preload image to sidestep this issue. Note that this solution is not necessary if all HTML assets are located on the local storage of the player.

1.  Set BrightAuthor:connected to **Interactive**
    
2.  Drag and drop an image file into the main panel
    
3.  Set the **Initial State** box while editing the [**Image State**](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/1632632833/Image+State).
    
4.  Specify the timeout for three seconds (or more if desired) in a [**Timeout** **Event**](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/1636106748/Timeout+Event)**.**
    
5.  Set the **Timeout** **Event** to transition to the HTML5 state.
    

## Displaying Scrollbars

Browser scrollbars are disabled by default in BrightAuthor:connected. To display scrollbars, reference this simple CSS file from your HTML page:

[ForceScrollbars.css](./attachments/ForceScrollbars.css)
----
developers\developers\html-development\displaying-html-without-brightauthor.md
# Displaying HTML without BrightAuthor

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Table of Contents

*   [Simple Webpage Script](#simple-webpage-script)
*   [Portrait Orientation](#portrait-orientation)
*   [Displaying Scrollbars](#displaying-scrollbars)
*   [Mobile Scrollbars](#mobile-scrollbars)

There are two methods to display HTML without BrightAuthor. 

*   You can play an HTML page from the local storage without an autorun script by placing the  *index.html* file (along with other files and folders containing the page content) into the root folder of the player storage.
    
*   You can use BrightScript to display local or remote HTML content. The sections below pertain to using the [*roHtmlWidget*](../../developers/brightscript/object-reference/presentation-and-widget-objects/rohtmlwidget.md) BrightScript object to display HTML. To learn more about BrightScript, see the [BrightScript](../../developers/brightscript.md) section.
    

## Simple Webpage Script

The simple script outlined below displays a webpage stored on a remote server. Save this script as an *autorun.brs* file, place it on an SD card, and publish it to the player.

If you want to display a webpage located on local storage, replace the "http://www.brightsign.biz" URL on line 4 with the filename of the .html file: `"file:///mytestpage.html"`

Notice that the script has a `Sleep(10000)` line. This line delays loading of the web URL–this is necessary to compensate for connection delays that may occur on your network. If you don’t use this script, the BrightSign player may not connect in time to load the page, resulting in a “cannot resolve host” error, which indicates that the player does not have an Internet connection. In certain network configurations, especially when the player utilizes DHCP, you may need to increase the sleep amount (in milliseconds) to give the player more time to establish a connection before loading the page.

Parameters for the *roHtmlWidget* are defined in an associative array, which is then passed during object creation. See the [*roHtmlWidget* page](../../developers/brightscript/object-reference/presentation-and-widget-objects/rohtmlwidget.md) for more information on creating and configuring an HTML widget. 

```
Sub Main()
msgPort = CreateObject("roMessagePort")
r = CreateObject("roRectangle", 0, 0, 1920, 1080)
 
config = {
url: "http://www.brightsign.biz",
}
h = CreateObject("roHtmlWidget", r, config)
h.SetPort(msgPort)
sleep(10000)
h.Show()
while true
	msg = wait(0, msgPort)
	print "type(msg)=";type(msg)
	if type(msg) = "roHtmlWidgetEvent" then
		eventData = msg.GetData()
		if type(eventData) = "roAssociativeArray" and type(eventData.reason) = "roString" then
			print "reason = ";eventData.reason
			if eventData.reason = "load-error" then
				print "message = ";eventData.message
			endif
		endif
	endif
end while
End Sub
```

## Portrait Orientation

To rotate the contents of an HTML page, include the `transform` parameter when creating the *roHtmlWidget* object: For clockwise portrait orientation, use `transform:"rot90"`; for counter-clockwise portrait orientation, use `transform:"rot270"`. If you're using the above simple webpage script, you can add this parameter to the `config` associative array on line 7.

## Displaying Scrollbars

Browser scrollbars are disabled by default. They can be enabled by including the `scrollbar_enabled:true` parameter when creating the *roHtmlWidget* object. If you're using the above simple webpage script, you can add `scrollbar_enabled:true` to the `config` associative array on line 7.

You can also enable scrollbars using CSS (for example, by referencing the simple CSS file below).

[ForceScrollbars.css](./attachments/ForceScrollbars.css)

## Mobile Scrollbars

Browser scrollbars default to desktop style (i.e. more prominent and visible at all times). You can configure the Chromium instance for mobile-style scrollbars (i.e. less prominent and only visible when scrolling) by writing the `overlay-scrollbar` entry to the `html` section of the registry.

```
htmlRegistry = CreateObject("roRegistrySection", "html")
htmlRegistry.Write("overlay-scrollbar", "1")
```
----
developers\developers\html-development\html-authoring-resources.md
# HTML Authoring Resources

There are a large number of online resources—including tutorials, samples, templates, and widgets—available to help you get started creating content with HTML5. The HTML5 standard offers huge advantages to web developers, including digital signage authors. The following websites are great places to learn how to create pages using HTML5: 

*   [http://www.html5report.com](http://www.html5report.com)
    
*   [http://www.w3schools.com](http://www.w3schools.com)
    

## WordPress 

WordPress is an excellent HTML5 resource that provides an intuitive approach to creating digital signage. Here are some of the benefits of using the WordPress architecture: 

*   WordPress offers advanced HTML5 support, with premade widgets ranging from weather to e-commerce. The system also supports advanced HTML5 options using CSS3 features. The [http://www.jqwidgets.com](http://www.jqwidgets.com) site also provides HTML5 widgets.
    
*   You can either run WordPress from [the website](http://wordpress.org/) or install a WordPress instance on your own servers.
    
*   WordPress has an ecosystem of template creators that offer sophisticated templates for a wide range of industries: Template creators include the following:
    
    *   [http://www.rockettheme.com/wordpress](http://www.rockettheme.com/wordpress)
        
    *   [http://www.templatemonster.com](http://www.templatemonster.com)
        
    *   [http://graphpaperpress.com](http://graphpaperpress.com)
        

## HTML5 Authoring

These are some of the common HTML5 authoring applications:

*   Adobe CS Tools: Dreamweaver, Illustrator, InDesign, Photoshop
    
*   Aptana Studio
    
*   CoffeeCup Software
----
developers\developers\html-development\html-best-practices\html-caching.md
# HTML Caching

This page covers how to use caching techniques to display HTML content. BrightSign players offer novel solutions through BrightAuthor and BrightScript, as well as support for common Node.js® and JavaScript caching solutions.

## Storage and Memory

Before discussing HTML caching techniques, it is important to understand the storage and memory limitations of the players. All BrightSign players run HTML content on a Chromium engine. By default, Chromium reserves 1GB plus 10% of the total size of the player's storage device for memory. Players also have limited memory to run HTML graphics and JavaScript. This amount varies between player models; consult [this list](https://docs.brightsign.biz/display/DOC/HTML+Best+Practices#HTMLBestPractices-MemoryandPerformance) for more detail.

To change the storage values through BrightAuthor:

1.  Navigate to **Edit > Preferences > Storage**
    
2.  Check **Limit Storage Space by Function**
    
3.  Now space can be allocated for both HTML graphics and JavaScript. Make sure that:
    
    1.  When using **Specify absolute size**, the specified segments should be neither larger nor smaller than the absolute size of your storage device
        
    2.  When using **Specify percentages**, the percentages must add up to 100%.
        

These limitations are shared across all *roHtmlWidget* instances, where [*roHtmlWidget*](https://docs.brightsign.biz/display/DOC/roHtmlWidget) is the BrightScript object that handles all HTML processes.

## Caching Capabilities

BrightSign players offer a flexible toolset for caching HTML content. The sections below discuss novel BrightSign solutions and how to enable and use more common methods through Node.js and JavaScript.

### BrightSign solutions

BrightSign players offer two HTML caching solutions:

*   **Local Storage**: The SD card for each player can store HTML content for playback. This method eliminates any connectivity or latency issues that may arise from networked solutions, but it must be done on a player by player basis. This can make local storage unattractive when dealing with a large fleet of devices.
    
*   **The AssetPool BrightScript object:** The AssetPool is a sharded hash directory and is recommended for large file count applications. The AssetPool is filled by AssetFetcher objects that can acquire content online and store it for later playback in either sha1, besha1, or MD5 hash protocols. Consult [this page](https://docs.brightsign.biz/display/DOC/Content+Management+Objects) for more information about AssetPool.
    

### Node.js and JavaScript solutions

BrightSign players also support Node.js and JavaScript caching techniques. To use Node.js:

*   If you are using BrightAuthor, Node.js must first be enabled through a [BrightScript *roHtmlWidget* object](https://docs.brightsign.biz/display/DOC/roHtmlWidget#roHtmlWidget-%5Bboolean%5Dnodejs_enabled)
    
*   If you are using BrightAuthor:connected, Node.js can be initialized through the [Presentation State Properties](https://docs.brightsign.biz/display/DOC/State+Properties#StateProperties-Options) user interface.
    

Once Node.js is running on the player, users can use any JavaScript API or caching method to cache content. Recommended content acquisition methods are XmlHttpRequest and Fetch with Service Worker. Keep the memory limitations in mind - for example, XmlHttpRequest will cause some player models to crash if it is used to download files larger than 100-200MB. If XmlHttpRequest's storage reservation will exceed your memory limitation, we recommend using the Fetch API. 

You cannot use Service Workers to cache video content. BrightSign players use our media player infrastructure for later video playback, not the Chromium network. BrightSign recommends [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB) for storage: use it to cache content playback according to [these instructions](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Client-side_storage#storing_complex_data_via_indexeddb). 

See an HTML/JavaScript test download example [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370677153/Node.js#Downloading-Large-Files). 

> [!NOTE]
> Our HTML widget cannot cache videos listed in the AppCache manifest because of differences between the Chrome desktop and BrightSign device video playback architecture. Please use Service Worker and IndexedDB to cache content instead of AppCache, which is now deprecated.

### Using Blobs

BrightSign video players can play blob URLs referring to items in IndexedDB and Html5 FileSystem API. However it cannot play blob URLs referring to JavaScript objects in memory.

See this video-browser-storage.html example:

[indexdb_playback_example.zip](./attachments/indexdb_playback_example.zip)
----
developers\developers\html-development\html-best-practices.md
# HTML Best Practices

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Table of Contents

*   [Content Restrictions](#content-restrictions)
    *   [Web Browsing](#web-browsing)
    *   [Flash Content](#flash-content)
    *   [Video](#video)
    *   [4K Graphics](#4k-graphics)
        *   [XTx44, XTx43](#xtx44-xtx43)
        *   [XDx34, XDx33, HDx24, HDx23, LS424, LS423, 4Kx42](#xdx34-xdx33-hdx24-hdx23-ls424-ls423-4kx42)
    *   [Pixel Sizes and Coordinates with 4K Modes](#pixel-sizes-and-coordinates-with-4k-modes)
    *   [Image Sizes](#image-sizes)
    *   [Memory and Performance](#memory-and-performance)
    *   [Web Fonts](#web-fonts)
*   [Creating HTML Pages](#creating-html-pages)
*   [BrightSign Extensions](#brightsign-extensions)
    *   [GPU Rasterization](#gpu-rasterization)
    *   [Optimized Image Rendering](#optimized-image-rendering)
*   [Renderer Versions and Support](#renderer-versions-and-support)
*   [Animations and Add-on Libraries](#animations-and-add-on-libraries)
    *   [JavaScript Animations](#javascript-animations)
    *   [WebGL](#webgl)
    *   [Vector Animations](#vector-animations)
    *   [Canvas Animations](#canvas-animations)
    *   [Push Technology](#push-technology)
    *   [File Storage](#file-storage)
    *   [File Downloads](#file-downloads)
    *   [CSS Transforms](#css-transforms)
*   [HTML Storage](#html-storage)
    *   [Initialization](#initialization)
    *   [Storage Path](#storage-path)
    *   [Storage Quota](#storage-quota)
*   [Touchscreen Support](#touchscreen-support)
*   [Debugging Webpages](#debugging-webpages)
    *   [Web Inspector](#web-inspector)
        *   [Enabling the Web Inspector](#enabling-the-web-inspector)
        *   [Inspecting a Webpage](#inspecting-a-webpage)
        *   [Chromium Version Compatibility](#chromium-version-compatibility)
    *   [Trace Events](#trace-events)
        *   [Creating a TraceEvent Directory](#creating-a-traceevent-directory)
        *   [Enabling the TraceEvent System](#enabling-the-traceevent-system)
            *   [Example (JavaScript):](#example-javascript)
        *   [Viewing Trace Events](#viewing-trace-events)
        *   [Additional Documentation](#additional-documentation)
*   [Disabling Staged ES6 Features](#disabling-staged-es6-features)

This page covers the content requirements, abilities, and restrictions of the HTML rendering engine on BrightSign players.

## Content Restrictions

The following are content restrictions associated with HTML pages:

### Web Browsing

BrightSign players are *not* intended for use as general-purpose web browsers. It is best to think of BrightSign units as HTML players with interactive capabilities, not web-surfing tools: Each page should be thoroughly tested before being used as digital signage.

### Flash Content

BrightSign players do not support Flash content. Any HTML pages that have embedded flash content will not display correctly. Most Flash authoring applications, including the Adobe Creative Suite, have tools that allow you to export flash content as HTML.

### Video

See the [HTML Video](../html-development/html-video.md) page for usage rules regarding HTML video.

### 4K Graphics

While many BrightSign models can output 4K video modes (3840x2160), not all of these models can render HTML at 4K:

#### XTx44, XTx43

The XTx44 and XTx43 models support a native 4K HTML graphics plane (see [this page](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370678836/Full-Resolution+Graphics) for more details). Note the following performance restrictions when using native 4K HTML graphics:

*   Animations will not exceed 20 FPS (and intensive animations may exhibit very low framerates).
    
*   Non-HWZ video is likewise limited to 20 FPS, so [HWZ](../html-development/html-video.md) should be enabled for video elements in native 4K.
    
*   We recommend displaying only one or two 4K images at a time (for example, a slideshow with one image displayed and next image preloaded). Images should not exceed 3840x2160 in size. 
    
*   We recommend using [swap memory](../../developers/brightscript/object-reference/hashing-and-storage-objects/rovirtualmemory.md) if possible. 
    
*   Pages that use many layers may run out of memory in native 4K. Enabling the [gfxmemlarge](../../developers/brightscript/object-reference/presentation-and-widget-objects/rovideomode.md) setting may help mitigate this issue.
    

#### XDx34, XDx33, HDx24, HDx23, LS424, LS423, 4Kx42

The XD, HD, LS, and 4K models support graphics up to 1920x1200 (see [this page](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370678836/Full-Resolution+Graphics) for more details), which can then be upscaled to a 4K video mode. Pages must be specified as 1920x1080 (or 2048x1080 for DCI 4K); they can then be upscaled to 4K.

### Pixel Sizes and Coordinates with 4K Modes

As noted above, webpages are often upscaled when outputting a 4K video mode. Relative CSS property values will scale automatically, but pixel values may need to be modified to account for differences between 4K video and graphics. See [here](../../developers/brightscript/object-reference/presentation-and-widget-objects/rorectangle.md) for more information about using coordinates with upscaled video modes.

### Image Sizes

Images larger than 2048x1280x32bpp (or 3840x2160x32bpp for XT, 4K, XTx34, and XDx33 players) will not be displayed by default. If a 4K video mode is used, the player will upscale images from HD resolution accordingly (though [native 4K graphics](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370678836/Full-Resolution+Graphics) can be enabled on the XTx43). The default limit can be increased in BrightScript using the [*roVideoMode.SetImageSizeThreshold()*](http://docs.brightsign.biz/display/DOC/roVideoMode#roVideoMode-SetImageSizeThreshold(parametersAsroAssociativeArray)AsBoolean) method.

Without altering the default maximum resolution, you can increase the maximum width of images by sacrificing height (e.g. using a 3840x640x32bpp image on non-4K players is allowed). You can also increase the maximum width/height by reducing the bpp value (e.g. using a 3840x2160x16bpp on non-4K players is allowed).

> [!NOTE]
> For performance reasons, we recommend against downscaling images. This consumes considerably more resources than either displaying images at their native size or upscaling them.

### Memory and Performance

The amount of memory available for HTML applications varies by model and player series:

**Series 5 Players**

Unlike Series 4 and older players, Series 5 players don’t have pre-allocated graphics and system memory. There are limitations on GPU memory in Chromium so that demanding GPU applications don’t deplete that memory.

**Series 4 and Older Players**

*   **XTx43, XTx44**: 512MB for graphics; 512MB for JavaScript
    
*   **XDx33, XDx34**: 256MB for graphics; 512MB for JavaScript
    
*   **HDx23/LS423/HO523**: 256MB for graphics; 128MB for JavaScript
    

**Notes**

*   The memory available for graphics can be reduced by a number of factors, including the number of CSS layers, the complexity of animations, and the use of WebGL.
    
*   The JavaScript memory is subject to a hard limit: If there is no JavaScript memory after garbage collection, Chromium will terminate the active process.
    
*   Each HTML widget has its own JavaScript heap, so it's possible to overcommit JavaScript memory if multiple HTML widgets are active.
    

> [!TIP]
> Often, the best way to improve graphics performance is to ensure that images are scaled to the desired output resolution before they are rendered in HTML.

> [!NOTE]
> Use the [Chromium Web Inspector](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370672286/HTML+Best+Practices#Debugging-Webpages) to determine the amount of resources being used by a webpage.

### Web Fonts

If a font file is not included and referenced by the HTML page, text will be rendered using a default system font. While functional, the default font has little aesthetic appeal, so we recommend including font files for most digital-signage applications. Supported font types include TrueType Font files (*.ttf*), OpenType Font (*.otf*), and Web Open Font files (*.woff*, *.woff2*).

## Creating HTML Pages

Follow these steps when creating HTML pages:

1.  Make sure the HTML page has the same aspect ratio as your signage display. If you are using HTML content in a BrightAuthor zone that is smaller than the screen, fit the page to the same aspect ratio as the zone.
    
2.  Use a master Div aligned to 0,0 when building an HTML page. This will ensure correct alignment.
    
3.  When creating an HTML site, make sure that all webpage assets (image files, video files, etc.) are contained within the same folder on your local disk. This folder is a “site folder,” meaning that all assets in this folder and its subfolders will be used in the production of the webpage. If these assets are not in the folder, they will not display when the project is published.
    
4.  You can test the layout and appearance of a page locally by opening it with Google Chrome, which has similar rendering capabilities to BrightSign players.
    
5.  If you want to publish resource-intensive presentations (e.g. `<video>` elements or multiple transforms) using HTML, we recommend using a Class 10 (10Mb/s) SD card.
    

## BrightSign Extensions

The BrightSign implementation of the Chromium engine includes several platform-specific extensions. Extensions for <video> elements are covered on the [HTML Video](../html-development/html-video.md) page.

### GPU Rasterization

GPU rasterization is enabled by default in firmware versions 6.2.x and later. 

### Optimized Image Rendering

The `image-rendering` CSS property can be assigned the `optimizeSpeedBS` value. Using this value ensures that Chromium uses lower-quality but faster bilinear filtering when scaling images to 50% or less. We recommend using this value with pages that scale a lot of images at runtime.

## Renderer Versions and Support

The following table describes which version of web-rendering engine is used in each version of BrightSign firmware:

| Rendering Engine | Version | BrightSign FW Versions |
| --- | --- | --- |
| Chromium | 87  | 8.5.x, 9.0x |
| Chromium | 69  | 8.4.x, 8.3.x, 8.2.x, 8.1.x |
| Chromium | 65  | 8.0.x |
| Chromium | 45  | 7.1.x, 7.0.x, 6.2.x |
| Chromium | 37  | 6.1.x, 6.0.x |
| WebKit | \-- | 5.1.x, 5.0.x, 4.8.x, 4.7.x |

See [this page](https://docs.brightsign.biz/space/DOC/2303000608/Previous+Chromium+Downloads+for+Older+OS+Versions) to download any of the listed Chromium versions. Use [this page](http://caniuse.com/) to determine if specific function calls and extensions are supported in a corresponding version of Chrome.

> [!NOTE]
> Chromium version 69 or later will refuse SHA-1 certificates. See [this page](https://www.chromium.org/Home/chromium-security/education/tls/sha-1/) for more information.

## Animations and Add-on Libraries

This section outlines support for animations and add-on libraries for the Chromium engine on BrightSign players.

> [!TIP]
> Limit file directory depth to prevent issues caused by overly complex folder structures.

### JavaScript Animations

Animations that use JavaScript timers, including the jQuery® .animate() library, do not make efficient use of GPU resources and are not accurate enough to achieve smooth animations. For this reason, we recommend using CSS animations whenever possible. The jQuery® [Transit library](https://github.com/rstacruz/jquery.transit) uses CSS animations and provides an API similar to the .animate() library.

> [!NOTE]
> For best results when animating images, we recommend using images at their original size instead of scaling them first. For example, a 480x270 icon will rotate more smoothly if you use an image that is originally 480x270, rather than scaling down a 1280x720 image and then attempting to rotate it.

### WebGL

BrightSign players support the OpenGL API for JavaScript (i.e. WebGL). 

> [!NOTE]
> Textures will sometimes fail to load in WebGL because they exceed the [maximum allowed image size](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/2307784705/Supported+Image+Formats) on BrightSign Players. In these cases, you can use [*roVideoMode.SetImageSizeThreshold()*](../../developers/brightscript/object-reference/presentation-and-widget-objects/rovideomode.md) BrightScript method to increase the maximum size for textures.

### Vector Animations

The SVG protocol should be used to specify vector animations.

### Canvas Animations

Bitmap animations display smoothly when they are 1/3 or less of a 1080p HTML canvas. Setting the canvas size to 720p allows for larger high-quality animations to occupy the screen.

### Push Technology

The long polling technique has been tested and proven to work on BrightSign players.

The Websocket protocol is fully supported via the [Node.js](../html-development/nodejs.md) implementation on the BrightSign Chromium instance. In production environments, we recommend using HTTPS to initiate Websocket connections with a server (i.e using a WSS connection rather than a WS connection).

An example Websocket application is available on the [BrightSign Github](https://github.com/brightsign/websocket-test) page.

### File Storage

BrightSign players support several file storage/indexing technologies, including Web SQL, IndexedDB, the HTML Filesystem API, and the JavaScript *storage* class. The location and size of the web storage database should be set [during initialization of the *roHtmlWidget*](../../developers/brightscript/object-reference/presentation-and-widget-objects/rohtmlwidget.md) .

### File Downloads

If you're using JavaScript to download files, we reccomend using the Fetch API and Node.js® File System module to perform downloads. See [this page](../html-development/nodejs.md) for more details

### CSS Transforms

All CSS transforms should be specified as WebKit transforms. When performing a transform on a <div> or graphics element, you should not specify the transform in-line.

The following code shows an example of an effective CSS transform for a BrightSign player:

**Example:**

```
<style>
 
                .flipme{
                -webkit-animation-name:flipon;
                -webkit-animation-fill-mode:forwards;
                -webkit-animation-iteration-count:1;
                -webkit-animation-duration:2s;
                }
 
 
@-webkit-keyframes flipon
{
0% {-webkit-transform:rotateY(0deg);}
30% {-webkit-transform:rotateY(-90deg);}
100% {-webkit-transform: rotateY(360deg);}
}
 
</style>
```

## HTML Storage

The following [*roHtmlWidget*](https://docs.brightsign.biz/display/DOC/roHtmlWidget#roHtmlWidget-setlocalstoragedir()) methods are used to configure HTML storage on the BrightSign player:

*   `SetLocalStorageDir()`
    
*   `SetLocalStorageQuota()`
    
*   `SetWebDatabaseDir()`
    
*   `SetWebStorageQuota()`
    
*   `SetAppCacheDir()`
    
*   `SetAppCacheQuota()`
    

> [!NOTE]
> The behavior of *roHtmlWidget* storage methods has changed in OS8. The new behavior is described below. Updating a player to OS8 from 7.1.x or earlier will cause stored HTML data on the player to be reset.

### Initialization

The above methods take effect when a new *roHtmlWidget* instance is created; they don't apply to the *roHtmlWidget* instance on which they are called (this is not the case for the the `storage_path` and `storage_quota` [initialization parameters](https://docs.brightsign.biz/display/DOC/roHtmlWidget#roHtmlWidget-initialization_parameters)).

### Storage Path

The `SetLocalStorageDir()`, `SetWebDatabaseDir()`, and `SetAppCacheDir()` methods all configure the same storage path, so calling one of these methods will overwrite the storage path configured by the other methods.

Without a storage path (for example, when you are using an 'incognito' browser), nothing will persist when you are finished with the Chromium instance. If you want data to persist through reboot and widget creation, you must set a storage path. When non-persistent (incognito) mode is used, 10% of the total system memory is reserved for browser storage. This memory will be shared between multiple roHtmlWidget instances.

### Storage Quota

The `SetLocalStorageQuota()`, `SetWebStorageQuota()`, and `SetAppCacheQuota()` methods all configure the same storage quota, which applies to all persistent HTML storage on the player. If the storage path is specified without a storage quota, Chromium defaults to reserving 1GB plus 10% of the total size of the storage device.

If there are multiple *roHtmlWidget* instances, the configured or default quota is shared among them.

## Touchscreen Support

BrightSign players are compatible with touchscreens that use standard HID drivers. Note that some manufacturers claim support for HID but still use custom drivers. See [this FAQ](http://support.brightsign.biz/hc/en-us/articles/218065617-Supported-touchscreens) for further discussion and a list of touchscreen models that have been tested with BrightSign players.

## Debugging Webpages

### Web Inspector

You can use the [Web Inspector](https://trac.webkit.org/wiki/WebInspector) to debug webpages over the local network.

> [!NOTE]
> The JavaScript console should only be used in non-production presentations and it should be disabled before you publish in a production environment because it uses more memory, which can lead to frequent reboots, and it compromises security.

#### Enabling the Web Inspector

The Web Inspector can be enabled using BrightAuthor:connected, BrightAuthor, or BrightScript:

*   **BrightAuthor:connected**: Select **Allow JavaScript console** in the [**Chromium Debugging**](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/404620688/Remote+Diagnostic+Web+Server#Diagnostics) section of the DWS and [**Enable Javascript console**](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/1632600407/HTML5+State) in **Presentation tab > State Properties > Options**. To disable Chromium debugging, uncheck either of these boxes.
    
*   **BrightAuthor**: In your BrightAuthor presentation, navigate to **File > Presentation Properties > HTML** and check the **Enable Javascript console** box. Note that as of BOS 8.5.31 you will need to also set the enable\_web\_inspector registry key (in the "html" section) to enable the JavaScript console. See the "inspector\_server" in [roHtmlWidget](../../developers/brightscript/object-reference/presentation-and-widget-objects/rohtmlwidget.md) for more information.
    
*   **BrightScript**: When creating the *roHtmlWidget* instance, include the [inspector\_server](../../developers/brightscript/object-reference/presentation-and-widget-objects/rohtmlwidget.md) initialization parameter and specify a port number. Note that as of BOS 8.5.31, you must set the `enable_web_inspector` registry key to “1” to enable the web inspector for Chromium on the player (if it is set to “0” or nothing, the web inspector is disabled). For example:
    

```
reg = CreateObject("roRegistrySection","html")
reg.Write("enable_web_inspector", "1")
reg.Flush()
```

If you want to change the web inspector port, you must edit the configuration of *roHtmlWidget*. See the "inspector\_server" in [roHtmlWidget](../../developers/brightscript/object-reference/presentation-and-widget-objects/rohtmlwidget.md) for more information.

> [!NOTE]
> Enabling the Web Inspector creates a security vulnerability on BrightSign players. See [this page](https://docs.brightsign.biz/display/DOC/BrightSign+Player+Security#BrightSignPlayerSecurity-advanced_topics) for more details.

#### Inspecting a Webpage

Once HTML content is running on a BrightSign player, follow these steps to inspect it:

1.  Open Chrome on a desktop computer connected to the same local network.
    
2.  Enter the following URL into the address bar: chrome://inspect/devices
    
3.  In the **Devices** section, click **Configure**.
    
4.  Enter the player IP address and Web Inspector port in the field (see the image below). The page(s) being run on the BrightSign player will be displayed at the bottom of the page.
    
    1.  If you don't know the player IP address, power on the player with the microSD card (and other storage devices) removed. After a few moments, the IP address will be displayed on screen.
        
    2.  If you enabled the Web Inspector in BrightAuthor, use port 2999 (e.g. [http://192.168.1.62:2999/](http://192.168.1.62:2999/)).
        
5.  Click the **Inspect** button next to a page. A debugging session will be launched in a new window. Unlike local pages, the page contents are not displayed in the left pane, but the inspector window on the right can be used to debug the page.
    

![](./attachments/Inspector.png)

> [!NOTE]
> Adding more than one device in your list can cause performance issues, especially if the devices are not online, because the Chrome client will continue to search for any offline devices.

#### Chromium Version Compatibility

Because BrightSign players use an older version of Chromium than recent desktop versions, newer desktop Chrome releases may not work with the Web Inspector. If you're having trouble using the Web Inspector with your version of Chrome, download and install one of these versions:

*   **Linux**: [https://www.googleapis.com/download/storage/v1/b/chromium-browser-snapshots/o/Linux\_x64/576753/chrome-linux.zip?generation=1532051976706023&alt=media](https://www.googleapis.com/download/storage/v1/b/chromium-browser-snapshots/o/Linux_x64%2F576753%2Fchrome-linux.zip?generation=1532051976706023&alt=media)
    
*   **OSX:** [https://www.googleapis.com/download/storage/v1/b/chromium-browser-snapshots/o/Mac/576753/chrome-mac.zip?generation=1532055270387578&alt=media](https://www.googleapis.com/download/storage/v1/b/chromium-browser-snapshots/o/Mac%2F576753%2Fchrome-mac.zip?generation=1532055270387578&alt=media)
    
*   **Windows 64-bit**: [https://www.googleapis.com/download/storage/v1/b/chromium-browser-snapshots/o/Win\_x64/576753/chrome-win32.zip?generation=1532053193483102&alt=media](https://www.googleapis.com/download/storage/v1/b/chromium-browser-snapshots/o/Win_x64%2F576753%2Fchrome-win32.zip?generation=1532053193483102&alt=media)
    

> [!NOTE]
> If you're using the Web Inspector to manually step through JavaScript code, encountering an uncaught error in the debugger may cause the player to crash. This is a known bug with the Web Inspector.

A larger collection of supported Chromium downloads can be found [here.](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/2303000608/Chromium+Downloads+for+Current+Older+OS+Versions)

### Trace Events

The Chromium TraceEvent system allows you to debug JavaScript memory leaks, performance issues, and rendering problems. This feature is available in firmware versions 7.0.82 and later. Unlike PCs, where the trace/debugger is run in the same browser as the content, BrightSign players write JSON trace files to the local storage, which you can then import to Chrome on your PC.

When trace events are enabled on a BrightSign player, Chromium captures trace messages to a circular buffer. The player takes regular snapshots of this buffer and writes them to the root directory of the microSD card or SSD as JSON files. 

> [!NOTE]
> The TraceEvent system can easily generate gigabytes of log data on local storage, so we recommend disabling it in production environments.

> [!NOTE]
> See this StackOverflow [page](https://stackoverflow.com/questions/12996129/memory-leak-when-logging-complex-objects) for more information about memory leaks when using console.log to log complex objects.

#### Creating a TraceEvent Directory

Before enabling the TraceEvent system, create a directory named "brightsign-webinspector" in the root directory of the microSD card or SSD on the player. If this directory is missing, the player will not record trace events when they are enabled in the registry. Conversely, you can disable trace events by deleting the "brightsign-webinspector" directory from the storage device.

#### Enabling the TraceEvent System

The TraceEvent system is enabled and configured by writing to the BrightSign player registry (via [BrightScript](../../developers/brightscript/object-reference/hashing-and-storage-objects/roregistry.md) or [JavaScript](../../developers/player-apis/javascript-apis/registry.md)). To enable the TraceEvent system, write the following keys to the `html` section of the registry:

*   `[string] tracecategories`: A comma-separated list of trace event categories to enable. The category names are documented in the link below.
    
*   `[int] tracemaxsnapshots`: The maximum number of JSON-trace snapshot files in the "brightsign-webinspector" directory. When the limit is reached, the counter wraps around and begins writing over the oldest trace file.
    
*   `[int] tracemonitorinterval`: The frequency (in seconds) with which the player will take snapshots of the TraceEvent buffer. We recommend 60 seconds as a default value.
    

##### Example (JavaScript):

```
var registryClass = require("@brightsign/registry");
var registry = new registryClass();
registry.write("html", {
    "tracecategories": "toplevel,blink_gc,disabled-by-default-memory-infra,disabled-by-default-blink_gc,disabled-by-default.skia.gpu.cache",
    "tracemaxsnapshots": "25",
    "tracemonitorinterval": "60"
}).then(
    function() {
        console.log("Write Successful");
    });
```

#### Viewing Trace Events

Follow these steps to view the trace events:

1.  Transfer the JSON trace files from the "brightsign-webinspector" directory to your PC.
    
2.  Open [chrome://tracing](#) on your PC Chromium instance.
    
3.  Import the JSON trace files.
    

You can merge multiple trace files; however, in a long trace capture, there will be too many trace events to view at once (you'll likely need to write a script to process them).

#### Additional Documentation

See the following links for further explanation of trace events:

*   [https://www.chromium.org/developers/how-tos/trace-event-profiling-tool](https://www.chromium.org/developers/how-tos/trace-event-profiling-tool)
    
*   [https://chromium.googlesource.com/chromium/src/+/lkcr/docs/memory-infra/README.md](https://chromium.googlesource.com/chromium/src/+/lkcr/docs/memory-infra/README.md)
    
*   [https://developers.google.com/web/tools/chrome-devtools/memory-problems/](https://developers.google.com/web/tools/chrome-devtools/memory-problems/)
    

## Disabling Staged ES6 Features

Some ES6 features have not been finalized and may still contain bugs in the Chromium version(s) used by BrightSign. A crash may occur if your JavaScript application (or the framework code used to build the application) uses one of these features: For example, [this](https://bugs.chromium.org/p/v8/issues/detail?id=3923) is a known issue in Chromium version 45 that will cause a crash on BrightSign XTx44 and XDx34 players. 

To bypass such issues, you can disable all staged (i.e. experimental) ES6 features using the `disable-javascript-harmony-shipping` registry flag (which requires firmware version 7.1.49 or later). The following example shows how to set this registry flag using the  [*registry*](../../developers/player-apis/javascript-apis/registry.md) JavaScript module (you can also use the  [*roRegistry*](../../developers/brightscript/object-reference/hashing-and-storage-objects/roregistry.md) BrightScript object).

```
var registryClass = require("@brightsign/registry");
var registry = new registryClass();


var systemClass = require("@brightsign/system");
var system = new systemClass();


registry.write("html", {js-disable-harmony-shipping:"1"}).then(
    function(){console.log("Write Successful");});


system.reboot()
```

Enabling this registry flag will limit the available JavaScript syntax. However, for ES6 features to be available, an application must be written to be compatible with both ES5 and ES6, so enabling this flag should not cause syntax errors or similar issues.
----
developers\developers\html-development\html-playback-options-on-series-5-players.md
# HTML Playback Options on Series 5 Players

There are two ways to playback HTML audio and video from Series 5 players:

*   On Series 5 and older players, video decode is handed off by default to the BrightSign application which deals with decode and display.
    

*   On Series 5 players, there is now an option to set a registry value to enable the built-in Chromium video player. The resulting Chromium plays back video similarly to desktop Chromium. Series 5 players will automatically use hardware-accelerated decode if the Chromium video player is enabled. This option is not available on Series 4 and earlier players, regardless of OS version. 
    

BrightSign video and audio features are only provided by the BrightSign video player, so if you chose to use Chrome, BrightSign [HTML video](../html-development/html-video.md) features will not be supported (it is like running Chrome in a browser on a PC). Chromium has much poorer streaming support than our application, and fewer hardware accelerated video decode levels and profiles are supported.

Only customers who do not want to take advantage of our unique capabilities should use native Chrome in their CMS.

To switch from the BrightSign video player to the Chrome Media Player:

```
registrySection = CreateObject("roRegistrySection", "html")
registrySection.Write("use-brightsign-media-player", "0") ' to switch to Chromium for media playback
```

To switch from the Chrome Media Player to the BrightSign video player:

```
registrySection = CreateObject("roRegistrySection", "html")
registrySection.Delete("use-brightsign-media-player") ' to switch to back to the default (BrightSign) for media playback
```

or:

```
registrySection = CreateObject("roRegistrySection", "html")
registrySection.Write("use-brightsign-media-player", "1") ' to switch to back to BrightSign for media playback
```
----
developers\developers\html-development\html-video.md
# HTML Video

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Table of Contents

*   [Streaming Video](#streaming-video)
    *   [Streaming Parameters](#streaming-parameters)
    *   [YouTube](#youtube)
    *   [Media Source Extensions](#media-source-extensions)
    *   [HLS Live Streaming](#hls-live-streaming)
*   [HDMI Input](#hdmi-input)
*   [Multiple Video Elements](#multiple-video-elements)
*   [Small Videos](#small-videos)
*   [View Mode](#view-mode)
*   [HWZ Video](#hwz-video)
    *   [Z-Ordering HWZ Video](#z-ordering-hwz-video)
    *   [Transforming HWZ Video](#transforming-hwz-video)
    *   [Fading HWZ Video Streams](#fading-hwz-video-streams)
    *   [HWZ Video Transparency Extensions](#hwz-video-transparency-extensions)
    *   [How Video Decoders are Selected for Playback](#how-video-decoders-are-selected-for-playback)
*   [Video Decryption](#video-decryption)
*   [Video Stream Parsing](#video-stream-parsing)
    *   [Video Streams](#video-streams)
    *   [Audio Streams](#audio-streams)
    *   [Subtitle and Caption Streams](#subtitle-and-caption-streams)
    *   [Pattern Matching Behavior](#pattern-matching-behavior)
    *   [Further Examples](#further-examples)
*   [Video Track Switching](#video-track-switching)
*   [Audio Routing <audio>/<video> Elements](#audio-routing-audiovideo-elements)
*   [HTML Video Timecode Playback](#html-video-timecode-playback)
*   [Chroma Keying](#chroma-keying)

> [!NOTE]
> The documentation below applies to firmware versions 7.1.x and later.

You can use `<video>` elements to play streaming video (HLS, UDP, RTP, RTSP) and local video files. You can also display HDMI® input on the XD1230, XD1132, 4K1142, or XT1143 (and RF Input on the XD1230). 

## Streaming Video

Streaming video playback is achieved using the standard HTML <video> element with an appropriate *src* attribute.  These URL schemes can be used for playback:

*   http/https
    
*   udp
    
*   rtp
    
*   rtsp
    

Note that pause/resume commands currently work for HLS streams only.

### Streaming Parameters

You can configure streaming video using a number of unique BrightSign attributes.  These attributes can be overridden by parameters that are [included in the streaming URL](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/2340651034/Customize+Network+Streaming#Customize-the-Streaming-Buffer-Size).

**Example (HTML)**

```
<video src="udp://239.192.1.1:5004" x-bs-stream-timeout="0">
```

**Example (JavaScript)**

```
videoPlayer.setAttribute("x-bs-stream-low-latency", "1"); 
```

The following streaming parameters are supported:

*   `[int] x-bs-stream-timeout`: The length of time (in milliseconds) to wait for a stream to start before abandoning playback. Passing zero indicates that the video player should wait indefinitely. The default timeout value is 5000ms for HTTP streams and 3000ms for all other streams.
    
*   `[int] x-bs-stream-latency`: The amount of deviation (in milliseconds) from the default latency value: For example, a value of -500 will reduce the latency by half a second; a 500 value will increase the latency by half a second; and a 0 value will specify the default latency. Specifying a negative value will not change the buffer size; instead, it will give the buffer less time to fill up before playback begins. Usable values extend to approximately -750, though this value may differ depending on the network environment. Reducing the latency too much will result in obvious playback stutter.
    
*   `[int] x-bs-stream-fade-in`: The fade-in length (in milliseconds) for streams. By default, non-HTTP streams have a fade value of 1500ms if they contain video and 4000ms if they contain audio only. HTTP streams have a default fade value of 0ms.
    
*   `[int or boolean] x-bs-stream-low-latency`: Low-latency mode for RTSP streams. Setting this parameter to `true` (1) will achieve the lowest possible latency for a stream, but at a reduced maximum bitrate–which is often useful for IP camera streams. This parameter is set to `false` (0) by default.
    
*   `[int] x-bs-intrinsic-width`: The intrinsic width of the source video
    
*   `[int] x-bs-intrinsic-height`: The intrinsic height of the source video.
    

#### Achieving Low Latency

There are three options to reduce latency on Series 3 and 4 BrightSign players:

##### x-bs-stream-latency

The `x-bs-stream-latency` flag (buffer) described above under "Streaming Parameters". In this example, the latency is reduced by half a second (500 milliseconds):

```
<video src="udp://239.192.1.1:5004" x-bs-stream-latency="-500">
```

##### x-bs-no-force-capture

If the `x-bs-no-force-capture` flag is set to `true`, video capture will bypass frame-rate conversion and introduce the following limitations:

*   Transform values other than "identity" will not work.
    
*   Screenshots may not be correct
    
*   The encoded video frame rate and the video mode output must match
    

For example:

```
<video src="udp://239.192.1.1:5004" x-bs-no-force-capture="1">
```

##### x-bs-no-reordering

If the `x-bs-no-reordering` flag is set, it will Improve latency but disable playback of B-slices. For example:

```
<video src="udp://239.192.1.1:5004" x-bs-no-reordering="1">
```

See [this page](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/2340651034/Customize+Network+Streaming) for more information about modifying the latency of audio or video streams.

#### Native Chrome Media Player

Series 5 players support selecting native Chrome for video playback with hardware acceleration or using the default BrightSign Media Player for video playback. You can pick which option is best for your use case (see [HTML Playback Options on Series 5 Players](../html-development/html-playback-options-on-series-5-players.md)).

##### WebRTC

For WebRTC, BrightSign OS always uses native Chrome video playback.

Series 5 players, running OS 9.0.115 and later, will automatically use hardware-accelerated decode in this case.

Series 4 and older players do not support hardware-accelerated decode with native Chrome video playback. As such, the decode will be done in software, and we only recommend trying this approach with XT4 players.

#### Intrinsic Video Size

The following order of precedence is used to determine the intrinsic size of a video:

1.  The `x-bs-intrinsic-width` and `x-bs-intrinsic-height` attributes
    
2.  The size of the image specified by the `poster` attribute
    
3.  The `width` and `height` attributes of the `<video>` element
    
4.  The size as reported by the WebMediaPlayer
    
5.  The CSS default size, as defined by [W3C](https://www.w3.org/TR/2011/WD-html5-20110113/video.html): 300x150
    

If only the `width` and `height` attributes of a `<video>` element are specified, the rendering engine assumes that the intrinsic size of the source video is the same as the `<video>` element size, so it will scale the video to fill the video element, ignoring the aspect ratio of the source video if necessary. Additionally, if the `width` and `height` attributes of a `<video>` are not specified and the size is not available from the sources (for example, if the stream is still loading), the video will initially default to a resolution of 300x150.

If you know the size or aspect ratio of a source video beforehand, you can use the `x-bs-intrinsic-width`/`x-bs-intrinsic-height` attributes to ensure the aspect ratio of the source video is maintained when scaled to fit a `<video>` element: For example, if the video window is oriented as portrait HD (`width=1080, height=1920`), specifying an intrinsic width and height of 1920x1080 ensures that landscape HD videos will scale to fit while maintaining their aspect ratio and letter-boxing appropriately. Likewise, videos will scale to the intrinsic width/height immediately if the `<video>` element lacks `width` and `height` parameters, rather than possibly defaulting to 300x150 for a short time

### YouTube

BrightSign players support YouTube videos and playlists.

### Media Source Extensions

As of OS 8.3, Media Source Extension (MSE) is enabled automatically on Series 4 players. However, it can still be disabled by setting the mse-support flag to 0 in the registry.

MSE support is available for series 3 but it must be specifically enabled. To do this, enter the following code at the BrightSign prompt:

```
registry write html mse-support 1
```

### HLS Live Streaming

BrightSign players support HLS live streaming, but large playlists (which usually result from the server delivering a DVR playlist rather than a LIVE playlist) will cause performance issues.

## HDMI Input

You must input the video source using the following URI: “tv:brightsign.biz/hdmi”. Note that you *cannot* substitute another host URL for “brightsign.biz”.

**Example**

```
<video width="320" height="240">
       <source src="tv:brightsign.biz/hdmi">
</video>
```

## Multiple Video Elements

By default, XT, 4K, and XD players support a maximum of two active `<video>` elements at any time (HD/LS models only support one). You can have more than this amount of `<video>` elements on a page as long as additional `<video>` elements have their `src` attribute set to an empty string. By modifying the `src` string, you can enable and disable `<video>` elements on the page.

You can enable Mosiac Mode (using the [SetDecoderMode()](../../developers/player-apis/brightscript-javascript-objects/bsvideomode.md) JavaScript method) to increase the minimum allowed number of `<video>` elements.

## Small Videos

BrightSign players do not support videos that are less than 64 pixels in width or height. However, a video can be scaled down beyond this limit by making the `<video>` element smaller than 64x64. To get the desired downscaling behavior, ensure that the `<video>` element does not have the `viewmode="scale-to-fill-and-crop"` attribute.

## View Mode

In firmware versions 7.0.x and later, HWZ video scales to fit the aspect ratio of a `<video>` element (i.e. `"scale-to-fill"`). In earlier versions of firmware, `<video>` elements maintain the aspect ratio of the source video (i.e. `"scale-to-fit"`). This default behavior can be modified using the `viewmode` attribute; however, we now recommend using standard CSS methods (e.g. `object-fit`) to modify the view mode behavior of a `<video>` element.

*   `viewmode="scale-to-fill"`: Scales the video to fill the window. The aspect ratio of the source video is ignored, so the video may appear stretched.
    
*   `viewmode="scale-to-fit"`: Letterboxes the video.
    
*   `viewmode="scale-to-fill-and-crop"`: Scales the video to fill the window. The aspect ratio of the source video is maintained, so the video may be cropped.
    

## HWZ Video

HTML `<video>` elements can have an optional “hwz” attribute, which is disabled by default. With hwz disabled, video frames are decoded by the dedicated hardware but are routed to the GPU for display. With hwz enabled, video frames are instead routed directly to the hardware compositor, bypassing the GPU. The choice of whether to enable hwz or not depends on the application and there is no single and obviously right answer. Some considerations are:

*   The GPU is limited to 8-bit color depth. If 10-bit video is in use, it must be routed to the hardware video plane in order to retain the full color depth.
    
*   In most cases, the GPU is limited to full-HD resolutions. If 4K video is in use, it must be routed to the hardware video plane to avoid loss of resolution. (Even on platforms which can be configured to support 4K graphics, it is unlikely that the GPU will achieve a high enough frame rate for full-motion video playback.)
    
*   The hardware video compositor can perform simple scaling and alpha-blending but does not support arbitrary CSS transforms. Video with complex CSS styling must be routed through the GPU in order to display correctly.  Likewise, any video which needs to be captured as a canvas for WebGL processing must be routed to the GPU. We recommend testing a manipulated hwz video thoroughly before using it in a production environment.
    
*   If video is routed to the GPU, a graphics repaint is required for every frame. This consumes a large amount of system bandwidth and may result in stuttery playback if the GPU is not able to keep up with the required frame rate at all times.
    

In general, we recommend routing video to the hardware compositor unless there is a specific need for processing by the GPU. For most applications, routing video to the hardware compositor can be achieved by setting hwz="z-index:-1" on the video element in question.  This causes the compositor to stack the video and graphics layers according to the CSS z-index property.

You can also enable hwz for all videos in an HTML widget using one of the following methods:

*   **BrightAuthor:connected**: Select the **Enable native video playback** box in the [HTML5 State](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/1632600407/HTML5+State).
    
*   **BrightAuthor**: Check the **Enable native video plane playback** box in the [HTML5 state](https://docs.brightsign.biz/display/DOC/HTML5).
    
*   **BrightScript**: Call `SetHWZDefault("on")` on the [*roHtmlWidget*](https://docs.brightsign.biz/display/DOC/roHtmlWidget) instance.
    

### Z-Ordering HWZ Video

If two video elements are to be routed to the hardware compositor, one of them should be given hwz="z-index:-2".  The one with the lower (more negative) z-index will be stacked behind the other. (Note that in this specific instance the CSS stacking order is overridden.)  Alternatively, it is possible to pass a positive z-index value in the hwz attribute. If this is done, the video elements will be stacked in front of the graphics layer, again overriding the CSS stacking order, and the one with the higher positive value z-index will be in front.

To route video playback to the GPU, pass hwz="off" or hwz="z-index:0" (these are equivalent). The legacy value hwz="on" is equivalent to hwz="z-index:1" and should be avoided.

You can use the CSS z-index property to layer the elements without enabling hwz. The layer order shown below is text on top → video in the middle→ image in the back:

```
<body style="background-color:blue">
  <div style="position:absolute;color:red;font-size:100px;z-index:-1" > Hello BrightSign </div>
  <img src="poster.png" style="position:absolute;left:0px;top:0px;width:800px;height:800px;z-index:-3"></img>
  <video src="coffee2.mp4" style="position:absolute;left:0px;top:0px;width:480px;height:320px;z-index: -2;" autoplay loop muted></video>
</body>
```

If hwz is enabled, your CSS z-index property (`style="z-index:-1")` will be overridden. Add a z-index value in the hwz attribute to maintain the correct z-ordering positions for all elements:

```
<body style="background-color:blue">
  <div style="position:absolute;z-index:-1;color: red;font-size: 100px;" hwz="z-index:-1"> Hello World </div>
  <img src="poster.png" style="position:absolute;left:0px;top:0px;width:800px;height:800px;z-index:-3" hwz="z-index:-3"></img>
  <video src="coffee2.mp4" style="position:absolute;left:0px;top:0px;width:480px;height:320px;z-index: -2;" hwz="z-index:-2" autoplay loop muted></video>
</body>
```

### Transforming HWZ Video

You can add the optional "transform" parameter to the "hwz" attribute to rotate or mirror the `<video>` element. The `z-index:` parameter must also be specified for the transform to work. The "transform" parameter can be assigned the following values:

*   `identity`: No transformation (default behavior)
    
*   `rot90`: 90 degree clockwise rotation
    
*   `rot180`: 180 degree rotation
    
*   `rot270`: 270 degree clockwise rotation
    
*   `mirror`: Horizontal mirror transformation
    
*   `mirror_rot90`: Mirrored 90 degree clockwise rotation
    
*   `mirror_rot180`: Mirrored 180 degree clockwise rotation
    
*   `mirror_rot270`: Mirrored 270 degree clockwise rotation
    

> [!NOTE]
> Multiple HWZ video tag extensions are separated with a semicolon. A semicolon should also be appended to the final parameter.

**Example**

```
 // Video rotated 180 degrees and behind graphics layer.
<video src="example_movie.mp4" hwz="z-index:-1; transform:rot180;">
```

### Fading HWZ Video Streams

The "fade" parameter allows you to control the fading behavior between streaming videos in a `<video>` element (this setting does not apply to local video). The "fade" parameter allows you to control the fading behavior between decoded videos in a <video> element (this setting does not apply to HDMI in). It does not affect audio and will operate independently of [StreamFadeIn](https://docs.brightsign.biz/display/DOC/roVideoPlayer#roVideoPlayer-PlayFile(parametersAsroAssociativeArray)AsBooleanplayfile).

The "fade" parameter accepts the following values:

*   `auto`: If the video player is currently not showing anything (i.e. it hasn't played anything yet or the previous loaded video was cleared), the next video will fade in. If the video player is currently playing video, is paused, or is stopped without being cleared, the next video will not fade in. This is the default behavior.
    
*   `always` : When a video ends, the video window will go black. The new video will then fade in.
    
*   `never`: Videos transition without fade effects. 
    

### HWZ Video Transparency Extensions

If "hwz" is enabled for a `<video>` element, the video window can also support luma and chroma keys for video transparency. The `z-index:` parameter must also be specified for transparency to work. The luma and chroma keys are specified as follows: 

*   `luma-key:[HEX_VALUE]` 
    
*   `cr-key:[HEX_VALUE]` 
    
*   `cb-key:[HEX_VALUE]`  
    

**Example**

This is an example of a video on video layer, in front of graphics layer, with luma-keyed video:

```
<video src="example_movie.mp4" hwz="z-index:1; luma-key:#ff0020;">
```

### How Video Decoders are Selected for Playback

The system software selects which video decoder to use based on the resolution probed from the video file. In standard mode, it will attempt to select the decoder that has the closest maximum supported resolution (i.e. 1920x1080 for the HD decoder and 3840x2160 for the 4K decoder), without exceeding that maximum resolution. If a decoder has been configured for Mosaic mode, it will match the video resolution against the specified `timeslice_mode` instead. If both decoders support the same maximum resolution, you can select a decoder by matching the z-order of the *roVideoPlayer* instance (set using the `ToFront()` and `ToBack()` methods) with the z-order of the decoder (set using the *roVideoMode.SetDecoderMode()* method).

You can also select the decoder manually. First, configure the decoder(s) using the *roVideoMode.SetDecoderMode()* method. Then, use the `friendly_name` specified when calling the method to designate a decoder to use for video playback.

To select a decoder in BrightScript, pass an associative array to the *roVideoPlayer.PlayFile()* method containing the `decoder:[friendly_name]` parameter:

`PlayFile({filename:"text_1.mov", decoder:"main-video"})`

To select a decoder for HTML video, include the `decoder:[friendly_name]` property with the `hwz` attribute:

`<video` `hwz="decoder:main-video;"> </video>`  
`<video` `hwz="decoder:sd-video;"> </video>`

  
The `max_usage` of a decoder determines how many video players can be assigned to the decoder using the system software algorithm described above—video players beyond the  `max_usage` limit may be assigned to another decoder or not displayed at all. On the other hand, if you manually assign video players using the `friendly_name` of the decoder, you can assign more video players to the decoder than the `max_usage` limit, but this may cause unpredictable video-display behavior.

## Video Decryption

The HTML `<video>` tag can be used to decrypt video files and IP streams. Streaming decryption is currently only supported with the UDP protocol and the HTTP protocol (when HTTP is paired with an MPEG2 transport stream). If using a UDP multicast MPEG2 transport stream, one of the elemental streams should provide the PCR to the player.

The `<video>` tag supports the `EncryptionAlgorithm` and `EncryptionKey` methods:

*   `EncryptionAlgorithm`: The file-encryption algorithm. The following are the current options:
    
    *   "AesCtr": The AES algorithm in CTR mode
        
    *   "AesCtrHmac": The AES algorithm in CTR mode with HMAC
        
    *   "TsAesEcb": The AES algorithm in ECB mode (e.g. with a Harmonic Prostream). This algorithm is currently used for streaming encryption/decryption.
        
    *   "TsAesCbcRbt": The AES algorithm in CBC mode with residual block termination. This algorithm is used for streaming encryption/decryption.
        
*   `EncryptionKey`: A byte array consisting of 128 bits of key. If the encryption algorithm is AES-CTR or AES-CTR-HMAC, this is followed by 128 bits of IV.
    

**Example (HTML)**

```
<video src="udp://239.192.1.59:5000" EncryptionAlgorithm="TsAesEcb" EncryptionKey="01030507090b0d0f00020406080a0c0e">
```

> [!NOTE]
> The video player no longer accepts "{A|A}" AES encryption keys (i.e. where the top and bottom 64 bits of the key are identical).

**Example (JavaScript)**

```
var player = document.getElementById("my_video_player");
player.setAttribute("EncryptionAlgorithm", "TsAesEcb");
player.setAttribute("EncryptionKey", "01030507090b0d0f00020406080a0c0e");
```

## Video Stream Parsing

The following optional attributes can be included in an HTML `<video>` tag: "preferredvideo", "preferredaudio", and "preferredcaptions". If multiple video, audio, or data streams are encapsulated in the video input, these attributes allow you to determine which stream to use. For example, if a video may contain English and Spanish audio tracks, you can use the "preferredaudio" attribute to specify that the Spanish track should be played if it exists, with the video defaulting to English otherwise.

Preferred streams are chosen by matching the supplied text patterns against the textual description of the stream:

1.  Each attribute ("preferredvideo", "preferredaudio", or "preferredcaptions") is a semicolon-separated list of templates.
    
2.  Each template is a comma-separated list of patterns.
    
3.  Each pattern is a `[field_name]=[field_value]` pair that is matched directly against the stream description.
    

### Video Streams

Each template in a "preferredvideo" attribute can contain the following patterns:

*   `pid=[integer]`: The packet identifier (PID) of the video stream you wish to display
    
*   `program=[integer]`: The program number of the video stream
    
*   `codec=[video_codec]`: The preferred video codec, which can be any of the following:
    
    *   `MPEG1`
        
    *   `MPEG2`
        
    *   `MPEG4Part2`
        
    *   `H263`
        
    *   `H264`
        
    *   `VC1`
        
    *   `H265`
        
*   `width=[integer]`: The preferred video width
    
*   `height=[integer]`: The preferred video height
    
*   `aspect=[float(x.yy)]`: The preferred aspect ratio of the video stream as a floating-point number with two fractional digits.
    
*   `colordepth=[integer]`: The preferred color depth of the video.
    

**Example**

```
preferredvideo="pid=7680, codec=H264, width=1280, height=720, aspect=1.78, colordepth=8;;"
```

### Audio Streams

Each template in a "preferredaudio" attribute can contain the following patterns:

*   `pid=[integer]`: The packet identifier (PID) of the audio stream you wish to play
    
*   `program=[integer]`: The program number of the audio stream
    
*   `codec=[audio_codec]`: The preferred audio codec, which can be any of the following:
    
    *   `MPEG`
        
    *   `MP3`
        
    *   `AAC`
        
    *   `AAC-PLUS`
        
    *   `AC3`
        
    *   `AC3-PLUS`
        
    *   `DTS`
        
    *   `PCM`
        
    *   `FLAC`
        
    *   `Vorbis`
        
*   `channels=[integer]`: The preferred number of audio channels (from 1 to 8)
    
*   `freq=[frequency]`: The preferred sample frequency of the audio track, which can be any of the following:
    
    *   `32000`
        
    *   `44100`
        
    *   `48000`
        
*   `lang=[language]`: A code that determines the preferred language of the audio track (e.g. `eng`, `spa`). The language codes are specified in the ISO 639-2 standard.
    
*   `type=[audio_type]`: The preferred audio type, which can be one of the following:
    
    *   `Main audio`
        
    *   `Clean effects`
        
    *   `Hearing impaired`
        
    *   `Visual impaired commentary`
        

**Example**

```
preferredaudio="pid=4192, codec=AC3, channels=5, freq=48000, lang=eng, type=Main audio;;"
```

### Subtitle and Caption Streams

Each template in a "preferredcaption" attribute can contain the following patterns:

*   `pid=[integer]`: The packet identifier (PID) of the caption stream you wish to play
    
*   `type=[subtitle_type]`: The encoding standard of the subtitles. This value can be one of the following:
    
    *   `CEA708`: If the CEA-708 standard is not present, the subtitle\_type will default to CEA-608 (if it is present).
        
    *   `CEA608`
        
    *   `DVB`
        
*   `lang=[language]`: A code that determines the preferred language of the subtitles (e.g. `eng`, `spa`). The language codes are specified in the ISO 639-2 standard.
    
*   `service=[integer]`: The preferred service number of the caption stream
    

**Example**

```
preferredcaptions="pid=0, type=Cea708, lang=eng service=1;;"
```

> [!NOTE]
> Subtitles and captions are rendered on the graphics layer, and `hwz` must be set to `z-index -1` or `z-index -2` to place the video behind the graphics. Otherwise the subtitles and/or captions will be covered by the video.

### Pattern Matching Behavior

Note the following when matching templates to stream descriptions:

*   For a template to match a stream description, every pattern within the template must match.
    
*   The first listed template to match the stream description (if any) will be used.
    
*   An empty template string will match any stream description.
    
*   All value comparisons are case-insensitive.
    
*   Numerical values must match the stream description exactly (without leading zeroes). For example, the pattern `pid=016` will never match the stream PID value of 16.
    
*   To indicate logical negation, apply the "!" exclamation mark to the beginning of a pattern. For example, specifying `preferredvideo="!codec=H265"` will match only streams that are not encoded using H.265.
    
*   Apply the ">" greater-than symbol before an integer to indicate that, for a successful match, the value in the stream description must be *greater than* the value following the symbol. For example, specifying `preferredvideo="width=<1921,height=<1081"` will match only videos that are no larger than full-HD.
    
*   Apply the "<" less-than symbol before an integer to indicate that, for a successful match, the value in the stream description must be *less than* the value following the symbol.
    

### Further Examples

The following template list contains three patterns: `lang=eng`, `lang=spa`, and an empty string. The first pattern specifies an English language channel; if the English channel does not exist, the second pattern specifies a Spanish language channel. The third pattern specifies any other channel if the first two don't exist (the empty string matches anything).

```
preferredaudio="lang=eng;lang=spa;;"
```

Since the following template list is empty, no captions are specified. This can be used to disable captions altogether.

```
preferredcaptions=""
```

The following template list contains an empty string template. Since an empty template matches anything, the first video stream encountered will be played. This is the default behavior of all attributes.

```
preferredvideo=";"
```

The following template list specifies a 48KHz audio stream if there is one; otherwise, no audio stream will be played. Observe that the list is not terminated with a semicolon; in this case, the semi-colon is implicitly supplied.

```
preferredaudio="freq=48000"
```

The following template list contains two templates. Note that all patterns within a template must match the stream description for the entire template to match. In this example, an AAC-encoded English track is preferred; an MP3-encoded English track is designated as the second option; and any track will be chosen if neither template is matched.

```
preferredaudio="codec=aac,lang=eng;codec=mp3,lang=eng;;"
```

## Video Track Switching

The BrightSign media playback framework does not support dynamic switching among tracks via HTML5 video/audio. However, it does support querying track information using the [Tracklist API](https://www.w3.org/TR/html5/embedded-content-0.html#audiotracklist-and-videotracklist-objects). The following steps outline how to select tracks using this API.

1.  Create a video element in JavaScript that is not attached to the DOM (i.e. that is invisible).
    
2.  Set the `onloadedmetadata` event listener.
    
3.  Set the `src` of the media URL.
    
4.  Call `load()` on the HTML5 video element. This will trigger the `loadedmetadata` event.
    
5.  Read the track information from the event.
    
6.  Create a new HTML5 video player and use the track information to set the `preferredAudio`, `preferredVideo`, and `preferredSubtitle` parameters (described above).
    
7.  Call `load()`/`play()` on the video element.
    
8.  Append the video element to the DOM.
    

> [!NOTE]
> When switching from one video to another, it is important to set the video source to be blank to release the video element, otherwise the first video(s) will continue to use memory while subsequent videos are playing. See line 12 in the code example below.

**Example**

```
<!DOCTYPE html>
<head>
  <script>
var video;

function playTrackNext()
{
  // Switch to audio/video 1
  var pid = video.videoTracks[1].id;
  var audiopid = video.audioTracks[1].id;
  // release the video element
  video.src = "";                            
  // create a new video element
  video = document.createElement('video');   
  video.src = "http://brightsign.biz/example.ts";
  video.hwz = "on";
  video.preferredvideo = "pid=" + pid;       
  // use the params we gathered from previous video load
  video.preferredaudio = "pid=" + audiopid;
  video.load();
  video.play();
  document.getElementById("videoarea").appendChild(video);
}


function runTest()
{
  // Initialize testing bs/javascript bridge.
  bs.start();
  // Initial load of media to gather track information
  video = document.createElement('video');
  video.onloadedmetadata = playTrackNext; // play track 0
  video.src = "http://brightsign.biz/example.ts";
  video.hwz = "on";
  video.load(); // will trigger loadedmetadata event once the video is loaded.
}
  </script>
</head>
<html>
  <body bgcolor="#E6E6FA" onload="runTest()">
    <h1>Video Audio Tracks Test Page</h1>
    <div id="videoarea"></div>
</html>
```

## Audio Routing <audio>/<video> Elements

BrightSign players have unique audio attributes for `<audio>/<video>` elements. These allow you to control how the audio is routed through the player outputs:

*   `Pcmaudio`: PCM audio
    
*   `Compaudio`: Compressed audio
    
*   `Multiaudio`: Multi-channel audio
    

Each attribute can be passed the following values, which determine where the audio will be routed:

*   `“none”`
    
*   `"hdmi”` or `"hdmi-1"`, `"hdmi-2"`, `"hdmi-3"`, or `"hdmi-4`" for Series 5 players with multiple outputs
    
*   `“usb”`
    
*   `“spdif”`
    
*   `"analog"`
    
*   `“analog:N”` (N specifies the port enumeration, which is useful for models with multiple analog-audio ports; you can also use `"analog:1"` to specify the analog output on a model with a single analog-audio port)
    

> [!NOTE]
> If you don’t assign any audio attributes to an `<audio>/<video>` element, then the audio will be routed to all audio outputs, along with any other audio that is currently playing.

**Example 1**

```
<video src="example_movie.mp4" width="512" height="400" pcmaudio="hdmi" autoplay>
  Your browser does not support the video tag.
</video>
```

**Example 2**

```
<video src="example_movie.mp4" width="512" height="400" compaudio="hdmi;usb"autoplay>
  Your browser does not support the video tag.
</video>
```

## HTML Video Timecode Playback

BrightSign precision for HTML video timecode playback is 200ms.

## Chroma Keying

BrightSign chroma key settings consist of a mask, and a minimum and maximum value. The minimum and maximum are the most important values since the mask is really only useful for “special effects”. Each pixel of every frame is checked to see if it is between the minimum and maximum values and if it is, the pixel is set to fully transparent. If it is outside the range, the pixel is fully opaque. This means you will have a hard edge, not a gradual fade, where the video goes from opaque to transparent.

#### Chroma Key Tips

*   To get better chroma keying, do not anti-alias any pixels that should be transparent. You will then be able to target a single transparency color rather than a range.
    
*   If your video is compressed, the chroma is sub-sampled, so there will be edges where the chroma will end up as an intermediate value between green and the frame color. CGI animations with green holes often have anti-aliasing which will result in a fade of green around edges. You may be able to chroma keyed out these edges with the values shown in the examples below (in these examples, v is an [roVideoPlayer](../../developers/brightscript/object-reference/presentation-and-widget-objects/rovideoplayer.md) object).
    
*   The easiest color to remove from content is black which has a luma value of 0, because the video has sub-sampled chroma (4:2:0 rather than 4:4:4). Using luma keying means that every pixel can be accurately keyed.
    
*   White is luma 240 (it's not quite a full range 8 bit value), but the chroma can mean that it contains many other bright colors, so it's hard to just remove white.
    
*   Arbitrary colors are hard to deal with, as they involve specifying a small range of chroma values which must be calculated. The color to be removed has to be calculated in YCbCr, and the Cb and Cr values are used for the chroma keying. If the source is CGI then the range used can be very tight since a single color is made transparent. If the video source was live footage shot against a green screen, then the range needs to be much wider to accommodate the range of green colors in the video.
    

#### Examples

##### Lower Chroma Key Values

Here the Cr range is 0-32 and the Cb range is 0-48. This may leave a green halo around areas that were blended to give a smoother look since chroma keying can't do smooth transitions.

```
v.SetKeyingValue({cr:&hff2000, cb:&hff3000})
```

##### Higher Chroma Key Values

This example covers a much larger range of colors:

```
v.SetKeyingValue({cr:&hff7000, cb:&hff7000})  
```
----
developers\developers\html-development\known-issues.md
# Known Issues

BrightSign’s HTML5 rendering engine is a constant work-in-progress. The following are known issues that we are working to resolve in future versions of player firmware.

## Rotated 4K Output

Displaying an HTML page and rotated video while using a 4K output mode will cause the video to glitch. This is the case even if the video is not part of the HTML page (i.e. it's displayed and rotated using BrightScript).

## Localized JavaScript Time

The JavaScript `toLocaleTimeString()` call does not retrieve localized time formats (i.e. 24-hour vs. 12-hour clock): Instead, the hour/minute clock defaults to 24-hour time on the BrightSign player. The below code provides a workaround in JavaScript if you would like to display time using a 12-hour clock:

```
function format12Hour(date)
{
    var zero = '0';

    hh = date.getHours();
    mm = date.getMinutes();
    ss = date.getSeconds()

    if((hh % 12) == 0)
        hh = 12;

    else
        hh %= 12;

    // Pad zero values to 00
    hh = (zero+hh).slice(-2);
    mm = (zero+mm).slice(-2);
    ss = (zero+ss).slice(-2);

    return hh + ':' + mm + ':' + ss + ' ' + ((date.getHours() < 12) ? 'AM' : 'PM');
}
```

If you would prefer not to display seconds information, you can replace the above “return” line with the following:

```
return hh + ':' + mm + ' ' + ((date.getHours() < 12) ? 'AM' : 'PM');
```

Implement the function in the HTML script as follows:

```
var dateString = (startJSDate.getMonth() + 1) + "/" +
startJSDate.getDate();
    if (!startDateTime.isDateOnly()) {
      dateString += " -- " + format12Hour(startJSDate);
    }
```
----
developers\developers\html-development\nodejs-versions.md
# Node.js Versions

As of BrightSignOS 8.2, two versions of Node are shipped with the player:

*   A Node.js version that is integrated into Chromium
    
*   The standalone Node.js that is used by [roNodeJs](https://docs.brightsign.biz/display/DOC/roNodeJs) and similar objects
    

The version numbers of these are not identical although BrightSign tries to ensure that they are at least the same major version.

Note that the embedded Node.js is associated with [roHtmlWidget](../../developers/brightscript/object-reference/presentation-and-widget-objects/rohtmlwidget.md) and standalone Node.js is associated with [roNodeJs](../../developers/brightscript/object-reference/presentation-and-widget-objects/ronodejs.md).

## Determining Version Numbers

Inspecting `process.version` in each environment is the most reliable way to determine the exact version number for any given version of the OS. For standalone Node.js, enter `process.version` at the prompt:

```
BrightSign> node
> process.version
'v10.15.3'
> 
BrightSign>
```

  
For embedded Node.js, run a script to print the version number to the log and inspect the output (there is no way to type directly in the console):

```
BrightSign> htmlplay data:text/html,<script>console.log(process.version);</script>
BrightSign> log
[...]
<12>[173535.688] [INFO]   [source data:text/html,%3Cscript%3Econsole.log(process.version);%3C/script%3E:1]: v10.11.0 
BrightSign>
```

## OS/Chromium Version Compatibility

| BrightSignOS version | Chromium version | Embedded Node.js version | Standalone Node.js version |
| --- | --- | --- | --- |
| OS 7.1.x, 7.0.x | Chromium 45 | 5.1.1 | 5.1.1 |
| OS 8.0.x | Chromium 65 | 10.0.0 | 8.9.4 |
| OS 8.1.x, 8.2.x, 8.3.x | Chromium 69 | 10.11.0 | 10.15.3 |
| OS 8.5.x, OS 9.0.x | Chromium 87 | 14.17.6 | 14.17.6 |
----
developers\developers\html-development\nodejs.md
# Node.js

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Table of Contents

*   [BrightSign Node.js Implementation](#brightsign-nodejs-implementation)
*   [Enabling Node.js](#enabling-nodejs)
    *   [Cross-Domain Security](#cross-domain-security)
    *   [Web Storage](#web-storage)
    *   [JQuery](#jquery)
    *   [Node SerialPort](#node-serialport)
    *   [Reloading Node.js Enabled Web Applications](#reloading-nodejs-enabled-web-applications)
*   [Packaging and Delivering Node.js Applications](#packaging-and-delivering-nodejs-applications)
    *   [WebPack](#webpack)
*   [Device Storage Paths](#device-storage-paths)
*   [Debugging Applications](#debugging-applications)
*   [Downloading Large Files](#downloading-large-files)
*   [Node.js Examples](#nodejs-examples)

Our customers often need to communicate between applications on a BrightSign player, or between a BrightSign player and the outside world. This can be done using various protocols: HTTP, serial, and UDP are the most popular. You can write applications in either BrightScript or JavaScript to create this functionality. If you choose to write your application in JavaScript, you will need Node.js® to implement features such as hosting a web server in JavaScript.

BrightSign makes a Node.js endpoint available so that our partners can use Node.js modules and features. 

## BrightSign Node.js Implementation

BrightSign players support the Node.js runtime environment, which runs on the same V8 JavaScript engine used by Chromium. The Node.js® and Chromium instances share a single JavaScript execution context, so JavaScript applications can access both Node.js modules and DOM objects at the same time. BrightSign firmware pushes Node.js events to the Chromium event loop, ensuring that JavaScript applications receive Node.js and DOM events seamlessly.

The BrightSign Node.js implementation is based on the [NW.js](https://github.com/nwjs/nw.js) and [Electron](https://github.com/electron/electron) projects and shares many characteristics with them. Whereas Electron uses a JavaScript file as the entry point (i.e. the JavaScript file creates a webview, which also has access to the Node.js runtime), NW.js and BrightSign use an HTML file as the entry point: On a BrightSign player, BrightScript creates a Node.js-enabled *roHtmlWidget* instance; the initial URL, which is passed when *roHtmlWidget* is initialized, acts as the entry point for Node.js applications.

Like NW.js and Electron, BrightSign does not use sandboxing. Instead, it launches the render process with a Node.js user and storage group, which has write permissions for local storage and read permissions for the entire file system. It also can access networking interfaces and use privileged ports.  

![](./attachments/nodejs_combined_diagrams.png)

The integrated Node.js implementation in OS 8.2.x and OS 8.3.x is based on Node v10. For further documentation and usage information, consult the [Node.js 10.0.0 API documentation](https://nodejs.org/dist/v10.0.0/docs/api/). 

> [!NOTE]
> Node.js is not enabled for iframes or Web Workers.

## Enabling Node.js

Node.js object functionality is available in BrightAuthor:connected when users specify Node.js items in [Presentation Settings](https://docs.brightsign.biz/display/DOC/Presentation+Settings#PresentationSettings-Node.js). Node.js objects are not available in BrightAuthor.

Node.js is enabled for individual *roHtmlWidget* instances by including the `nodejs_enabled:true` entry in the [initialization parameters](../../developers/brightscript/object-reference/presentation-and-widget-objects/rohtmlwidget.md) of the *roHtmlWidget* object.

**Example:**

```
r=CreateObject("roRectangle", 0,0,1920,1080)
is = {
	port: 3000
}
config = {
	nodejs_enabled: true
	inspector_server: is
	brightsign_js_objects_enabled: true
	url: "file:///sd:/nodehello.html"
}
h=CreateObject("roHtmlWidget", r, config)
h.Show()
```

> [!WARNING]
> We do not recommend loading arbitrary websites with Node.js enabled. Some JavaScript libraries assume that Node.js is running on an instance with server-side capabilities, and they will attempt to load dependencies, causing playback to fail.

> [!NOTE]
> If you are using a BrightAuthor plugin to enable Node.js, you will need to set other desired parameters in the plugin, rather than with an HTML5 state. For example, if you want to enable the mouse cursor, you will need to set `mouse_enabled:true` during the *roHtmlWidget* initialization, rather than checking the box in the HTML5 state.

### Cross-Domain Security

Chromium has default security measures for preventing cross-site scripting attacks: If the URL for the *roHtmlWidget* instance is a remote domain, JavaScript applications from that domain cannot make HTTP requests to other domains; on the other hand, if the URL points to local storage, requests to other, remote domains are acceptable.

If you want to reference other domains in remote applications, set the `websecurity` parameter to `false` when initalizing the *roHtmlWidget*, as shown below:

**Example:**

```
r=CreateObject("roRectangle", 0,0,1920,1080)
is = {
	port: 3000
}
config = {
	nodejs_enabled: true
	inspector_server: is
	brightsign_js_objects_enabled: true
	url: "http://www.mysitehere.com"
	security_params: {websecurity: false} 
}
h=CreateObject("roHtmlWidget", r, config)
h.Show()
```

### Web Storage

If you want to use JavaScript storage applications, you will need to specify a `storage_path` and `storage_quota` when initializaing the *roHtmlWidget*:

**Example:**

```
r=CreateObject("roRectangle", 0,0,1920,1080)
is = {
	port: 3000
}
config = {
	nodejs_enabled: true
	inspector_server: is
	brightsign_js_objects_enabled: true
	url: "file:///sd:/nodehello.html"
	storage_path: "SD:"
	storage_quota: 1073741824
}
h=CreateObject("roHtmlWidget", r, config)
h.Show()
```

### JQuery

JQuery® requires a workaround to operate correctly with Node.js (see [this page](https://stackoverflow.com/questions/4299363/how-to-use-jquery-selectors-in-node-js) for an example). This workaround requires modifying the content, so if you don't have control over the webpage enabling node in your HTML widget, this can cause an intractable problem. You should only enable Node.js if you are planning to use it (for example with our [JavaScript API](../../developers/player-apis/javascript-apis.md)s).

See also [HTML Best Practices](../html-development/html-best-practices.md).

### Node SerialPort

The BrightSign player provides JavaScript serial port bindings for the Node SerialPort package. These bindings can be used using with the *@brightsign/serialport* API:

```
const SerialPort = require('@serialport/stream');
const BrightSignBinding = require('@brightsign/serialport');
SerialPort.Binding = BrightSignBinding;
```

Also see our [reference implementation](https://github.com/brightsign/bs-node-serialport) on GitHub.

### Reloading Node.js Enabled Web Applications

Any customer application that uses *@brightsign* objects, and some of the "BS" objects, will throw a JavaScript exception when reloaded in BrightSignOS 8.0 to 8.4 (even though it may have worked in OS 7.x and earlier) due to limitations with native modules in Node 10. This problem will be fixed in OS 8.5 and above, which ships with Node 14.x. You can also disable Node.js (and *@brightsign* objects) if you don’t need it.

## Packaging and Delivering Node.js Applications

> [!WARNING]
> If you are using Electron/Chromium 110 or a later version, BrightSign no longer supports any BrightScript/JavaScript objects in iframes for security reasons. iframes requests should be sent to [parent](https://nam04.safelinks.protection.outlook.com/?url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FWindow%2Fparent&data=05%7C02%7Csmulqueen%40brightsign.biz%7Cc0b4df4b1a374212f14308dc95fa4ac2%7C8fbcdf641ab847cebdc743e23b04fb3c%7C0%7C0%7C638550149459230214%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C0%7C%7C%7C&sdata=%2BBc0ofFac7LaEWddOehvXi7WJyxDFMvLPhPV6YNKl1g%3D&reserved=0) and then the parent page should call BrightSign/JavaScript objects.

To deploy your Node.js application to a BrightSign player, run "npm install" on your computer. This will create the `node_modules` directory. Copy this directory to the SD card along with the rest of the application.

When initialized, the BrightSign Node.js implementation seeks to the `node_modules` directory relative to the loaded HTML file. Like a standard Node.js application, it then loads all modules contained in the `node_modules` directory.

> [!NOTE]
> The majority of Node.js modules contain JavaScript code only. However, some modules contain binary code. When a module containing binary parts is installed using "npm install", the binary parts are compiled for the local platform (usually Intel x64), and this code will not run on a BrightSign player. Currently, the BrightSign Node.js implementation is limited to JavaScript code only.

### WebPack

The *node\_modules* directory associated with a Node.js application may contain hundreds or thousands of unnecessary files. The [webpack](https://webpack.js.org/)® bundler allows you to reduce the *node\_modules* directory to a manageable size.

To use webpack®, you will need to place your Node.js entry-point function in a separate file (e.g. "index.js"), rather than as inline HTML. This file will contain the references to other JavaScript files and Node.js modules:

**Example index.js:**

```
var myutils = require('./utilities'); // My utilities.js
var moment = require('moment'); // A node module
 
function main() {
 
  myutils.foo();
  moment.now();
  //...
}
```

The JavaScript file containing the Node.js entry point can then be referenced in the HTML file:

**Example HTML:**

```
<script src='./index.js'></script>
```

To use webpack®, attach `main()` to the window object so that it can be found from the HTML file:

```
var myutils = require('./utilities'); // My utilities.js
var moment = require('moment'); // A node module
 
function main() {
 
  myutils.foo();
  moment.now();
  //...
}
window.main = main;
```

Change the HTML file so that it points to the bundled JavaScript and to `window.main()`:

```
<script src='./bundle.js'></script>
 
<body onload="window.main()">
```

To build your bundle, run the following npm steps on your computer:

```
npm i -D webpack webpack-cli
npx webpack --mode production
```

Now you can publish the index.html and bundle.js files; there's no need to publish the `node_modules` directory. See the sample webpack® configuration below for more information.

[webpack.config.js](./attachments/webpack.config.js)

## Device Storage Paths

To load Node.js modules and read/write files, you must first define the root directory of the device storage. The following are common root directories:

*   microSD: `"storage/sd/"`
    
*   SSD: `"storage/ssd/"`
    
*   USB: `"storage/usb1/"`
    

We recommend using the `process.chdir()` call at the beginning of the script to change the process path:

**Example:**

```
var process = require("process");
process.chdir("/storage/sd");
```

  
Alternatively, if you have modules located on multiple storage drives, you can append multiple search paths to a module:

**Example:**

```
module.paths.push("/storage/sd/")
module.paths.push("/storage/ssd/")
module.paths.push("/storage/usb1/")
```

## Debugging Applications

When Node.js modules are enabled, they become visible from the [Chromium remote inspector](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370672286/HTML+Best+Practices#Debugging-Webpages), allowing you to debug applications. The console.log works like a normal web application: Output is redirected to both stderr and the remote inspector.

## Downloading Large Files

If your application uses the XMLHttpRequest object to download a large file (100-200MB, depending on the player model), the player will run out of memory and the download operation will fail. The XMLHttpRequest object first downloads the whole file into memory, then creates a blob object of equal size, so memory requirements for a download are effectively double that of the file size.

For large-file downloads, we recommend using the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API), which has callbacks that are fired when fragments are downloaded. Data can be appended to the disk as it arrives, so the player won't run out of memory, no matter the file size. The "download-test" HTML/JavaScript example below uses the Fetch API and the Node.js File Service module to download a file in fragments.

[download-test.zip](./attachments/download-test.zip)

> [!NOTE]
> This example is specific to BrightSign players and requires node.js runtime, enabled by use of the *roHtmlWidget* `nodejs_enabled` flag, to write files to disk.

## Node.js Examples

GitHub contains a [Node.js-starter-project](https://github.com/brightsign/node.js-starter-project). This project was originally created for BrightAuthor but can also be used with BrightAuthor:connected.

Another example is the script below, which initializes an HTTP server on the BrightSign player at port 8000. When a client (for example, a desktop browser) connects to the server, it will send the model number and boot version of the player to the client. The script also displays the IP address of the connected client on the screen attached to the player. 

**Example:**

```
<html>
<script>
function displayMessage()
{
  // Load the http module to create an http server.
  var http = require('http');

  // Configure our HTTP server to respond with Hello World to all requests.
  var server = http.createServer(function (request, response) {
    var device_info = new BSDeviceInfo();
    response.writeHead(200, {"Content-Type": "text/plain"});
    response.end("Device Information:\n" + device_info.model + "\n" + device_info.bootVersion + "\n");
    var ip = request.connection.remoteAddress;
    document.getElementById("Ip").innerHTML+="Server responded to: "+ ip + "<br>";
    console.log("Server responded to request from " + ip);
  });

  // Listen on port 8000, IP defaults to 127.0.0.1
  server.listen(8000);

  // Display it on brightsign browser
  var os = require('os');
  var interfaces = os.networkInterfaces();
  var addresses = [];
  for (var k in interfaces) {
      for (var k2 in interfaces[k]) {
          var address = interfaces[k][k2];
          if (address.family === 'IPv4' && !address.internal) {
              addresses.push(address.address);
          }
      }
  }
  var message = "Server running at: " + addresses[0] + ":8000<br>";
  document.getElementById("Ip").innerHTML+= message;

  // Print message on console
  console.log(message);

}
</script>
<body style="background-color:red" onload="displayMessage()">
  <div id = "Ip" style="font-size:60px; text-align:center;">
  </div>
</body>
</html>
```

  
Built-in modules, such as "os" and "http", can be initialized using the `require()` method. If the `nodejs_enabled:true` entry is not included when initializing the *roHtmlWidget* object (as shown above), the `require()` method will not be available.
----
developers\developers\html-development.md
# HTML Development

BrightSign players feature the Chromium HTML rendering engine, allowing you to display local or remote HTML pages. You can use a single, full-screen page of HTML content as a presentation, or you can display HTML content within one or more BrightAuthor zones along with other multimedia content. This feature greatly increases your creative options when using BrightSign players.

The contained pages are not general-purpose instructions for writing HTML code or using HTML publishing software, but you can use these sections to get the most out of your HTML presentations and ensure that your HTML content works seamlessly with your BrightSign players.

See [this page](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/1348304996/HTML+Playback+Options+on+Series+5+Players+DOCS-1041+DOCS-1090) for more information about the new Chromium options on Series 5 players.

Reference implementation details can be found on [our GitHub repository](https://github.com/brightsign/bs-node-serialport).
----
developers\developers\local-and-remote-diagnostic-web-server-apis.md
# Local and Remote Diagnostic Web Server APIs

These APIs allow you to connect to individual BrightSign players. They are especially useful if there are many devices on the network so you can more quickly find and access players.

*   [Local DWS APIs](./local-and-remote-diagnostic-web-server-apis/local-dws-apis.md) let you access your players on a local network. These APIs give you information about the player, let you reboot the player, see the health of SD card, and access all of the functionality of the calls that underlie the DWS in the BrightAuthor:connected UI. The local DWS APIs include Presentation Autorun Server APIs, which are hosted by the presentation autorun, and can be accessed with authentication from the local DWS. Only BrightScript objects in the presentation autorun know how to respond to these requests. Local DWS APIs are local player APIs and are authenticated through a username and password, not an OAuth bearer token.
    

![Screenshot 2023-03-17 at 9.12.13 AM.png](./attachments/Screenshot%202023-03-17%20at%209.12.13%20AM.png)

*   The [Remote DWS APIs](./local-and-remote-diagnostic-web-server-apis/remote-dws-apis.md) are contained in the [WebSockets](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/388434938/WebSockets) APIs, which use the WebSocket connection to leverage legacy endpoints that would otherwise only be addressable via the local network. Once a connection is established, the BrightSign WebSockets server can send WebSockets messages to BrightSign players. Depending on the operation, the BrightSign player may return information to the BrightSign Websockets server, which will be relayed in the server REST response to the client application. 
    
    The Remote DWS APIs allow you to access your player through BSN.cloud (using the bearer token for bsn.cloud) as well as get information about the player, reboot the player, see the health of SD card, and access all of the functionality of the calls that underlie the DWS in the BrightAuthor:connected UI.
    

![WSAPI_v3.png](./attachments/WSAPI_v3.png)
----
developers\developers\player-apis\brightscript-javascript-objects\bsbtmanager.md
# BSBtManager

Use the *BSBtManager* object to discover whether any BLE adapters are present and to receive events (for example, when adapters are added or removed). It can also be used to retrieve and modify Bluetooth advertising.

## Attributes

The *BSBtManager* object has the following attribute:

`readonly attribute Array adapters`: A list of all available Bluetooth adapters. If this list is empty, there are no adapters present.

## Events

Use the `onBtEvent()` callback to receive events:

`"add-adapter"`: An adapter has been added. The value reports the name of the adapter.

`"startup-complete"`: The initial advertising list has been built. This event is sent after any initial "add-adapter" events. Applications should wait for this event before detecting a missing adapter.

`"remove-adapter"`: An adapter has been removed. The value reports the name of the adapter.

`"update-advertising"`: Bluetooth advertising has changed. The value identifies the source of the change (from "brightscript" or "javascript"). If your script maintains a variable containing the advertising list, this event indicates that it may need to be refreshed.

> [!NOTE]
> Since additional events may be added in the future, your script should have the capacity to handle unrecognized events.

### Example

`btm.onbtevent = function (ev) { console.log("Event " + ev.name + "; parameter " + ev.parameter); }`

## Methods

The *BSBtManager* object has the following methods:

`object GetCurrentAdvertising()`

Returns a *BSBtAdvertisementList* object containing current advertisement parameters.

`boolean StartAdvertising(in object advertisement_list)`

Begins sending BLE advertisements using the specified *BSBtAdvertisementList* object. Calling this method will replace all previous advertisements, including persistent advertisements, regardless of whether they were set from JavaScript or BrightScript. To preserve advertisements, retrieve the current *BSBtAdvertisementList* and make changes as needed before passing it to `StartAdvertising()`.

`StartAdvertising(new BSBtAdvertisementList())`

Stops all advertisements.

`void Close()`

Shuts down the instance, preventing it from further consuming resources. If this method is not called, garbage collection determines when the instance will be destroyed.

`BSBtAdvertisementList`

The *BSBtAdvertisementList* object is a container for *BSBtAdvertisement* objects. Elements can be added to the end of the list using `push()` or removed using `pop()`. Existing elements can be accessed with indexing.

`BSBtAdvertisement`

The *BSBtAdvertisement* object represents a single BLE advertisement. It supports advertising data in standard formats or arbitrary custom values. Standard format values can be initialized on construction using a dictionary, but advanced custom fields must be set on the object. Supported modes are described below.

### Beacon Format

This mode uses a simple beaconing format:

`mode:"beacon"` 

`beaconUUID`: A string representation of a UUID, which can be in 16-bit, 32-bit, or 128-bit format. A 16-bit UUID must be exactly four hex digits with no punctuation;  a 32-bit UUID must be exactly eight hex digits with no punctuation; and a 128-bit UUID must be punctuated exactly as follows: "cd7b6f81-f738-4cad-aebf-d2a2ea36d996".

`beaconMajor`: An integer specifying the 2-byte Major value (0 to 65535)

`beaconMinor`: An integer specifying the 2-byte Minor value (0 to 65535)

`beacon_level`:(optional) An 8-bit signed integer (-127 to 128) that corresponds to the measurement of the Tx power level (in dBm) at 1 meter. The default level is -60.

`beaconManufacturer`:(optional) A 2-byte integer value (0 to 65535) specifying the beacon manufacturer. The default value is 76 (&H4C).

`connectable`:(optional) A Boolean value indicating whether the advertisement should be connectable (for GATT or other services). Advertisements are non-connectable by default.

`persistent`:(optional) A Boolean value indicating whether the advertisement should persist after every reboot. Beacon advertisements are not persistent by default.

### Eddystone-URL Format

This mode uses the [Eddystone-URL](https://github.com/google/eddystone/tree/master/eddystone-url) format:

`mode:"eddystone-url"` 

`url`: The URL to encapsulate in the advertisement packet. If the URL is too long to fit in the packet, the StartAdvertising() call will return an AbortError exception that includes the description "Compressed URL is too long".

`tx_power`:(optional) An integer value specifying the Tx power level in dBm at 0 meters. The default value is -19, which corresponds to a level of -60dBm at 1 meter. The recommended calibration practice is to measure at 1 meter and add 41: For example, -65dBm RSSI leads to a value of -24.

`connectable`:(optional) A Boolean value indicating whether the advertisement should be connectable (for GATT or other services).  Advertisements are non-connectable by default.

`persistent`:(optional) A Boolean value indicating whether the advertisement should persist after every reboot. Eddystone-URL advertisements are not persistent by default.

### Eddystone-UID format

This mode uses the [Eddystone-UID](https://github.com/google/eddystone/tree/master/eddystone-uid) format:

`mode`:"eddystone-uid"

`nameSpace`: A 10-byte value expressed as 20 hexadecimal digits

`instance`: A 6-byte value expressed as 12 hexadecimal digits

`tx_power`:(optional) An integer value specifying the Tx power level in dBm at 0 meters. The default value is -19, which corresponds to a level of -60dBm at 1 meter. The recommended calibration practice is to measure at 1 meter and add 41: For example, -65dBm RSSI leads to a value of -24.

`connectable`:(optional) A Boolean value indicating whether the advertisement should be connectable (for GATT or other services).  Advertisements are non-connectable by default.

`persistent`:(optional) A Boolean value indicating whether the advertisement should persist after every reboot. Eddystone-URL advertisements are not persistent by default.

### Custom Format

This mode supports arbitrary custom data. Binary fields are specified as hexadecimal-encoded strings (e.g. the decimal values 12, 128 would be specified as "0C80"). All lists support `push()`/`pop()` calls and indexing. Duplicate values should not be included.

*   `mode:"custom"`
    
*   `manufacturerData`:(optional) A *BSBtManufacturerData* object containing the following fields:
    
    *   `manufacturer`: An unsigned 16-bit integer value
        
    *   `data`: Binary data
        
*   `serviceUUID`:(optional) A list of UUID strings.
    
*   `serviceData`:(optional) A *BSBtUUIDData* object containing the following fields:
    
    *   `uuid`: The UUID string
        
    *   `data`: Binary data
        
*   `soliciitUUID`:(optional) A list of UUID strings.
    
    *   connectable:(optional) A Boolean value indicating whether the advertisement should be connectable (for GATT or other services). Advertisements are non-connectable by default.
        
*   `persistent`:(optional) A Boolean value indicating whether the advertisement should persist after every reboot. Custom advertisements are not persistent by default.
    

## Examples

This script configures a simple advertisement and an Eddystone-URL advertisement and then begins advertising:

```
ads = new BSBtAdvertisementList();
ad1 = new BSBtAdvertisement({ mode: "beacon", beaconUUID: "41fac221-c8cb-41e7-b011-12d1016dd39e", beaconMajor: 400, beaconMinor: 123});
ads.push(ad1);
ad2 = new BSBtAdvertisement({ mode:"eddystone-url", url: "http://www.brightsign.biz"})
ads.push(ad2);

btm.StartAdvertising(ads);
```

This script finds beacons matching a UUID and forms a string with Major/Minor codes:

```
s = "";
for(i = 0; i < adList.length; i++) {
	if (adList[i].mode == "beacon"
		&& adList[i].beaconUUID == "434b2eb8-c28f-4089-8e7a-1e644bb13b9f") {
			s = s + "Beacon: " +  adList[i].beaconMajor + "," + adList[i].beaconMinor + " "
		}
}
```

This script looks for Eddystone-URL beacons and sends updates based on the current URL:

```
btm = new BSBtManager()
adList = btm.GetCurrentAdvertising()
for(i = 0; i < adList.length; i++) {
	// Brightsign.biz is now https
		if (adList[i].mode == "eddystone-url" && adList[i].url == "http://www.brightsign.biz")      {
			adList[i].url = "https://www.brightsign.biz"
		}
}
btm.StartAdvertising(adList)
```

This script produces an exception because the compressed URL is too long:

```
al = new BSBtAdvertisementList()
ad4 = new BSBtAdvertisement( { mode: "eddystone-url", url:"http://www.brightsign.biz/thisistoolong"} )
al.push(ad4)
b.StartAdvertising(al)
```
----
developers\developers\player-apis\brightscript-javascript-objects\bscecreceiver.md
# BSCECReceiver

For more information about available methods, refer to the [*roCecInterface*](../../../developers/brightscript/object-reference/inputoutput-objects/rocecinterface.md) entry. Note that you can only use this JavaScript class to receive CEC messages. Use [*BSCECTransmitter*](../brightscript-javascript-objects/bscectransmitter.md) to send CEC messages.

The JavaScript equivalent is [cec](../../player-apis/javascript-apis/cec.md).

## Events

The following events are available on the *BSCECReceiver* object. They can receive an event of the type *CECReceiverEvent*. 

`onececrxframe`

`oncectxcomplete`

### BSCECReceiverEvent – Attributes

`readonly attribute int status`

`readonly attribute DOMString data`

### BSCECReceiverEvent – Methods

`ArrayBuffer getBytes()`

## Methods

`void Close()`

Shuts down the instance, preventing it from further consuming resources. If this method is not called, garbage collection determines when the instance will be destroyed.

## Example

```
<script>
    function loadCec()
    {
        console.log("*** loadCec ***");

        var cec_in = new BSCECReceiver();

        cec_in.oncecrxframe = function(e){
           console.log('############ oncecrxframe: ' + e.data);
        }

        cec_in.oncectxcomplete = function(e){
           console.log('############ oncectxcomplete: ' + e.status);
        }
    }
</script>
```
----
developers\developers\player-apis\brightscript-javascript-objects\bscectransmitter.md
# BSCECTransmitter

For more information about available methods, refer to the [*roCecInterface*](../../../developers/brightscript/object-reference/inputoutput-objects/rocecinterface.md) entry. Note that you can only use this JavaScript class to send CEC messages. Use [*BSCECReceiver*](../brightscript-javascript-objects/bscecreceiver.md) to receive CEC messages.

When possible, JavaScript APIs should be used instead of BrightScript-Javascript Objects. The JavaScript API equivalent to this object is [cec](../../player-apis/javascript-apis/cec.md).

## Methods

`boolean SendRawMessage(in ArrayBuffer data)`

`boolean SendRawMessage(in ArrayBufferView data)`

`boolean SendRawMessage(in DOMString data)`

`void Close()`

Shuts down the instance, preventing it from further consuming resources. If this method is not called, garbage collection determines when the instance will be destroyed.

## Example

The following JavaScript example shows how to send a set of CEC messages:

```
function cecDisplayOn()
    {
        console.log("### cecDisplayOn ###");
        var cec_control = new BSCECTransmitter();
        var buffer = new Uint8Array(2);
        buffer[ 0 ] = 0x40;
        buffer[ 1 ] = 0x0D;
        cec_control.SendRawMessage(buffer);
    }

function cecDisplayOff()
    {
        console.log("### cecDisplayOff ###");
        var cec_control = new BSCECTransmitter();
        var buffer = new Uint8Array(2);
        buffer[ 0 ] = 0x40;
        buffer[ 1 ] = 0x36;
        cec_control.SendRawMessage(buffer);
    }
```
----
developers\developers\player-apis\brightscript-javascript-objects\bscontrolport.md
# BSControlPort

This object provides support for the BP200/BP900 USB button boards and GPIO ports. Button presses are returned as `oncontroldown` and `oncontrolup` events. The object is used to configure output levels on the I/O connector and monitor inputs. Typically, LEDs and buttons are attached to the GPIO connector on the BrightSign player or the BrightSign Expansion Module.

The JavaScript equivalent is [controlport](../../player-apis/javascript-apis/controlport.md).

## Object Creation

The *roControlPort* object is created with a single parameter that specifies the port being used.

```
BSControlPort(in DOMString PortName)
```

The port parameter can be one of the following:

*   `BrightSign`: Specifies the onboard GPIO connector (including the SVC (GPIO12) button).
    
*   `Expander-GPIO`: Specifies the DB-25 connector on the BrightSign Expansion Module. If no BrightSign Expansion module is attached, then object creation will fail and Invalid will be returned.
    
*   `Expander-<n>-GPIO`: Specifies a [USB-to-GPIO device](https://www.brightsign.biz/digital-signage-products/accessories/USB-C-Cables) connected to the player. Multiple USB-to-GPIO devices can be controlled using separate *roControlPort* instances: The first device corresponds to `"Expander-0-GPIO"`, the second to `"Expander-1-GPIO"`, etc.
    
*   `Expander-DIP`: Specifies the eight DIP switches on the BrightSign Expansion Module. If no BrightSign Expansion module is attached, then object creation will fail and Invalid will be returned.
    

> [!NOTE]
> Hot-plugging the BrightSign Expansion Module is not supported.

*   `Touchboard-<n>-GPIO`: Retrieves events from the specified BP200/BP900 button board. Events are handled in the same manner as events from the BrightSign port.
    
*   `Touchboard-<n>-LED-SETUP`: Sets various LED output options for the specified BP200/BP900 button board.
    
*   `Touchboard-<n>-LED`: Sets the bits for each button on the specified BP200/BP900 button board. The bits indicate whether the associated LED should be on or off.
    

> [!NOTE]
> Since multiple BP200/BP900 button boards can be connected to a player simultaneously, the <n> value specifies the port enumeration of each board. This value corresponds to the `<raw>` or `<fid>` value returned by the [*roDeviceInfo.GetUSBTopology()*](../../../developers/brightscript/object-reference/system-objects/rodeviceinfo.md) method. An unspecified enumeration value is synonymous with a button board with an enumeration value of 0 (e.g. Touchboard-GPIO and Touchboard-0-GPIO are identical).

## Methods

> [!TIP]
> See [this page](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/375390705/XTx44+Hardware+Interfaces) for a table of pins and corresponding buttons for the onboard GPIO connector.

`boolean ConfigureAsInput (unsigned Button)`

Marks the specified button as an input. If an invalid button number is passed, `false` will be returned. If successful, the function returns `true`. Input buttons are tri-stated and can be driven high or low externally.

`boolean ConfigureAsOutput (unsigned Button)`

Marks the specified button as an output. If an invalid button number is passed, `false` will be returned. If successful, the function returns `true`. The output will be driven high or low depending on the current output state of the pin.

`boolean SetPinValue(unsigned Button, unsigned Output)`

Configures the output of the specified button, which can be either low (0) or high (1). If the button is not configured as an output, the resulting level is undefined. This method can also be used to configure LED output behavior on [BP200/B900 button boards](../../../developers/brightscript/object-reference/inputoutput-objects/rocontrolport.md).

`boolean GetPinValue(unsigned Button)`

Returns the output of the specified button.

`void Close()`

Shuts down the *BSControlPort* instance, preventing it from further consuming resources. If this method is not called, garbage collection determines when the instance will be destroyed.

`boolean SetOutputValue(unsigned Param)`

Specifies the desired state of all outputs attached to the control port as bits in an integer. The individual buttons can be set using binary operations.

The parameter is an 8-bit integer and each bit represents an output.

`boolean SetOutputValues(unsigned Param1, unsigned Param2, unsigned Param3, unsigned Param4)`

Configures buttons on a BP200/BP900 button board. This method can only be used when the *BSControlPort* object is instantiated with the `Touchboard-<n>-LED-SETUP` or `Touchboard-<n>-LED` parameter. The parameters are integer values.

## Events

The following events are available on the *BSControlPort* object. Each event can receive a *ControlPortEvent* event.

*   `oncontroldown`
    
*   `oncontrolup`
    
*   `oncontrolevent`
    

### ControlPortEvent – Attributes

*   `readonly attribute unsigned long code`
    

## Examples

The following example code configures four GPIO outputs:

```
var gpio = new BSControlPort("BrightSign");
 
// set outputs
gpio.ConfigureAsOutput(0);
gpio.ConfigureAsOutput(1);
gpio.ConfigureAsOutput(2);
gpio.ConfigureAsOutput(3);
 
// set desired states
gpio.SetPinValue(0, 1);
gpio.SetPinValue(1, 1);
gpio.SetPinValue(2, 0);
gpio.SetPinValue(3, 0);
```

The following example causes the LEDs on a BP900 button board to twinkle:

```
var bp900_gpio;
function myFunction()
{
    var bp900_setup = new BSControlPort("TouchBoard-0-LED-SETUP");
    bp900_setup.SetPinValue(0, 11)

    var bp900 = new BSControlPort("TouchBoard-0-LED");
    bp900.SetPinValue(0, 0x07fe)
    bp900.SetPinValue(1, 0x07fd)
    bp900.SetPinValue(2, 0x07fb)
    bp900.SetPinValue(3, 0x07f7)
    bp900.SetPinValue(4, 0x07ef)
    bp900.SetPinValue(5, 0x07df)
    bp900.SetPinValue(6, 0x07bf)
    bp900.SetPinValue(7, 0x077f)
    bp900.SetPinValue(8, 0x06ff)
    bp900.SetPinValue(9, 0x05ff)
    bp900.SetPinValue(10, 0x03ff)

    bp900_gpio = new BSControlPort("TouchBoard-0-GPIO");
    bp900_gpio.oncontroldown = function(e)
    {
        console.log('###### oncontroldown' + e.code);
    }
}
```

The following example displays events from a GPIO expander board. Note that using the equivalent *roGpioControlPort* object in BrightScript at the same time will result in unpredictable I/O behavior.

```
<html>
    <head>
    <script>
        var bp900_gpio = new BSControlPort("BrightSign");

        bp900_gpio.oncontroldown = function(e){
            console.log('### oncontroldown ' + e.code);
            newtext = " DOWN: " + e.code + "\n";
            document.myform.outputtext.value += newtext;
            document.myform.outputtext.scrollTop = document.myform.outputtext.scrollHeight;
        }

        bp900_gpio.oncontrolup = function(e){
            console.log('### oncontrolup ' + e.code);
            newtext = "   UP: " + e.code + "\n";
            document.myform.outputtext.value += newtext;
            document.myform.outputtext.scrollTop = document.myform.outputtext.scrollHeight;
        }

        bp900_gpio.oncontrolevent = function(e){
            console.log('### oncontrolevent ' + e.code);
            newtext = "EVENT: " + e.code + "\n";
            document.myform.outputtext.value += newtext;
            document.myform.outputtext.scrollTop = document.myform.outputtext.scrollHeight;
        }

        function ledOn(output_index)
        {
            bp900_gpio.ConfigureAsOutput(output_index);
            newtext = "  LED: " + output_index + "\n";
            document.myform.outputtext.value += newtext;
            document.myform.outputtext.scrollTop = document.myform.outputtext.scrollHeight;
        }

        function buttonOn(output_index)
        {
            bp900_gpio.ConfigureAsInput(output_index);
            newtext = "INPUT: " + output_index + "\n";
            document.myform.outputtext.value += newtext;
            document.myform.outputtext.scrollTop = document.myform.outputtext.scrollHeight;
        }
    </script>
    </head>

    <body bgcolor="#E6E6FA">

    <h1>GPIO/Expander Test Page</h1>
    Note this does NOT play well with <em>roGpioControlPort</em>!!<br><br>
    <input type="button" onclick="ledOn(0)" value="led0">
    <input type="button" onclick="ledOn(1)" value="led1">
    <input type="button" onclick="ledOn(2)" value="led2">
    <input type="button" onclick="ledOn(3)" value="led3">
    <input type="button" onclick="ledOn(4)" value="led4">
    <input type="button" onclick="ledOn(5)" value="led5">
    <input type="button" onclick="ledOn(6)" value="led6">
    <input type="button" onclick="ledOn(7)" value="led7">
    <br>
    <input type="button" onclick="buttonOn(0)" value="button0">
    <input type="button" onclick="buttonOn(1)" value="button1">
    <input type="button" onclick="buttonOn(2)" value="button2">
    <input type="button" onclick="buttonOn(3)" value="button3">
    <input type="button" onclick="buttonOn(4)" value="button4">
    <input type="button" onclick="buttonOn(5)" value="button5">
    <input type="button" onclick="buttonOn(6)" value="button6">
    <input type="button" onclick="buttonOn(7)" value="button7">
    <br>

    <form name="myform">
        <textarea readonly rows="50" cols="100" name="outputtext" style="font-family:monospace"></textarea>
    </form>

</body>
</html>
```
----
developers\developers\player-apis\brightscript-javascript-objects\bsdatagramsocket.md
# BSDatagramSocket

For more information about available methods, refer to the *roDatagramReceiver* and *roDatagramEvent* entries.

## Methods

`boolean BindLocalPort(in long port)`

`long GetLocalPort()`

`boolean JoinMulticastGroup(in DOMString group)`

`boolean SendTo(in DOMString dest, in long port, in ArrayBufferView data)`

`boolean SendTo(in DOMString dest, in long port, in DOMString data)`

`void Close()`

Shuts down the instance, preventing it from further consuming resources. If this method is not called, garbage collection determines when the instance will be destroyed.

## Events

The following event is available on the *BSDatagramSocket* object. It can receive an event of the type DatagramSocketEvent. Use getBytes() to retrieve the body of the UDP message.

`ondatagram`

### DatagramSocketEvent

The DatagramSocketEvent has the following attributes:

`readonly attribute DOMString remoteHost`

`readonly attribute int remotePort`  

The DatagramSocketEvent supports the following methods:

`ArrayBuffer getBytes()`

## Example

> [!NOTE]
> See [here](https://stackoverflow.com/questions/6965107/converting-between-strings-and-arraybuffers) to learn how to convert between strings and an `ArrayBuffer`.

```
var bsSocketMessage = new BSDatagramSocket();
bsSocketMessage.BindLocalPort(1234)
bsSocketMessage.ondatagram = function(e){

  var txtDec = new TextDecoder("utf-8");
  console.log("Received " + txtDec.decode(e.getBytes()));
};
```
----
developers\developers\player-apis\brightscript-javascript-objects\bsdeviceinfo.md
# BSDeviceInfo

For more information about available methods, refer to the *roDeviceInfo* entry. The JavaScript equivalent is [deviceinfo](../../player-apis/javascript-apis/deviceinfo.md).

## Attributes

`readonly attribute DOMString model`

`readonly attribute DOMString version`

`readonly attribute int deviceUptime`

`readonly attribute int deviceLifetime`

`readonly attribute int deviceBootCount`

`readonly attribute DOMString bootVersion`

`readonly attribute DOMString deviceUniqueId`

`readonly attribute DOMString family`

## Methods

`int VersionCompare(in DOMString version)`

`int BootVersionCompare(in DOMString version)`

`boolean HasFeature(in DOMString feature)`

## Example

The following JavaScript example posts device information on the page when the button is clicked:

```
function deviceInfo()
{
    var device_info = new BSDeviceInfo();
    document.getElementById("modelText").innerHTML = device_info.model;
    document.getElementById("versionText").innerHTML = device_info.version;
    document.getElementById("bversionText").innerHTML = device_info.bootVersion;
    document.getElementById("serialText").innerHTML = device_info.deviceUniqueId;
    document.getElementById("familyText").innerHTML = device_info.family;

    document.getElementById("uptime").innerHTML = device_info.deviceUptime;
    document.getElementById("lifetime").innerHTML = device_info.deviceLifetime;
    document.getElementById("bootcount").innerHTML = device_info.deviceBootCount;

    if(device_info.VersionCompare("4.7.36") > 0)
    {
        document.getElementById("version1").innerHTML = "Version > 4.7.36"
    }
    else
    {
        document.getElementById("version1").innerHTML = "Version <= 4.7.36"
    }
    
	if(device_info.HasFeature("Six Channel Audio"))
    {
        document.getElementById("feature").innerHTML = "6 Channel Audio Available"
    }
    else
    {
        document.getElementById("feature").innerHTML = "6 Channel Audio NOT Available"
    }
}
```
----
developers\developers\player-apis\brightscript-javascript-objects\bsirreceiver.md
# BSIRReceiver

This class receives IR events. For more information, refer to the Object Reference Manual entry on *roIRReceiver*.

## Object Creation

A *BSIRReceiver* object must specify the hardware interface that will receive IR events, as well as the encoding(s) to look for:

`BSIRReceiver(DOMString interface, DOMString encoding)`

  
Valid hardware interfaces include the following:

*   "GPIO": Pin 1 of the GPIO connector
    
*   "IR-in": The 3.5mm IR input/output connector
    
*   "Iguana": The [Iguanaworks](http://iguanaworks.net/) IR transceiver. This source can support both NEC and RC5 encodings simultaneously.
    
*   “tvcontroller” : This virtual IR driver is only available on BrightSign built-in products. It reads the IR messages from UART and drives the roIRReceiver object like other IR receivers. A creation example would be:
    

```
BSIRReceiver(tvcontroller)
```

Valid encodings include the following (multiple encodings can be specified in the string using a ";"):

*   "NEC"
    
*   "RC5" (supported on the Iguanaworks device only)
    

NEC codes are expressed in 24 bits:

*   Bits 0-7: Button code
    
*   Bits 8-23: Manufacturer code
    

> [!NOTE]
> If the manufacturer code is zero, then the code is considered to be intended for the Roku SoundBridge remote control.

## Methods

`void Close()`

Shuts down the instance, preventing it from further consuming resources. If this method is not called, garbage collection determines when the instance will be destroyed.

## Events

These events are available on the *BSIRReceiver* object. Each event can receive an IRReceiverEvent event.

`onremotedown`

`onremoterepeat`

`onremoteup` (supported on the Iguanaworks device only)

#### IRReceiverEvent – Attributes

`readonly attribute DOMString irType;`

`readonly attribute unsigned long code;`

## Example

The following JavaScript example displays messages on the log when remote codes are received:

```
function myFunction()
{
    var ir_receiver = new BSIRReceiver("IR-in","NEC");

    ir_receiver.onremotedown = function(e){
        console.log('############ onremotedown: ' + e.irType + " - " + e.code);
    }

    ir_receiver.onremoteup = function(e){
        console.log('############ onremoteup: ' + e.irType + " - " + e.code);
    }
}
```
----
developers\developers\player-apis\brightscript-javascript-objects\bsirtransmitter.md
# BSIRTransmitter

This class receives IR events. For more information, refer to the Object Reference Manual entry on *roIRTransmitter*.

## Object Creation

A *BSIRTransmitter* object must specify the hardware interface that will output the IR signal:

`BSIRTransmitter (in DOMString interface)`

Valid hardware interfaces include the following:

*   "IR-out": The 3.5mm IR input connector (available on XDx30 players) or 3.5mm IR input/output connector (available on XTx43, 4Kx42, XDx33, and XDx32 players)
    
*   "Iguana": The [Iguanaworks](http://iguanaworks.net/) IR transceiver
    

## Methods

`boolean Send(in DOMString Type, in unsigned long code)`

`boolean SetSendPolarity(in boolean polarity)`

`void Close()`

Shuts down the instance, preventing it from further consuming resources. If this method is not called, garbage collection determines when the instance will be destroyed.

## Example

```
<script>
    var irTransmitter = new BSIRTransmitter("IR-out");

    function irCode1()
    {
        console.log('############ irCode1');
        irTransmitter.Send("NEC", 65284);
    }
    function irCode2()
    {
        console.log('############ irCode2');
        irTransmitter.Send("NEC", 65288);
    }
    function irCode3()
    {
        console.log('############ irCode3');
        irTransmitter.Send("NEC", 65290);
    }
</script>
```
----
developers\developers\player-apis\brightscript-javascript-objects\bsmessageport.md
# BSMessagePort

This object allows for an associative array to be passed from JavaScript to BrightScript (or vice versa). Only one *BSMessagePort* instance may be created per *roHtmlWidget* instance.

The JavaScript equivalent is [messageport](../../player-apis/javascript-apis/messageport.md).

## Methods

`boolean PostBSMessage(in Dictionary message)`

> [!NOTE]
> The PostBSMessage() method does not accept nested dictionaries. The same is true for the PostJSMessage() BrightScript method.

## Events

The following event occurs when a message is sent from BrightScript to JavaScript. It will appear as a *MessagePortEvent* event.

`onbsmessage`

### MessagePortEvent

This event contains a single field:

`readonly attribute any data;`

The following script will iterate over all the fields received in the event:

```
var bsMessage = new BSMessagePort();

bsMessage.onbsmessage = function(msg)
{
    for(name in msg.data)
    {
    	console.log('### ' + name + ': ' + msg.data[name]);
    }
}
```

In BrightScript, the *roHtmlWidget.PostJSMessage()* method can be used to post a message to JavaScript:

`widget.PostJSMessage({ Param1: "Data1", Param2: "Data2", Param3: "Data3" })`

## Examples

The following script will send a collection of properties to BrightScript:

```
function myFunction()
{
    var bsMessage = new BSMessagePort();
    bsMessage.PostBSMessage({complete: true, result: "PASS"});
}
```

The message will appear in BrightScript as an *roHtmlWidgetEvent*. In this case, the GetData().reason equals "message" and GetData().message contains the *roAssociativeArray*.

```
while not finished
    ev = mp.WaitMessage(30000)
    if type(ev) <> "roHtmlWidgetEvent" then
        print type(ev)
        stop
    end if
    payload = ev.GetData()
    print payload
    print "Reason: "; payload.reason
    if payload.reason = "message" then
        print "Message: "; payload.message
        if payload.message.complete = invalid then
            stop
        else if payload.message.complete = "true" then
            finished = true
            if payload.message.result = "PASS" then
                print "Test passed"
            else
                print "Test failed: "; payload.message.err
                stop
            end if
        end if
    end if
end while
```
----
developers\developers\player-apis\brightscript-javascript-objects\bsserialport.md
# BSSerialPort

For more information about available methods, refer to the [*roSerialPort*](../../../developers/brightscript/object-reference/inputoutput-objects/roserialport.md) entry.

If possible, use @brightsign/serialport with the Node Package [serialport](https://serialport.io/) instead of BSSerialPort. A basic reference implementation can be found in [this GitHub repository](https://github.com/brightsign/bs-node-serialport).

## Object Creation

`BSSerialPort(in unsigned long port);`

## Methods

`void SetBaudRate(in unsigned long baudRate) raises(DOMException)`

`void SetDataBits(in unsigned long dataBits) raises(DOMException)`

`void SetStopBits(in unsigned long stopBits) raises(DOMException)`

`void SetParity(in DOMString parity) raises(DOMException)`

`boolean SetEcho(in boolean flag) boolean`

`SetInverted(in boolean flag) boolean`

`SetFlowControl(in boolean flag)`

`void SetGenerateByteEvent(in boolean flag) raises(DOMException)`

`void SetGenerateLineEvent(in boolean flag) raises(DOMException)`

`void SetLineEnding(in DOMString eol) raises(DOMException)`

`boolean SendByte(in unsigned long byte)`

`boolean SendBytes(in ArrayBuffer data)`

`boolean SendBytes(in ArrayBufferView data)`

`boolean SendBytes(in DOMString data)`

`boolean SendBreak(in long duration_ms)`

`void Flush() raises(DOMException)`

`void Close()`

Shuts down the instance, preventing it from further consuming resources. If this method is not called, garbage collection determines when the instance will be destroyed.

## Events

The following events are available via the *BSSerialPort* object. Each event can receive a SerialPortEvent event.

`onserialbyte`

`onserialline`

### SerialPortEvent – Attributes

For the onserialbyte event:

`readonly attribute unsigned long sbyte`

For the onserialline event:

`readonly attribute DOMString sdata`

## Example

```
function serialOut()
{
    console.log("*** serialOut **");

    // '2' is the first externally connected USB  port on Cheetah
    var serial_out = new BSSerialPort(2);

    serial_out.SetBaudRate(115200);
    serial_out.SetDataBits(8);
    serial_out.SetStopBits(1);
    serial_out.SetParity("none");
    serial_out.SetEcho(true);

    serial_out.SetGenerateByteEvent(true);
    serial_out.SetGenerateLineEvent(true);

    serial_out.onserialbyte = function(e){
        console.log('### onserialbyte: ' + e.sbyte);
    }

    serial_out.onserialline = function(e){
        console.log('### onserialline: ' + e.sdata);
    }

    serial_out.SendByte(89);
    serial_out.SendByte(90);
    serial_out.SendByte(91);

    serial_out.SendBytes('Hello World!');
    serial_out.SendBytes(String.fromCharCode(64, 27, 66, 67))
}
```
----
developers\developers\player-apis\brightscript-javascript-objects\bssyncmanager.md
# BSSyncManager

For more information about available methods, refer to the [*roSyncManager*](https://docs.brightsign.biz/display/DOC/roSyncManager) entry. To enable Genlock in JavaScript, pass the *BSSyncManager*/*roSyncManager* domain to the [*videooutput.setSyncDomain()*](../../player-apis/javascript-apis/videooutput.md) method

## Object Creation

BSSyncManager(in DOMString interface, in DOMString domain, in DOMString multicast\_address, in DOMString multicast\_port)

Setting the interface to `""` (empty) will use all interfaces, and omitting the `interface` parameter is equivalent to specifying an empty interface name. 

## Methods

`void SetAsLeader(in boolean leader_mode) raises(DOMException)`

`void Synchronize(in DOMString id, in unsigned long ms_delay) raises(DOMException)`

`void Close()`

Shuts down the instance, preventing it from further consuming resources. If this method is not called, garbage collection determines when the instance will be destroyed.

`BindToInterface(in DOMString interface)`

Binds the SyncManager to a specific network interface (for example, "eth0", "wifi0"). Setting the interface to `""` (empty) will use all interfaces.

`boolean SetEncryptionEnable(in boolean enable)`  
  
`boolean SetEncryptionEnable(in boolean enable, in DOMString key)`  
  
`boolean SetEncryptionEnable(in boolean enable, in ArrayBuffer key)`

Enables or disables encryption of *BSSyncManager* messages over the network. This method returns `true` on success and `false` on failure.

The key may be specified as a string or binary array. Alternatively, a `key` value may not be supplied, in which case a pseudo-randomly generated key is used. Setting `enable` to `false` and supplying a `key` at the same time will cause this method to fail. 

Encryption is available (and enabled by default) in OS8 and later. Note the following behavior in mixed-version environments:

*   Follower units that have encryption enabled can ingest unencrypted synchronization messages from a leader unit. Once a follower unit receives encrypted packets, it will no longer accept unencrypted packets from a leader unit, unless encryption is explicitly disabled using this method.
    
*   Follower units that have encryption disabled (or do not support encryption) cannot ingest encrypted messages from a leader unit. Therefore, if a synchronization group includes mixed versions of OS, the leader unit should always have an older version of OS than the follower units.
    

`boolean SetEncryptionEnableWithObfuscatedKey(in DOMString obfuscated_key) As Boolean`

Enables encryption of *BSSyncManager* messages using an obfuscated key. Contact [support@brightsign.biz](mailto:support@brightsign.biz) to learn more about generating a key for obfuscation and storing it on the player.

## HTML Video Functions

setSyncParams(in DOMString domain, in DOMString id, in DOMString iso\_timestamp)

HTML video tags include the `setSyncParams()` function. Calling this function synchronizes the video with the specified sync group.

## Events

The following event is available on the *BSSyncManager* object. It can receive events of the type *BSSyncManagerEvent*.

`onsyncevent` 

### BSSyncManagerEvent – Attributes

The following attributes are relevant to the onsyncevent event:

`readonly attribute DOMString domain`

`readonly attribute DOMString id`

`readonly attribute DOMString iso_timestamp`

## Examples

The following JavaScript example contains two videos being synchronized locally with *BSSyncManager*. If a follower player is configured to be in the same PTP domain as the leader player and uses the follower HTML script, then it will display the videos in sync with the leader player. This can be implemented on multiple follower players.

### Leader Script

```
<video id="one" hwz="on">
    <source id="one_src" src="pirates.mov">
</video>

<script>
    // Create the sync manager with provided multicast settings
    var sync = new BSSyncManager("domain1", "224.0.126.10", 1539);

    sync.onsyncevent = function (e) {
        document.getElementById("one").setSyncParams(e.domain, e.id, e.iso_timestamp);
        document.getElementById("one").load();
        document.getElementById("one").play();
        console.log(e.domain);
        console.log(e.id);
        console.log(e.iso_timestamp);
    };

    function startTimer() {
        setTimeout(function () {
            restartLeader()
        }, 30000);
    }
    function restartLeader() {
        // Synchronize the videos to start playing in 1000ms
        sync.SetAsLeader(1);
        sync.Synchronize("sync_event1", 1000);
        startTimer();
    }
    restartLeader();

</script>
```

### Follower Script

```
<video id="one" hwz="on">
    <source id="one_src" src="pirates.mov">
</video>

<script>
    // Create the sync manager with provided multicast settings
    var sync = new BSSyncManager("domain1", "224.0.126.10", 1539);

    sync.onsyncevent = function (e) {
        document.getElementById("one").setSyncParams(e.domain, e.id, e.iso_timestamp);
        document.getElementById("one").load();
        document.getElementById("one").play();
        console.log(e.domain);
        console.log(e.id);
        console.log(e.iso_timestamp);
    };
 
</script>

</body>
</html>
```
----
developers\developers\player-apis\brightscript-javascript-objects\bsticker.md
# BSTicker

For more information about available methods, refer to the *roTextWidget* entry. This object can be used to display a scrolling type ticker.

> [!NOTE]
> This object supports both right-to-left and left-to-right (for example, Arabic, Hebrew) scrolling modes, depending on the language of the first string or file added to the widget. To change the scrolling direction, first remove all strings from the ticker.

## Object Creation

`BSTicker(in unsigned long x, in unsigned long y, in unsigned long w, in unsigned long h, in long rotation);`

The `x` and `y` integers specify the position of the ticker widget (via the top-left corner), while the  `w` and `h` integers specify the size of the widget. The `rotation` parameter accepts the following values (rotation is counter-clockwise from landscape mode):

`0`: 0 degrees

`90`: 90 degrees

`180`: 180 degrees

`270`: 270 degrees

> [!NOTE]
> The `rotation` parameter only affects the text inside the ticker; it does not alter the screen coordinates of the widget itself. If you are creating a vertical ticker or rotating the ticker to match portrait-mode HTML content, you will need to use the `x, y, w, h`  coordinate parameters to match the rotation of the text.

## Methods

`boolean SetRectangle(in unsigned long x, in unsigned long y, in unsigned long w, in unsigned long h)`

Modifies the (`x,y)` position and (`w,h)` size of the ticker widget. Changing the size of the widget will reset the ticker animation. As long as the size of the widget remains unchanged, modifying the position will not interrupt the ticker animation. This method returns `True` on success, or `False` on failure.

`int AddString(in DOMString str)`

Adds a string to the queue. This method returns a `string_id` integer that can be used to identify which string was removed when the `ontickerstringremoved` event is generated; a zero return indicates that the method failed to add the string. Adding too many strings without popping them from the stack will cause `AddString()` to return a non-zero value (the exact number depends on the font size for each string). The maximum recommended number of stored strings is 64.

`int AddSurface(in ImageData image)`

Adds a bitmap image to the list of strings to display. The image must be of type `ImageData`. This method returns a `string_id` integer that can be used to identify which surface is removed when the `ontickerstringremoved` event is generated. See the code at the bottom of this page for an example of using a canvas/image with this method.

`boolean PopStrings(in unsigned long count)`

Removes designated number of strings from the queue. This method returns `True` on success, or `False` on failure.

`boolean SetAutoPop(in boolean)`

If this method is set to `True`, strings are automatically removed (popped from the stack) once they have scrolled offscreen.

`boolean SetForegroundColor(in unsigned long argb)`

Specifies the foreground color as a 32-bit number in ARGB (Alpha, Red, Green, Blue) format. This method returns `True` on success, or `False` on failure.

`boolean SetForegroundColor(in unsigned long a, in unsigned long r, in unsigned long g, in unsigned long b)`

Sets the foreground color in red, green, and blue (foreground alpha values are currently unsupported and are ignored by this method, though this may change in future firmware versions). `a, r, g` and `b` are integer values between 0 and 255. This method returns `True` on success, or `False` on failure.

`boolean SetBackgroundColor(in unsigned long argb)`

Specifies the background color as a 32-bit number in ARGB (Alpha, Red, Green, Blue) format. This method returns `True` on success, or `False` on failure.

`boolean SetBackgroundColor(in unsigned long a, in unsigned long r, in unsigned long g, in unsigned long b)`

Sets the background color in alpha, red, green, and blue. While standard alpha values are between 0.0 and 1.0, the values in BSTicker are `unsigned long` (or the upper 8 bits of an `unsigned long`). The values are mapped between 0x00 and 0xff to correspond to 0.0 to 1.0. This method returns `True` on success, or `False` on failure.

`boolean SetSeparatorString(in DOMString str)`

Use a text string to separate individual messages. This method returns `True` on success, or `False` on failure.

`boolean SetSeparatorCircle()`

Use a circle to separate individual messages. This method returns `True` on success, or `False` on failure.

`boolean SetSeparatorDiamond()`

Use a diamond to separate individual messages. This method returns `True` on success, or `False` on failure.

`boolean SetSeparatorSquare()`

Use a square to separate individual messages. This method returns `True` on success, or `False` on failure.

`unsigned long SetPixelsPerSecond(in unsigned long pps)`

Sets the speed of the ticker.

`boolean SetFont(in DOMString font)`

Specifies a font for the BSTicker (as well as the roTextWidget BrightScript object). This method accepts a list of font-family names (similar to the CSS <font-family> property). The string can also have a `font-face:` prefix to indicate that this is a font description (for example, `font-face:DejaVu Serif,Serif Italic Bold`). Fonts must be added to the HTML widget using the `roHtmlWidget.AddFont()` method before they can be used in a BSTicker instance. This method returns `True` on success, or `False` on failure.

`boolean SetSyncManager(in DOMString domain)`

Specifies a BSSyncManager domain to use when executing the `SetMultiscreen()` call. When this method is called, it creates an internal domain based on the existing BSSyncManager domain and uses the same network parameters. We recommend using this method instead of passing a multicast IP address and port to the `SetMultiscreen()` method itself. This method returns `True` on success, or `False` on failure.

`boolean SetMultiscreen(in unsigned long offset, in unsigned long size, in DOMString ip_address, in unsigned long port)`

Call the `SetMultiscreen()` method to create a ticker that smoothly scrolls across multiple screens. This method returns `True` on success, or `False` on failure.

*   `offset:` Determines the left starting point (in pixels) in the multiscreen array. The parameter value will always be 0 for the leftmost display. This parameter should be calculated using the length of the multiscreen ticker, *not the total length of the multiscreen display*. For example, using an offset of 1920 in a two-screen array of 1920x1080 screens would specify this player as the right-hand (master) display.To create a ticker that smoothly scrolls across multiple screens, call the `SetMultiscreen()` method on each page. 
    
*   `size:` The total width (in pixels) of the multiscreen array across all displays. This parameter should be the same value for each `SetMultiscreen()` call. Note that the size of a multiscreen ticker can be different from the total width of a multiscreen display (for example, if the width of a BSTicker widget is smaller than the width of the screen). Defining a size of 3840 would specify a two-screen array of 1920x1080 screens.
    
*   `ip_address:` A string specifying the multicast IP address for the PTP synchronization process (for example, "239.192.0.0")
    
*   `port:` A string specifying the multicast port for the PTP synchronization process (for example, "1234").
    

The following example diagram and code snippets specify a multiscreen display with two monitors. The width of each monitor is 1024 pixels, while the width of each ticker is 768 pixels:

![](./attachments/SetMultiScreen()%20Diagram.png)

## Events

`bsTicker.ontickerstringremoved`

This event handler is triggered when a string has been removed and is no longer visible. The event contains the `string_id` property, which is returned by a successful `AddString()` call.

## Examples

The following script shows how to use many of the available *BSTicker* methods:

```
var bsTicker = new BSTicker(10, 110, 600, 30);
 
function addText1()
{
    console.log('############ addText1');
    bsTicker.AddString("addText1");
}
function addText2()
{
    console.log('############ addText2');
    bsTicker.AddString("addText2");
}
function addText3()
{
    console.log('############ addText3');
    bsTicker.AddString("addText3");
}

function setBackground1()
{
    console.log('############ setBackground1');
    bsTicker.SetBackgroundColor(0xFFFF0000);
}
function setBackground2()
{
    console.log('############ setBackground2');
    bsTicker.SetBackgroundColor(0xFF00FF00);
}

function setForeground1()
{
    console.log('############ setForeground1');
    bsTicker.SetForegroundColor(0xFF007700);
}
function setForeground2()
{
    console.log('############ setForeground2');
    bsTicker.SetForegroundColor(0xFF000077);
}

function setSeparatorString()
{
    console.log('############ setSeparatorString');
    bsTicker.SetSeparatorString(" ### ");
}
function setSeparatorCircle()
{
    console.log('############ setSeparatorCircle');
    bsTicker.SetSeparatorCircle();
}
function setSeparatorDiamond()
{
    console.log('############ setSeparatorDiamond');
    bsTicker.SetSeparatorDiamond();
}
function setSeparatorSquare()
{
    console.log('############ setSeparatorSquare');
    bsTicker.SetSeparatorSquare();
}

function setTickerSpeed()
{
    console.log('############ setTickerSpeed');
    var speed = bsTicker.SetPixelsPerSecond(180);
    console.log('############ SetPixelsPerSecond(180), Resulting speed: ' + speed);
}
```

The following examples allow for adding a canvas or image to the ticker with the `AddSurface()` method:

```
//Loading a canvas
var ctx = canvas.getContext("2d");
var img = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);

ticker.AddSurface(img); 

//Loading an image
var imageObj = new Image();
imageObj.onload = function() {
	canvas.width = this.width;
	canvas.height = this.height;

	var ctx = canvas.getContext("2d");
	ctx.drawImage(this, 0, 0); // Use getImage Data as above
 };
 imageObj.src = "filename.jpg";
```
----
developers\developers\player-apis\brightscript-javascript-objects\bsvideomode.md
# BSVideoMode

For more information about available methods, refer to the *roVideoMode* page.  If you’d like to change the video mode of the player, you will need to use BrightScript instead of this JavaScript class. 

The JavaScript equivalent is [videomodeconfiguration](../../player-apis/javascript-apis/videomodeconfiguration.md).

## Attributes

`readonly attribute int resX`

`readonly attribute int resY`

`readonly attribute int safeX`

`readonly attribute int safeY`

`readonly attribute int safeWidth`

`readonly attribute int safeHeight` 

`readonly attribute DOMString mode`

`readonly attribute BSDecoderModeList decoderModeList`

## Methods

> [!WARNING]
> The methods used by this object are obsolete and can be found in the [videooutput](../../player-apis/javascript-apis/videooutput.md) and [videomodeconfiguration](../../player-apis/javascript-apis/videomodeconfiguration.md) JavaScript API documentation. The HdmiAudioDisable() method can be found in the *roVideoMode* BrightScript API documentation.

```
boolean IsAttached(in DOMString connector)

DOMString GetBestMode(in DOMString connector)

boolean SetBackgroundColour(in unsigned long rgb)

boolean SetBackgroundColour(in unsigned long r,
	in unsigned long g,
	in unsigned long b)

boolean SetPowerSaveMode(in boolean disable)

boolean HdmiAudioDisable(in boolean disable)
 
boolean SetDecoderMode(in DOMString decoder,
	in DOMString timeslice_mode,
	in int z_order,
	in DOMString friendly_name,
	in boolean enable_mosaic_deinterlacer)


boolean SetSyncManager(in BSSyncManager sync); //See the roVideoMode.SetSyncDomain() entry for more details.
```

## BSDecoderMode

The `decoderModeList` attribute contains an array of *BSDecoderMode* objects, each containing information about a configured decoder on the player.

See the `SetDecoderMode()` and `GetDecoderMode()` entries on the [*roVideoMode*](../../../developers/brightscript/object-reference/presentation-and-widget-objects/rovideomode.md) page for more information about decoder parameters.

```
interface BSDecoderMode {
    readonly attribute DOMString decoderName;
    readonly attribute DOMString friendlyName;
    readonly attribute DOMString maxSize;
    readonly attribute DOMString configuredSize;
    readonly attribute unsigned long currentUsage;
    readonly attribute unsigned long maxUsage;
    readonly attribute boolean mosaic;
    readonly attribute boolean enableDeinterlacer;
};
```

## Example

The following JavaScript example illustrates how to retrieve information about the current video mode:

```
function fillInVideoData()
    {
        var videomode_info = new BSVideoMode();
        document.getElementById("resX").innerHTML = videomode_info.resX;
        document.getElementById("resY").innerHTML = videomode_info.resY;
        document.getElementById("safeX").innerHTML = videomode_info.safeX;
        document.getElementById("safeY").innerHTML = videomode_info.safeY;
        document.getElementById("safeWidth").innerHTML = videomode_info.safeWidth;
        document.getElementById("safeHeight").innerHTML = videomode_info.safeHeight;
        document.getElementById("videoMode").innerHTML = videomode_info.mode;
        document.getElementById("bestMode").innerHTML = videomode_info.GetBestMode("hdmi");
        document.getElementById("connectedFlag").innerHTML = videomode_info.IsAttached("vga");
    }

function changeBackground()
    {
        var videomode_info = new BSVideoMode();
        videomode_info.SetBackgroundColour(0xFF0000);
    }
```
----
developers\developers\player-apis\brightscript-javascript-objects\enabling-brightscript-javascript-objects.md
# Enabling BrightScript-JavaScript Objects

For security reasons, all BrightScript JavaScript objects are disabled by default. As a result, you will encounter DOM errors like those shown below if you do not enable first enable them (to view a console log of BrightScript/JavaScript events, go to the [Diagnostic Web Server](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370673541/Diagnostic+Web+Server) or use the JavaScript console).

![](./attachments/DOM%20Exception%20--%20Console%20Output.png)

Follow the below steps to enable BrightScript JavaScript objects.

## Enabling with BrightAuthor

Make sure that you are using BrightAuthor version 4.1 or later. Earlier versions do not have the code that enables BrightScript objects for JavaScript.

Also, ensure that the **Enable external data** box is checked within the HTML5 state that is displaying your page.

![](./attachments/BA%20--%20Enable%20External%20Data.png)

## Enabling with BrightScript

Include the `brightsign_js_objects_enabled:true` entry with the associative array that is passed during creation of the [*roHtmlWidget*](../../../developers/brightscript/object-reference/presentation-and-widget-objects/rohtmlwidget.md) instance:

**Example:**

```
r=createobject("rorectangle",0,0,1920,1080)
aa=createobject("roassociativearray")

aa.url="http://test-server/index.html"
aa.brightsign_js_objects_enabled=true

bb=createobject("roassociativearray")
bb.port=3000
aa.inspector_server=bb

h=createobject("rohtmlwidget",r,aa)
h.show()
```

The above method enables all BrightScript-JavaScript objects on an *roHtmWidget* instance. To enable only a subset of BrightScript-JavaScript objects, or to restrict the objects to certain URLs, use the `AllowJavaScriptUrls()` method on a *roHtmlWidget* instance. This method accepts an associative array that maps BrightScript-JavaScript classes to the URL(s) that are allowed to use them.

*   An `all` key indicates that all classes are authorized for the associated URL(s).
    
*   An asterisk `"*"` value indicates that all URLs are authorized for the associated BrightScript-JavaScript class.
    
*   A `"local"` value indicates that all local pages are authorized for the associated BrightScript-JavaScript class.
    

This will enable all BrightScript classes for all URLs:

```
html.AllowJavaScriptUrls({ all: "*" })
```

This call will enable all BrightScript-JavaScript classes for local pages and the BrightSign homepage:

```
html.AllowJavaScriptUrls({ all: ["local", "http://www.brightsign.biz"]})
```
----
developers\developers\player-apis\brightscript-javascript-objects\global-brightscript-javascript-functions.md
# Global BrightScript-JavaScript Functions

The following functions are implemented at the global level.

`IsBSLocalFilePresent()`

Determines whether the specified file exists on local storage. This function interfaces with the BrightScript pool and determines if the file exists there; it also searches for files with standard names.

`CloseAllBSClasses()`

This function effectively calls `Close()` on all custom objects that have been created and have yet to be garbage collected. Call this function when initializing a new web page to ensure all previous links to hardware interfaces on the player have been removed.
----
developers\developers\player-apis\brightscript-javascript-objects.md
# BrightScript-JavaScript Objects

> [!WARNING]
> New applications should avoid using BrightScript objects and should use [JavaScript API](../player-apis/javascript-apis.md) objects instead. See the [BrightScript-JavaScript Migration Guide](../player-apis/brightscript-javascript-migration-guide.md) for the mapping between BrightScript and JavaScript APIs.

The BrightSign HTML engine exposes several platform-specific JavaScript objects, which allow you to integrate your HTML content with hardware interfaces and system functions on the player. These objects allow you to link many standard interactive, database, and hardware elements (serial, CEC, device info, etc.) to HTML pages.

This section details the functions and parameters for each JavaScript object. For more information about the BrightScript objects that the JavaScript objects are linked to, see the [BrightScript](../../developers/brightscript.md) section.
----
developers\developers\player-apis\javascript-apis\assetfetcher.md
# assetfetcher

The *assetfetcher* object allows for downloading files to an asset pool (which is represented in JavaScript as an [*assetpool*](../javascript-apis/assetpool.md) instance).

**assetfetcher IDL**

```
interface AssetPoolFetcher {
    AssetPoolFetcher(AssetPool pool);
    Promise<void> start(AssetList list, AssetPoolFetcherParams assetPoolParams[optional]);
    Promise<void> cancel();
};

interface FileEvent {
    attribute String type;
    attribute String fileName;
    attribute int index;
    attribute int responseCode;
    attribute String error;
};

interface ProgressEvent {
    attribute String type;
    attribute String fileName;
    attribute int index;
    attribute int total;
    attribute long currentFileTransferred;
    [optional] attribute long currentFileTotal;
};

interface AssetPoolFetcherParams {
    attribute Authentication auth;
    attribute bool enableUnsafeAuthentication;
    attribute bool enableUnsafeProxyAuthentication;
    attribute bool enableEncodings;
    attribute bool enablePeerVerification;
    attribute bool enableHostVerification;
    attribute String certificatesFile;
    attribute HeaderList headers;
    attribute String proxy;
    attribute Array<String> proxyBypassList;
    attribute unsigned int progressInterval;
    attribute unsigned int fileRetryCount;
    attribute String relativeLinkPrefix;
    attribute String interfaceName;
    attribute MinTransferRate minimumTransferRate;
    attribute double maximumTransferRate;
    attribute bool onlyRequestCache;
};

interface Authentication {
    attribute String username;
    attribute String password;
};

interface Header {
    attribute String value;
};

interface MinTransferRate {
    attribute int bytesPerSecond;
    attribute int periodInSeconds;
};
```

## Object Creation

To create an *assetpoolfetcher* object, you will first need to create an *assetpool* instance. Then, load the `brightsign/assetpoolfetcher` module using the `require()` method, and create an instance of the *assetpoolfetcher* class using the *assetpool* instance.

```
const AssetPoolClass = require("@brightsign/assetpool");
let assetPool = new AssetPoolClass("SD:/pool");
 
const AssetPoolFetcherClass = require("@brightsign/assetpoolfetcher");
let assetPoolFetcher = new AssetPoolFetcherClass(assetPool);
```

## AssetPoolFetcher

This interface allows you start or stop the asset fetcher.

##### start()

```
Promise<void> start(AssetList list, AssetPoolFetcherParams assetPoolParams[optional])
```

Begins fetching the files specified in the passed [*assetpool.AssetList*](../javascript-apis/assetpool.md) interface. The fetching process is configured with the passed *AssetPoolFetcherParams* interface. The `start()` promise returns when the asset-fetching process is complete. Alternatively, the promise will be rejected if the *assetpoolfetcher* instance has already been started. This method may cause assets to be pruned.

##### cancel()

```
Promise<void> cancel()
```

Cancels the asset-fetching process. The promise will not be resolved until cancellation is complete.

## FileEvent

This interface contains information about a file-transfer attempt.

*   `type` string: Contains `fileevent` to indicate the type of the event.
    
*   `fileName` string: The name of the asset being downloaded.
    
*   `index` int: The zero-based index of the file in the [*assetpool.AssetList*](../javascript-apis/assetpool.md) interface.
    
*   `responseCode` int: The protocol response code associated with the event. The following codes indicate success:
    
    *   200: Successful HTTP transfer
        
    *   226: Successful FTP transfer
        
    *   0: Successful local file transfer
        

> [!NOTE]
> **Note**
> There are also numerous error codes in case of failure; see [this page](../../../developers/brightscript/object-reference/content-management-objects/roassetfetcherevent.md) for a non-exhaustive list.

*   `error` string: A textual error message which may be more descriptive than the responseCode for local errors.
    

## ProgressEvent

This interface contains information about the asset-fetching process.

*   `type` string:  Contains `progressevent` to indicate the type of the event.
    
*   `fileName` string: The name of the file currently being downloaded
    
*   `index` int: The zero-based index of the current file in the [*assetpool.AssetList*](../javascript-apis/assetpool.md) interface
    
*   `total` int: The total number of files in the *AssetList* object
    
*   `currentFileTransferred` long: The number of bytes that have been downloaded so far for the current asset.
    
*   `currentFileTotal` long optional: If the size of the asset in bytes was known prior to the download starting then it is provided in this property. If the size was not known then this property may not be present.
    

## AssetPoolFetcherParams

This interface contains configuration parameters for the asset-fetcher process.

*   `auth` Authentication: An *Authentication* interface specifying the credentials to use when downloading the asset
    
*   `enableUnsafeAuthentication`  bool: A flag enabling basic HTTP authentication. HTTP authentication uses an insecure protocol, which might allow others to easily determine the password. The *assetpoolfetcher* object will still prefer the stronger digest HTTP if it is supported by the server. If this parameter is `false` (which is the default setting), it will refuse to provide passwords via basic HTTP authentication, and any requests requiring this authentication will fail.
    
*   `enableUnsafeProxyAuthentication` bool: A flag enabling basic HTTP authentication against proxies. HTTP authentication uses an insecure protocol, which might allow others to easily determine the password. If this parameter is `false`, it will refuse to provide the proxy password via basic HTTP authentication, and any requests requiring this authentication type will fail. Unlike `enableUnsafeAuthentication`, this parameter is set to `true` by default. 
    
*   `enableEncodings` bool:  A flag enabling HTTP compression, which communicates to the server that the system can accept any encoding that the *assetpoolfetcher* instance is capable of decoding by itself (this behavior is enabled by default). Supported encodings currently include "deflate" and "gzip", which allow for transparent compression of responses. Clients of the *assetpoolfetcher* instance see only the decoded data and are unaware of the encoding being used.
    
*   `enablePeerVerification` bool: A flag that enables checking of TLS/SSL certificates. This parameter is set to `true` by default. Disabling peer verficiation allows you to bypass an expired certificate check.
    
*   `enableHostVerification` bool: A flag that enables checking of the TLS/SSL certificate for the correct hostname. This parameter is set to `true` by default. Disabling host verification allows you to accept a certificate being sent for the wrong hostname.
    

> [!CAUTION]
> **Important**
> Peer verification and host verification are important security checks that prevent "man-in-the-middle" attacks. These features should only be disabled after careful consideration of the security implications.

*   `certificatesFile` string: The filename of an alternative set of CA certificates for the connection. This method is useful if the connection certificates are signed by a CA that is not on the the default trusted list (for example, if your organization uses a private CA hierarchy that is not signed by a well known root CA). This file replaces the default list, so the passed certificate file must contain all acceptable CA certificates required for the connection.
    
*   `headers` HeaderList: A list of headers that will be passed to HTTP requests made by the *assetpoolfetcher* instance.
    
*   `proxy` string: The name or address of the proxy server that will be used by the *assetpoolfetcher* instance. The proxy string should be formatted as "[http://user:password@hostname:port](http://user:password@hostnameport/)". It can contain up to four "\*" characters; each "\*" character can be used to replace one octet from the player's current IP address. For example, if the IP address is currently 192.168.1.2, and the proxy is set to "proxy-\*-\*", then the player will attempt to use a proxy named "proxy-192-168". If present, this setting overrides the player global proxy setting.
    
*   `proxyBypassList` Array<String>: A list of hosts to exempt from the proxy setting. The list should consist of one or more hostnames (IP addresses cannot be used). The *assetpoolfetcher* instance will attempt to reach the specified hosts directly rather than using the proxy that has been specified with the `proxy` parameter. For example, the hostname "[example.com](http://example.com/)" would exempt "[example.com](http://example.com/)", "[example.com](http://example.com/):80", and "[www.example.com](http://www.example.com/)" from the proxy setting. If present, this setting overrides the global proxy bypass setting.
    
*   `progressInterval` unsigned int: The interval (in seconds) between progress events when an individual file is being downloaded. Setting the interval to `null` disables all progress events. Setting the interval to 0 specifies that events should be generated as often as possible, though this will slow down the transfer process. If the interval is set to 0 or any positive integer, events will always be generated at the start and end of the file download irrespective of elapsed time. The default interval is 300 seconds.
    
*   `fileRetryCount` unsigned int: The maximum number of times each file download will be retried before moving on to the next file download. The default retry count is five.
    
*   `relativeLinkPrefix` string: A prefix that will be prepended to links that lack a protocol in the *AssetList* object. Normally, this method is used to make `file:///` URIs drive agnostic, but it can also be used to reduce the size of the sync spec if all files are stored in the same place. Links that have a protocol are not affected by this method.
    
*   `interfaceName` string: A string specifying which network interface the *assetpoolfetcher* instance should try to use for network access, for example "eth0" for Ethernet or "wlan0" for WiFi. The default behavior (indicated by a null value) is to send requests using the most appropriate network interface, which may depend on the routing metric configured via the *networkconfiguration* object. If multiple interfaces are on the same layer 2 network, this method may not work as expected due to the Linux weak-host model.
    
*   `minimumTransferRate` MinTransferRate: A *MinTransferRate* interface specifying the average minimum transfer rate for file downloads. If a file transfer falls below this rate, it will be terminated.
    
*   `maximumTransferRate` long: The maximum transfer rate for file downloads. The source data rate isn't under the direct control of the BrightSign player, but download rates should average below the specified value over time. 
    
*   `onlyRequestCache` bool: A flag indicating that the player should disconnect shortly after beginning the asset download. If the player is set to use a suitably configured proxy (either globally or via the *AssetPoolFetcherParams* interface), then the proxy will continue to download the files, making them readily available for asset-fetching calls in the future. If this parameter is `true`, the `fileevent` will return response code 202 ("Accepted") to indicate success. Other errors will be reported as usual. The `progressevent` for the final all-files-complete event will always be -2 ("EVENT\_ALL\_FAILED") because the download does not complete.
    

## Authentication

This interface contains authentication information for downloading files.

*   `username` string: The user name for authentication
    
*   `password` string: The password for authentication
    

## Header

This interface contains a list of headers to pass to a file download URL. Each entry in the list contains the following parameters:

*   `value` string: The header value
    

## MinTransferRate

The values in this interface are used to calculate the minimum transfer rate.

*   `bytesPerSecond` int: The transfer rate below which, when it is averaged over the `periodInSeconds`, the file transfer will be terminated
    
*   `periodInSeconds` int: The time frame over which the `bytesPerSecond` measurement is averaged
    

> [!NOTE]
> **Note**
> If the transfer is over the Internet, you may not want to set the `periodInSseconds` to a small number in case network problems cause temporary drops in performance. For large file transfers and a small `bytesPerSecond` limit, averaging fifteen minutes or more may be appropriate.
----
developers\developers\player-apis\javascript-apis\assetpool.md
# assetpool

The *assetpool* object represents a directory on a storage device used to store downloaded assets. See the [Asset Pool](https://docs.brightsign.biz/display/DOC/BrightSign+Asset+Pool) overview for more general information and examples.

**assetpool IDL**

```
interface AssetPool {
    AssetPool(String poolPath);
    Promise<void> protectAssets(String assetCollectionName, AssetList assets);
    Promise<void> unprotectAssets(String assetCollectionName);
    Promise<void> reserveStorage(long reservedStorageInBytes);
    Promise<void> setMaximumPoolSize(long? maximumPoolSizeInBytes);
    Promise<long> getPoolSize();
    Promise<AssetValidationResult> validate(AssetList assets, AssetValidationOptions options);
    Promise<AssetQueryResult> queryFiles(AssetList assets);
    Promise<bool> areAssetsReady(AssetList assets);
};

interface AssetInfo {
    attribute String name;
    attribute String link;
    [optional] attribute long size;
    [optional] attribute AssetHash hash;
    [optional] attribute String changeHint;
    [optional] attribute AssetFetchAuthentication? auth;
    [optional] attribute AssetFetchHeaders? headers;
};

interface AssetHash {
    attribute String method;
    attribute String hex;
};

interface AssetFetchAuthentication {
    [optional] attribute String user;
    [optional] attribute String password;
};

interface AssetFetchHeaders {
};

interface AssetValidationOptions {
    attribute deleteCorrupt;
};

interface AssetQueryResult {
    attribute String name;
    attribute bool present;
};

interface AssetValidationResult {
    attribute String name;
    attribute String reason;
};
```

## Object Creation

To create an *assetpool* object, first load the `brightsign/assetpool` module using the `require()` method. Then create an instance of the *assetpool* class with a string value specifying the pool path. You must create only one *assetpool* instance per pool path. This means that it is not possible to safely share a single pool path between BrightScript and JavaScript code.

```
const AssetPoolClass = require("@brightsign/assetpool");
let assetPool = new AssetPoolClass("SD:/pool");
```

## AssetPool

Use this interface to perform operations on the asset pool.

##### protectAssets()

```
Promise<void> protectAssets(String assetCollectionName, AssetList assets)
```

Requests that a set of files in the asset pool be protected from deletion when the system software needs to prune files from the pool to make space. The passed `assetCollectionName` is used to reference the set of files if their protection needs to be removed later using the `unprotectAssets()` method. Protection only affects this a`ssetpool` instance and the other objects that use it. You must protect all the assets you care about before performing any operation that might prune files from the pool in order to be sure that the assets you still need are not pruned. This setting is not persistent beyond the lifetime of the `assetpool` instance.

##### unprotectAssets()

```
Promise<void> unprotectAssets(String assetCollectionName)
```

Removes protection from a set of files that have been protected by passing the corresponding `assetCollectionName` to the the `protectAssets()` method.

##### reserveStorage()

```
Promise<void> reserveStorage(long reservedStorageInBytes)
```

Operations on this assetpool instance, and any other assetpoolfetcher and assetrealizer instances using it, will attempt to keep the specified amount of space free on the storage device containing the pool. As other files are written to the storage device, the maximum size occupied by the pool will be reduced to compensate. This setting is not stored persistently in the pool, so the method must be called each time an assetpool object is created.

##### setMaximumPoolSize()

```
Promise<void> setMaximumPoolSize(long? maximumPoolSizeInBytes)
```

Specifies the maximum size of the asset pool. This method is more resource-intensive than `reserveStorage()`, but it is useful when creating multiple pools on a storage device to ensure they don't grow unevenly. This setting is not stored persistently in the pool, so the method must be called each time an assetpool object is created.

##### getPoolSize()

```
Promise<long> getPoolSize()
```

Returns the current size of the asset pool in bytes. It is necessary to walk the pool directory structure looking at every asset file to do this, which may slow down other access to the storage device. It is recommended that this method is not called regularly in production code.

##### validate()

```
Promise<AssetValidationResult> validate(AssetList assets, AssetValidationOptions options)
```

Recalculates the hashes of every file in the pool and compares them with the expected values in the passed AssetList. This means every asset file needs to be read in its entirety which may take a long time and may slow down other access to the storage device. This method can be used to detect storage and file system corruption. This method returns an *AssetValidationResult* interface containing validation results for each file. The second parameter is an *AssetValidationsOptions* interface specifying validation options. The only option currently supported indicates whether any assets with mismatched hashes are automatically deleted. The default behaviour is to leave such asset files in place.

##### queryFiles()

```
Promise<AssetQueryResult> queryFiles(AssetList assets)
```

Determines whether the specified files are present in the asset pool. This method returns an *AssetQueryResult* interface containing query results. This method is normally only useful for debugging during development.

##### areAssetsReady()

```
Promise<bool> areAssetsReady(AssetList assets)
```

Returns `true` if every asset in the AssetList is present in the asset pool.

## AssetInfo 

This interface represents a single asset file that may be in the pool may not yet be in the pool. Each asset has a subset of the following properties:

*   `name` string: The name that can be used to look up the asset. For a file to be realized, it must have a valid filename without any slashes. Asset names must be unique within an asset collection, but different asset collections may use the same asset name to refer to the same asset in the pool or a different asset in the pool. Asset names are not stored in the pool, the only way to refer to an asset by name is using an asset collection.
    
*   `link` string: The URI that can be used by assetpoolfetcher to download the file. http, https, ftp and file URIs are supported.
    
*   `size` long optional : The file length (in bytes) if known.
    
*   `hash` AssetHash optional: A *Hash* interface specifying the hash algorithm and hash value of the file. If no hash is provided then one is created automatically from the link and changeHint.
    
*   `changeHint` string optional: An arbitrary value that can be used by the client to specify that a file has changed even when the hash value and download URL remain the same. This is mostly useful when the hash is not known but the provider of the asset collection can tell when the content has changed. For example, MediaRSS feeds often provide a GUID for the content.
    
*   `auth` AssetFetchAuthentication? optional: An *AssetFetchAuthentication* interface specifying the credentials to use when downloading the asset. By default, credentials are inherited from the [*assetpoolfetcher*](../javascript-apis/assetfetcher.md) instance used to download the asset.
    
*   `headers` AssetFetchHeaders? optional: By default, the HTTP headers specified via the `headers` property passed to the s`tart` method will be used for each asset. The use of these headers can be disabled for a particular asset by setting this property to `null`. This is useful if a particular subset of assets are retrieved from somewhere else that does not require authentication. It is not currently possible to provided specific headers for a single asset.
    

## AssetHash

This interface contains hash information about the file.

*   `method` string: The hash algorithm. Accepted values include "SHA1", "SHA224", "SHA256", "SHA384", "SHA512", "MD5" and "BESHA1". "BESHA1" is a custom hash algorithm that is only useful for referring to large assets that are stored remotely and its use is not recommended.
    
*   `hex` string: The hash value in hexadecimal format
    

## AssetFetchAuthentication

This interface contains authentication information for downloading files.

*   `user`string optional: The user name for authentication
    
*   `password` string optional: The password for authentication
    

## AssetValidationOptions

This interface contains validation options for the `validate()` method.

*   `deleteCorrupt`: A flag specifying whether corrupt files should be deleted during validation
    

## AssetQueryResult

This interface is returned by the `queryFiles()` method. Each entry in the list contains the following parameters:

*   `name` string: The name of the queried file
    
*   `present` bool: A flag indicating whether the queried file exists in the asset pool
    

## AssetValidationResult

This interface is returned by the `validate()` method. Each entry in the list contains the following parameters:

*   `name` string: The name of the checked file
    
*   `reason` string: An explanation for a failed validation
----
developers\developers\player-apis\javascript-apis\assetpoolfiles.md
# assetpoolfiles

This *assetpoolfiles* object provides direct access to the files for assets in the pool.

**assetrealizer IDL**

```
interface AssetPoolFiles {                                                                                                                                                                                   
    AssetPoolFiles(AssetPool pool, AssetList assets);                                                                                                                                                        
    Promise<String> getPath(String assetName);                                                                                                                                                               
    Promise<AssetInfo> getInfo(String assetName);                                                                                                                                                            
    Promise<void> moveFileIntoPool(String sourceFileName, String destinationAssetName);                                                                                                                          
}                                                                                                                                                                                                            
```

## Object Creation

To create an *assetpoolfiles* object, you will first need to create an *assetpool* instance and download files to it using an *assetpoolfetcher* instance. Then, load the `brightsign/assetrealizer` module using the `require()` method, and create an instance of the *assetrealizer* class using the *assetpool* instance and the destination directory for realization.

```
const AssetPoolClass = require("@brightsign/assetpool");
let assetPool = new AssetPoolClass("SD:/pool");
  
const AssetPoolFilesClass = require("@brightsign/assetpoolfiles");
let assetPoolFiles = new AssetPoolFilesClass(assetPool, assetCollection);
```

## AssetPoolFiles

Use this interface to gain access to information about the files for assets in the pool.

##### getPath()

```
Promise<String> getPath(String assetName)
```

Returns the full path to the file in the pool that corresponds to the named asset. This can be used to read, play or execute the corresponding asset as required. You must not modify the file since this will change its hash.

##### getInfo()

```
Promise<AssetInfo> getInfo(String assetName)
```

Returns the [AssetInfo](https://docs.brightsign.biz/display/DOC/BrightSign+Asset+Pool) for the named asset if it is present in the pool. If the asset is not present then the returned promise is rejected.

##### moveFileIntoPool()

```
Promise<void> moveFileIntoPool(String sourceFileName, String destinationAssetName)
```

Move an existing file on the same storage device as the pool into the pool as the asset with the corresponding name. This is a quick operation because the hash is not checked. Note that this method does not cause any pruning of assets already in the pool to take place (although it may cause a subsequent operation that can prune the pool to do so.) This method is only rarely useful.
----
developers\developers\player-apis\javascript-apis\assetrealizer.md
# assetrealizer

This *assetrealizer* object contains functions for realizing files (i.e. extracting files from an asset pool and placing them into the standard file directory).

**assetrealizer IDL**

```
interface AssetRealizer {
    constructor(AssetPool pool, String destinationPath);
    Promise<unsigned long long> estimateRealizedSize(AssetList assets);
    Promise<void> realize(AssetList assets);
    Promise<Array<ValidationResult>> validateFiles(AssetList assets, AssetValidationOptions options);
};
 
interface AssetValidationOptions {
    attribute deleteCorrupt;
};
 
interface ValidationResult {
    attribute String name;
    attribute String reason;
};
```

## Object Creation

To create an *assetrealizer* object, you will first need to create an *assetpool* instance and download files to it using an *assetpoolfetcher* instance. Then, load the `brightsign/assetrealizer` module using the `require()` method, and create an instance of the *assetrealizer* class using the *assetpool* instance and the destination directory for realization.

```
const AssetPoolClass = require("@brightsign/assetpool");
let assetPool = new AssetPoolClass("SD:/pool");
   
const AssetRealizerClass = require("@brightsign/assetrealizer");
let assetRealizer = new AssetRealizerClass(assetPool, "SD:/");
```

## AssetRealizer

Use this interface to copy assets out of the pool into real named files in the file system and perform related functions.

##### estimateRealizedSize()

```
Promise<unsigned long long> estimateRealizedSize(AssetList assets)
```

Returns the estimated amount of space (in megabytes) that would be taken up if the files specified in the [*AssetList*](../javascript-apis/assetpool.md) object are realized.

##### realize()

```
Promise<void> realize(AssetList assets)
```

Places the files into the destination directory specified in the passed AssetList object. If the pool does not contain the full set of required files, then this method will immediately fail before any files are changed (this method attempts to do as much work as possible before destructively modifying the file system). This method automatically checks the length of the file and that any hashes that match those specified. If there is a mismatch, then the affected file is deleted from the pool and realization fails. This method may cause unprotected assets to be pruned from the pool. The method indicates failure by rejecting the returned promise.

> [!NOTE]
> The pool and the destination must be on the same storage device in the same file system.

##### validateFiles()

```
Promise<Array<ValidationResult>> validateFiles(AssetList assets, AssetValidationOptions options)
```

Checks the hash of every file in the passed AssetList against the corresponding file in the destination path and returns a string list containing each mismatched file name mapped to the reason. This operation can take a long time and slow down access to the storage device. It is normally only useful if file system or storage corruption is suspected or for debugging. The `options` parameter is a string list, which can currently support a single option:

*   `"deleteCorrupt"`: Automatically deletes any files that do not match the expected hash. By default, these files are not deleted.
    

## ValidationResult

This interface is returned by the `validateFiles()` method to indicate the results of the realize operation.

*   `name` string: The name of the mismatched file (if the realize operation fails)
    
*   `reason` string: An explanation for a failed realize operation. See the [*roAssetRealizerEvent*](../../../developers/brightscript/object-reference/content-management-objects/roassetrealizerevent.md) page for a list of possible reason strings.
----
developers\developers\player-apis\javascript-apis\audio.md
# audio .

The *audio* object is a JavaScript object for use with *roNodeJs* that allows the playback of audio by replicating functionality from the HTML5 audio element.

**audio IDL**

```
interface Audio {
  // error state
  readonly attribute MediaError error;
 
  // network state
           attribute String src;
  readonly attribute String currentSrc;
  readonly attribute unsigned short networkState;
  const unsigned short NETWORK_EMPTY = 0;
  const unsigned short NETWORK_IDLE = 1;
  const unsigned short NETWORK_LOADING = 2;
  const unsigned short NETWORK_NO_SOURCE = 3;
 
  void load();
  String canPlayType(String type);
 
  // ready state
  readonly attribute unsigned short readyState;
  const unsigned short HAVE_NOTHING = 0;
  const unsigned short HAVE_METADATA = 1;
  const unsigned short HAVE_CURRENT_DATA = 2;
  const unsigned short HAVE_FUTURE_DATA = 3;
  const unsigned short HAVE_ENOUGH_DATA = 4;
 
  readonly attribute boolean seeking;
 
  // playback state
           attribute double currentTime;
  readonly attribute double duration;
  readonly attribute boolean paused;
           attribute double defaultPlaybackRate;
           attribute double playbackRate;
  readonly attribute boolean ended;
           attribute boolean autoplay;
           attribute boolean loop;
  void play();
  void pause();
 
  void setSyncParams(String domain, String sync_id, String iso_timestamp);
 
  // controls
           attribute double volume;
           attribute boolean muted;
 
  // BrightSign extensions
           attribute String pcmaudio;
           attribute String compaudio;
 
           attribute int x-bs-stream-timeout;
           attribute String x-bs-audio-mode;
 
  // Present but unimplemented
           attribute String preload;
  readonly attribute TimeRanges buffered;
  readonly attribute double initialTime;
  readonly attribute Date startOffsetTime;
           attribute boolean controls;
  readonly attribute TimeRanges played;
  readonly attribute TimeRanges seekable;
 
  readonly attribute TextTrack[] tracks;
  MutableTextTrack addTrack(String kind, optional String label, optional String language);
 
};
```

## Object Creation

To create an *audio* object, first load the *brightsign/audio* module using the require() method. Then create an instance of the audio class using the following example:

```
var audio_class = require("@brightsign/audio");
var audio_player = new audio_class();
```

## Audio

Use this interface to create *audio* objects.

### Event

`seeked:` This event is fired when media loops back to the start.

### Methods

##### load() 

```
void load()
```

Triggers processing of the `src`. `load` starts up playback to the point of being ready to play the first frame. If `autoplay` is set, then it also starts playback. `readyState` and `networkState` are altered, and multiple events fire as playback starts.

##### canPlayType() 

```
 String canPlayType(String type)
```

Returns whether the passed MIME type can be displayed on the BrightSign player.

##### play() 

```
void play()
```

Starts or resumes playback.

##### pause() 

```
void pause()
```

Pauses playback.

##### setSyncParams()

```
 void setSyncParams(String domain, String sync_id, String iso_timestamp)
```

This BrightSign extension is documented [here.](https://docs.brightsign.biz/display/DOC/BSSyncManager)

## Audio Parameters

*   `src` string: Contains the URL of a media resource to use in the element. Only file URLs are supported currently, including relative URLs to the current script and a file:/// URI with an absolute filesystem path on the player. The URL returned when reading this value back is always absolute with file: protocol on the front.
    
*   `currentSrc` string: Contains the URL of the media resource in use by the element.
    
*   `networkState` unsigned short: An enum that indicates the current state of the fetching of media. This attribute moves through the states as `src` is selected and playback begins, but because support is currently for files only, it is not as dynamic as when used with HTTP. Possible values are:
    
    *   `NETWORK_EMPTY = 0,`
        
    *   `NETWORK_IDLE,`
        
    *   `NETWORK_LOADING,`
        
    *   `NETWORK_NO_SOURCE` 
        
*   `readyState` unsigned short: Indicates the readiness state of media. This attribute moves through the states as `src` is selected and playback begins. Possible values are:
    
    *   `HAVE_NOTHING = 0,`
        
    *   `HAVE_METADATA,`
        
    *   `HAVE_CURRENT_DATA,`
        
    *   `HAVE_FUTURE_DATA,`
        
    *   `HAVE_ENOUGH_DATA`
        
*   `seeking` boolean:  Indicates if the media is seeking to a new position.
    
*   `currentTime` double: Specifies the current playback time in seconds as a floating point. Currently seeking is not supported, and setting this attribute has no effect. If playback is completed, this returns the same value as duration.
    
*   `duration` double: Specifies the current duration of the media in seconds as a floating point.
    
*   `paused` boolean: Reflects whether the media playback is currently paused.
    
*   `defaultPlaybackRate` double: This cannot be set to anything other than 1.0, and always returns 1.0 (only normal speed playback is supported).
    
*   `playbackRate` double: This cannot be set to anything other than 1.0, and always returns 1.0 (only normal speed playback is supported).
    
*   `ended`  boolean: Reflects where the media playback has reached the end of the media.
    
*   `autoplay` boolean: Indicates whether playback should automatically begin when media is available to play without interruption.
    
*   `loop` boolean: Sets whether the playback should loop or not. The value is used when load is called. Setting it once playback has started will have no effect.
    
*   `volume` double: Controls the volume of playback
    
*   `muted` boolean: Controls the muting and unmuting of the audio
    
*   `pcmaudio` string: Route decoded PCM audio to the outputs in the string. Outputs available are `analog`, `earc`, or a USB output (for example, `usb:A.0`). Multiple outputs can be specified by using a semi-colon delimeter (for example, `earc; analog`)
    
*   `compaudio` string: Routes compressed audio direct to eARC without decoding. Can be set to `earc` only.
    
*   `x-bs-stream-timeout` int*:* Controls timeouts when streaming.
    
*   `x-bs-audio-mode` string: Controls the downmix of audio to mono. Possible values are `MonoLeftMixdown`, `MonoRightMixdown`, and the default which is `Stereo`. Using this, two audio players can output to a single stereo output, one to the left channel, and the other to the right channel.
    

## Unimplemented Methods and Properties

*   `preload`
    
*   `buffered`
    
*   `initialTime`
    
*   `startOffsetTime`
    
*   `controls`
    
*   `played`
    
*   `seekable`
    
*   `tracks`
    

## Examples

```
const audio_class = require("@brightsign/audio");
let audio_player = new audio_class();
audio_player.src = "/storage/sd/file.mp4"
audio_player.volume = .5;
audio_player.load();
audio_player.play();
```

```
let setupAudio = (audio, setupObj) => {
   for (let [key, val] of Object.entries(setupObj)) {
      audio[key] = val;
   }
}

let interval = setInterval(()=>{}, 10000);
const audio_class = require("@brightsign/audio");
let audio = new audio_class();
let settings = {
   src: '/storage/sd/file.mp4',
   autoplay: true,
   loop: false,
   volume: .5,
   pcmaudio: "analog"
};
setupAudio(audio, settings);
audio.load();
audio.addEventListener("ended", () => {
   audio.src = '';
   audio = null;
   clearInterval(interval);
   process.exit(0);
});
```
----
developers\developers\player-apis\javascript-apis\audioconfig.md
# audioconfig

This object allows for mixing and leveling of audio streams before they are passed to audio outputs. 

**audioconfig IDL**

```
interface AudioConfiguration {
    Promise<AudioConfig> getConfig();
    Promise<void> applyConfig(AudioConfig config);
};

interface AudioConfig {
    attribute String modeName;
    [optional] attribute int srcRate;
    [optional] attribute bool pcmOnly;
    [optional] attribute bool autoLevel;
};
```

## Object Creation

To create an *audioconfig* object, load the `brightsign/audioconfiguration` module using the `require()` method.

```
var AudioConfigurationClass = require("@brightsign/audioconfiguration");
var audioconfig = new AudioConfigurationClass();
```

## AudioConfiguration

Use this interface to create *audioconfig* objects.

##### getConfig()

```
Promise<AudioConfig> getConfig()
```

Returns the audio configuration information.

##### applyConfig()

```
Promise<void> applyConfig(AudioConfig config)
```

Configures the audio mode to switch between dynamic and pre-routed.

## AudioConfig

This interface contains the audio configuration parameters for all but the AU series 5 product line. See the note below for more information about those products.

*   `modeName` string: Sets the audio routing mode:
    
    *   `"dynamic"`: The default mode. Mixing audio streams with differing sampling rates will cause playback to fail; differing volume levels will not be normalized; and audio streams cannot be added to an output that currently has audio playing on it. Other parameters in the associative array are ignored. However, in the AU product line, only a single audio stream can be played to an output at any one time. All other parameters in the associative array are ignored.
        
    *   `"prerouted"`: Add and remove audio streams on an output that currently has audio playing on it; additional audio routing behavior is determined with the `srcrate,  pcmonly`, and `autolevel` parameters. 
        
*   `srcRate` int optional: Sets the sample rate to which all PCM audio streams are converted in the the "pre-routed" audio mode. This value can be either 44100 or 48000.
    
*   `pcmOnly` bool optional: Enables ("true") or disables ("false") compressed audio support in the "pre-routed" audio mode. 
    
*   `autoLevel` bool optional: Enables ("on") or disables ("off") volume leveling for audio outputs in the "pre-routed" audio mode. When this setting is enabled, all PCM audio streams on a particular output will play at a similar volume. 
    

> [!NOTE]
> These audio configuration parameter definitions are specific to AU series 5 products:
> *   `modeName` string: Sets the audio routing mode:
>     
>     *   `"dynamic"`: The default mode. Only a single audio stream can be played to an output at any one time. All other parameters in the associative array are ignored.
>         
>     *   `"prerouted"`:  Multiple audio streams can be played simultaneously to analog or eARC outputs (not USB). Audio is always the sample rate converted to the value set in *srcRate*. Streams can be started and stopped without affecting other playing streams.
>         
> *   `srcRate` int optional: Sets the sample rate to which all PCM audio streams are converted in the the "pre-routed" audio mode. This value can be from 32000 to 96000.
>     
> *   `pcmOnly` bool optional: This feature is not available on the AU series 5 product line.
>     
> *   `autoLevel` bool optional: This feature is not available on the AU series 5 product line.

## Example

In this example, the code gets the current audio configuration, alters it (though it doesn't check that the values are changing), and writes it back:

```
var AudioConfigurationClass = require("@brightsign/audioconfiguration");
var audioconfig = new AudioConfigurationClass();
var config_state = await audioconfig.getConfig();
config_state.mode = "prerouted"
config_state.srcRate = 48000;
await audioconfig.applyConfig(config_state);
```
----
developers\developers\player-apis\javascript-apis\audiooutput.md
# audiooutput

This object allows individual control of audio outputs on the player.

**audiooutput IDL**

```
    constructor(String output_name)
] interface AudioOutput {
            attribute float volumeLinear;
            attribute float volumeDb;
            attribute long delay;   
            attribute float treble; 
            attribute float bass;   
            attribute boolean mute;
   readonly attribute string name;
};
```

## Object Creation

To create an *audiooutput* object, use the `require()` method.

You must also enter an `AudioOutputClass` (in the example below, "analog" is used). The `AudioOutputClass` parameter can take the following strings:

*   `“none”`
    
*   `"hdmi”` or `"hdmi-1"`, `"hdmi-2"`, `"hdmi-3"`, or `"hdmi-4`" for Series 5 players with multiple outputs
    
*   `“usb”`
    
*   `“spdif”`
    
*   `"analog"` 
    
*   `“analog:N”`
    
*   `"earc"` (AU335 only)
    
*   Support for multiple USB outputs using the USB port naming terminology. See [roDeviceInfo-getusbtopology](../../../developers/brightscript/object-reference/system-objects/rodeviceinfo.md)
    

```
var AudioOutputClass = require("@brightsign/audiooutput");
var audiooutput = new AudioOutputClass("analog");
```

## AudioOutput

Use this interface to create *audiooutput* objects.

*   `volumeLinear` float: Sets the linear volume of the specified output as a percentage represented by a floating point number between 0 and 1 (1.0 is 100%).
    
*   `volumeDb` float: Sets the volume in decibels of the specified output as a percentage represented by a floating point number where 0.0 is 100%
    
*   `delay` long: On Series 3 and 4 players, delays the audio for a specific audio output by lagging decoded samples before they reach that output. Delays are in milliseconds.
    
*   `treble` float: On Series 3 and 4 players, sets the treble of the specified output in decibels. The treble floating point numbers can range from -10 to 10, with 0 indicating no modification to the audio signal. 
    
*   `bass` float: On Series 3 and 4 players, sets the bass of the specified output in decibels. The bass floating point numbers can range from -10 to 10, with 0 indicating no modification to the audio signal. 
    
*   `mute` boolean: Mutes the specified output if True. This method is set to False by default.
    
*   `name` string: The name of the output.
    
*   `plugState` boolean: Has a value of `true` if the corresponding output has a plug in it, `false` if it does not, or `undefined` if the plug state cannot be determined on the current hardware or OS version. This is supported by BOS 9.0.163 onwards.
----
developers\developers\player-apis\javascript-apis\brightsign-asset-pool\brightsign-asset-pool-example.md
# BrightSign Asset Pool Example

This script shows how the BrightSign Asset Pool can be used from JavaScript. It works from both NodeJS and Chromium. It is not intended as a full application and it doesn’t do anything with the assets that are downloaded.  

```
// MIT License
//
// Copyright (c) 2020 BrightSign
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// Customise these settings for your environment
const storagePath = "/storage/sd/";
const poolPath = storagePath + "examplePool";
const serverPrefix = "https://github.com/brightsign/javascript-assetpoolfetcher/blob/video-training/";

const fs = require('fs');
const AssetPool = require("@brightsign/assetpool");
const AssetPoolFiles = require("@brightsign/assetpoolfiles");
const AssetFetcher = require("@brightsign/assetfetcher");
const AssetRealizer = require("@brightsign/assetrealizer");

// Create the asset collection array to be used by the rest of the
// program. The asset collection will usually come either directly or
// indirectly from a server somewhere rather than being generated in
// code like this.
function makeAssetCollection()
{
    // Assets must have a name and a link. Everything else is
    // optional. You can add your own properties if required. For
    // example, the "osUpdate" property here is only used by this
    // script.
    let videoAsset1 = {
	name: "brightlink.mp4",
	hash: { method: "SHA256",
		hex: "82e5e800ff4b2608ae996b6c9fce78c0d84b82cba0da270251846324f48fb076" },
	link: serverPrefix + "brightlink%201min.mp4?raw=true",
	size: 17219989,
    };

    let videoAsset2 = {
	name: "CMScontrol.mp4",
	hash: { method: "SHA512",
		hex: "d476296b114fda612917b1568a9f7ffe6f54f3f927b2d1ecc932816e912619eeef980e1adc16d8b1d7914d3f172cd6a2ef17172ea3251ddcdbb3d151faa6818f" },
	link: serverPrefix + "CMS%2BControl%201%20min.mp4?raw=true",
	size: 5633877,
    };

    // We don't want to risk actually changing the OS version on the
    // BrightSign running this example cript, so this is not a real
    // BrightSignOS file. It will be realized into the root of the
    // storage device, but the OS will fail to find the expected
    // header and rename it to placeholder.bsfw_invalid.
    let osUpdateAsset = {
	name: "placeholder.bsfw",
	hash: { method: "SHA1", hex: "20e89c9ba0491590e3c34bc704171c0c02e643c3" },
	link: serverPrefix + "placeholder.bsfw?raw=true",
	size: 43,
	osUpdate: true,
    };

    let assetCollection = [
	videoAsset1,
	videoAsset2,
	osUpdateAsset,
    ];

    return assetCollection;
}

// Convert a progress event to a useful string for reporting
function progressString(event)
{
    if (event.currentFileTotal === undefined) {
	// If the size of the asset was not specified in the asset collection, then the total size may not be reported
	// during the fetch.
	return event.currentFileTransferred.toString() + " of unknown";
    } else {
	return event.currentFileTransferred.toString() + " of " + event.currentFileTotal.toString() + " "
	    + (100*event.currentFileTransferred / event.currentFileTotal).toFixed(0) + "%";
    }
}

// Download any assets that aren't already in the pool into the pool
// whilst reporting progress.
async function fetchAssets(assetPool, assetCollection)
{
    console.log("Fetch: " + JSON.stringify(assetCollection.map(asset => asset.name)));

    let assetFetcher = new AssetFetcher(assetPool);

    assetFetcher.addEventListener("fileevent", (event) => {
	// This is called each time the fetcher has finished trying to
	// download an asset, whether successful or not. It is not
	// called for any assets that are already in the pool.
	console.log("ASSET [" + (event.index + 1).toString() + "] "
		    + event.fileName + " complete: " + event.responseCode.toString() + " " + event.error);
    });

    assetFetcher.addEventListener("progressevent", (event) => {
	// This is called at approximately the progress interval
	// specified in the options to indicate how far through the
	// download
	console.log("ASSET [" + (event.index + 1).toString() + "/" + event.total.toString() + "] " + event.fileName
		    + " progress: " + progressString(event));
    });

    const fetchOptions = {
	// receive asset progress events about every five seconds.
	progressInterval: 5,
	// try to download each asset three times before giving up.
	fileRetryCount: 3,
	// Give up if we fail to download at least 1024 bytes in each
	// ten second period.
	minimumTransferRate: { bytesPerSecond: 1024, periodInSeconds: 10 },
    };

    try {
	await assetFetcher.start(assetCollection, fetchOptions);
    }
    catch (err) {
	console.log("FETCH FAILED: " + err.message);
	throw(err);
    }
}

// In order to make use of an asset from the pool you need to look up
// its pool filename so you can refer to it there.
async function useAssets(assetPool, assetCollection)
{
    let files = new AssetPoolFiles(assetPool, assetCollection);

    for (const fileName of [ 'brightlink.mp4', 'CMScontrol.mp4' ]) {
	const path = await files.getPath(fileName);
	console.log("Asset " + fileName + " is at " + path);
    }
}

// Some files need to appear in the filesystem outside the pool. For
// example, BrightSignOS update files must be written to the root of
// a storage device for them to be found. Realizing will copy files,
// so can be slow on large files.
async function realizeAssets(assetPool, assetCollection)
{
    let realizer = new AssetRealizer(assetPool, storagePath);

    // We only want to realize the files that we have to
    const assetsToRealize = assetCollection.filter(asset => asset.osUpdate);
    console.log("Realize: " + JSON.stringify(assetsToRealize.map(asset => asset.name)));
    await realizer.realize(assetsToRealize);
}

function ensureDirectoryExists(path) {
    try {
	fs.mkdirSync(path);
    } catch (err)
    {
	if (err.code != 'EEXIST')
	    throw(err);
    }
}

function exceptionToString(err)
{
    if (err instanceof Error)
        return err.name + ":" + err.message;
    else if (typeof(err) === "string")
        return err;
    else
        return JSON.stringify(err);
}

async function runExample()
{
    console.log("Start");
    ensureDirectoryExists(poolPath);

    // Only one AssetPool instance should be created for a given pool
    // path. Having multiple instances risks them disagreeing over
    // which assets are protected during pruning.
    let assetPool = new AssetPool(poolPath);

    // Don't let the pool grow any larger than 500MiB
    await assetPool.setMaximumPoolSize(500 * 1024 * 1024);

    // Don't let free space on the storage device fall below 100MiB
    await assetPool.reserveStorage(100 * 1024 * 1024);

    const assetCollection = makeAssetCollection();

    // We need to stop the fetcher from pruning any of the assets we
    // currently care about in order to make space for fetching new
    // assets or realizing existing ones. Assets are protected until
    // the AssetPool instance is destroyed or unprotectAssets is
    // called for the same name.
    await assetPool.protectAssets("collection1", assetCollection);

    await fetchAssets(assetPool, assetCollection);

    // In this case any failure to fetch the assets will cause
    // fetchAssets to have thrown an exception, so we won't get this
    // far. However, in a larger script it may be more convenient to
    // call areAssetsReady to determine whether the asset collection
    // is ready for use.
    if (await assetPool.areAssetsReady(assetCollection)) {
	await useAssets(assetPool, assetCollection);
	await realizeAssets(assetPool, assetCollection);
    } else {
	console.log("Assets were not downloaded successfully");
    }
}

runExample()
    .then(() => {
	console.log("Complete");
	process.exit(0);
    })
    .catch((err) => {
	console.log("Failed " + exceptionToString(err));
	process.exit(1);
    });
```
----
developers\developers\player-apis\javascript-apis\brightsign-asset-pool\brightsign-asset-pool.md
# BrightSign Asset Pool

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Table of Contents

*   [Core Concepts](#core-concepts)
*   [Managing Pool Size](#managing-pool-size)
*   [Referring To Assets In The Pool](#referring-to-assets-in-the-pool)
*   [Hash Uniqueness](#hash-uniqueness)
*   [Asset Metadata](#asset-metadata)
*   [Hashing](#hashing)
*   [Usage Overview](#usage-overview)
*   [Example](#example)

The BrightSign Asset Pool provides a reliable and resilient mechanism for downloading, storing and retrieving media assets and other files required by the player for its presentations.

## Core Concepts

### The Pool

An asset pool is a directory hierarchy under a single root. The directory is often simply named "pool", but the underlying implementation does not require that. Each asset is stored in one of a number of sub-directories to improve performance on simple filesystems like FAT.

The destination for a particular asset in the pool is determined by its [hash](https://en.wikipedia.org/wiki/Cryptographic_hash_function) (or digest) of its contents (or, in some cases, a hash of its metadata) which makes it a content-addressable store. In order to refer to an asset either before or after it has been downloaded it is necessary to know its hash. (This is similar to the way that objects are stored in a Git repository.)

The pool can be configured with a maximum size and/or to ensure that a particular amount of space remains free on the storage device that contains it. In order to stop the pool growing beyond these bounds old files are "pruned". Files that must not be pruned must be "protected" before any operations are started that may write to the pool.

An asset that is stored in the pool using a particular hash will only be stored once until it is pruned. Requests to download an asset that is already in the pool will immediately succeed since the asset is already present. This means that switching between presentations that share assets, even perhaps ones that haven't been used for a while, can avoid downloading assets unnecessarily.

### Asset Collections

An asset collection is a list of asset metadata. The metadata either directly contains the hash as a specific field or the hash can be generated directly from other fields. The metadata also provides a name for each asset which allows assets and therefore files in the pool to be looked up by name. An asset collection is necessary to provide meaning for the assets stored in the pool. Asset collections themselves exist only in memory and are not stored in the pool itself.

### Synchronization Specification

Synchronization specifications are often refered to as "sync specs". They consist of formatted XML or JSON that can be used to generate an asset collection but also have space for extra information that can be useful when downloading assets. They are not recommended unless compatibility with existing systems that use them is required.

### Asset Fetcher

An asset fetcher runs asynchronously downloading any assets mentioned in an asset collection that are not currently available in the pool. The file contents are automatically verified against the supplied hash during the download.

#### Protocols

Assets are expected to primarily be downloaded using HTTP or HTTPS. However, the fetcher also supports FTP and file URLs.

#### Authentication

Arbitrary HTTP headers can be provided when fetching all the assets in an asset collection. The fetcher supports HTTP Basic, Digest and NTLM authentication. Individual assets within a collection can be marked as opting out of providing these headers and authentication.

## Managing Pool Size

The pool is intended to live for a long time with assets being fetched into it as required. If the pool becomes too full then unused assets will be pruned to make space. This means that any assets that are still required (or will be required) must be protected before performing any operations that may prune such as fetching or realizing.

The pool size can be restricted in two ways:

*   by requiring that a certain amount of space on the storage device always be kept free. This means that space can be reserved for logs to grow into and any pool operations that can prune will ensure that at least the requested amount of space remains free. Checking the amount of free space on a storage device is a lightweight operation so this method should be preferred.
    
*   by setting a maximum size that the pool can occupy. This can be used in combination with the previous method and attempting to exceed either threshold will trigger pruning. Calculating the size of the pool requires adding up the size of each file individually, so the first operation can take longer than usual. Once the first calculation is complete the pool size is only updated based on modifications to the pool so subsequent operations have less overhead.
    

Files are considered for pruning based on how long ago they were last fetched, or would have been fetched had they not already been present in the pool. The least-recently fetched unprotected files will be pruned first. Note that unless the "working set" of assets is close to the maximum size of the pool this can often mean that any failures to protect assets have no ill effects.

## Referring To Assets In The Pool

Asset files can often be used directly from the pool. The pool filename corresponding to an asset can be looked up by name in an asset collection.

Sometimes it is necessary for the asset files to appear with their names within the filesystem. Asset files can be copied to a destination directory. This is known as "realization" and should only be used when necessary since it can be very slow. Alternatively, an asset collection can be made to appear as a virtual filesystem.

## Hash Uniqueness

The hash for a particular asset file must be unique. This happens automatically for normal hash algorithms such as SHA-256 since hash collisions should not be possible. If two files with different contents generate the same hash, this is known as a "hash collision". Some older hash algorithms such as MD5 and SHA-1 are known to have hash collisions, but these only occur when files have been deliberately constructed to create such collisions – they do not occur by accident.

Sometimes the actual hash of the asset is not available prior to the download. In this case parts of the asset metadata, such as the URL and a change hint are hashed together instead. If the asset changes then some part of the metadata must also change so that the asset fetcher knows to download the asset again.

It is not possible to use HTTP headers like ETag or Last-Modified as part of the hash since these aren't known prior to the download and can change independently.

## Asset Metadata

| Tag | Description |
| --- | --- |
| name | Relative filename (may contain slashes but if so the file may not be realized.) Asset names must be unique within an asset collection, but it is expected that different asset collections will contain assets with the same name. The asset name is not stored in the pool, and the same asset file in the pool may be referenced by multiple names, even within the same asset collection. |
| size | File length in bytes |
| hash | Hash algorithm and hash of file contents. |
| link | Source URL |
| change\_hint | An arbitrary value used by the client to ensure that files that have the same hash are not considered to be identical unless this value and the URL also matches. |
| auth | Specify extra authentication information (see below). |
| probe | Media probe data (useful for Cheetah and Panther). |
| pattern | Wildcard pattern to match against |

## Hashing

### Simple Hash Algorithms

md5, sha1, sha224, sha256, sha384, sha512

### BESHA1 Algorithm

This algorithm is only useful for referring to remote content that is too large to download during authoring. Its use is not recommended.

### No Hash

If no hash is specified then the hash is generated internally by hashing together the "link" and "change\_hint" fields.

## Usage Overview

The BrightSign asset pool can be used from BrightScript or from Javascript but it is not possible to share a single pool across both. However, the BrightScript `roHtmlWidget.MapFileFromAssetPool` method can be used to make a particular asset collection appear as files under a particular URI prefix.

### BrightScript

TBD

### Javascript

1.  Create @brightsign/assetpool object to represent the asset pool passing the path to the pool directory.
    
2.  Create the asset collection data structure. This is a Javascript array of objects containing the metadata for the assets you wish to use.
    
3.  Protect the assets by calling the assetpool.protectAssets method to stop them being deleted in order to make space.
    
4.  Create a @brightsign/assetfetcher object passing the pool.
    
5.  Call the assetfetcher.start method passing the asset collection. Any assets that are not present in the pool will start to be downloaded.
    
6.  Progress can be monitored by adding handlers for the progressevent and fileevent events.
    
7.  If the fetch attempt completes successfully then the promise returned by assetfetcher.start will be resolved. If at least one of the assets could not be fully downloaded then the promise will be rejected.
    
8.  When the promise returned by assetfetcher.start resolves, the fetch attempt is complete. 
    
9.  Create your set of assets as a Javascript array of objects containing the metadata.
    
10.  Create a @brightsign/assetfiles object passing the pool and asset collection.This object can be used to retrieve the full path to the files in the pool that correspond to the asset name specified. See [assetpoolfiles](https://docs.brightsign.biz/display/DOC/assetpoolfiles) for more information.
    
11.  Create a @brightsign/assetrealizer object passing the pool and call the realize method if you wish to copy assets from the pool to a directory using the asset names. Note that this is slow and is only recommended for files that must exist in the filesystem such as BrightSignOS upgrade files (bsfw).
    
12.  Create a @brightsign/assetcollectionview object passing the pool and the asset collection to create a virtual storage device containing the assets using the names and directory structure in the asset collection. See [assetpoolfiles](https://docs.brightsign.biz/display/DOC/assetpoolfiles) for more information.
    

## Example

[BrightSign Asset Pool Example](https://docs.brightsign.biz/display/DOC/BrightSign+Asset+Pool+Example) shows how the Asset Pool can be used from JavaScript. It works from both NodeJS and Chromium, and can be run from the BrightSign shell as follows:

```
node bs-assetpool-example.js
```
----
developers\developers\player-apis\javascript-apis\cec.md
# cec

The *cec* object lets you send messages over CEC (Consumer Electronics Control).

**cec IDL**

```
interface ReceiveEvent {
    attribute String type;
    attribute Array<byte> data;
};

callback ReceiveEventCallback = void (ReceiveEvent event);

interface Cec {
    Promise<void> send(Array<byte> data);
    void addEventListener(String type, ReceiveEventCallback callback);
    void removeEventListener(String type, ReceiveEventCallback callback);
};
```

## Object Creation

To create a *cec* object, load the *@brightsign/cec* module using the `require()` method. 

```
const CecClass = require('@brightsign/cec');
const cec = new CecClass();
```

Set the specific HDMI port for players with more than one output as follows:

```
const CecClass = require("@brightsign/cec");
const cec = new CecClass("HDMI-2"); //Modify this to be 'HDMI-1', 'HDMI-2', 'HDMI-3', and 'HDMI-4' as needed
```

## Cec

### Event

*   `ReceiveEvent`:  The CEC reception path is implemented as a receive event. The receive message has two generic fields:
    
    *   `type`:  The event type "receive"
        
    *   `data`:  Array<byte> CEC frame
        

### Method

##### send()

```
    Promise<void> send(Array<byte> data)
```

Sends messages over *cec.*

*   `data` Array<byte> : The CEC frame
    

##### port\_name ()

```
    Promise<void>
```

The parameters for this optional argument are:

*   `default`: The default output for the platform, normally `HDMI-1`
    
*   `HDMI-X`: X is a number from 1 up to the number of HDMI**®** outputs on the platform
    
*   `eARC`: The default for the AU335   
    

> [!NOTE]
> **Note**
> As of BrightSignOS 8.2.55, the CEC implementation for AU series 5 products will reply to these messages with the correct data, without involving the script:
> *   CEC\_MSG\_GET\_CEC\_VERSION
>     
> *   CEC\_MSG\_ABORT
>     
> *   CEC\_MSG\_GIVE\_DEVICE\_POWER\_STATUS
>     
> *   CEC\_MSG\_GIVE\_OSD\_NAME
>     
> *   CEC\_MSG\_GIVE\_DEVICE\_VENDOR\_ID
>     
> *   CEC\_MSG\_GIVE\_FEATURES
>     
> *   CEC\_MSG\_GIVE\_PHYSICAL\_ADDR
>     
> *   CEC\_MSG\_USER\_CONTROL\_PRESSED
>     
> *   CEC\_MSG\_USER\_CONTROL\_RELEASED
>     
> *   CEC\_MSG\_REPORT\_PHYSICAL\_ADDR

## Example

See the following example to send or receive CEC messages. See [BSCECTransmitter](../../player-apis/brightscript-javascript-objects/bscectransmitter.md) for an example that turns a display on and off.

```
const CecClass = require('@brightsign/cec');
const cec = new CecClass();

var initiatorAddress = 0x40;
var opcodeGetVersion = 0x9f;
var opcodeVersion = 0x9e;
var version = "";

function onRxEvent(packet) {
    let frame = packet.data;
    let opcode = frame[1];
    console.log("Frame Opcode: " + opcode);
    console.log(JSON.stringify(frame));
    if (opcode == opcodeVersion) {
        version = frame[2].toString(16);
        console.log("Version: " + version);
    }
}

function cecVersion() {
    return new Promise(async (resolve) => {
        version = "";
        let buffer =[];
        buffer[0] = initiatorAddress;
        buffer[1] = opcodeGetVersion;
        cec.send(buffer)
            .then(async function() {
                await (async () => new Promise(resolve => setTimeout(resolve, 1000)))();
                console.log("Version received: " + version);
                resolve();
            })
            .catch (function(error) {
                console.log("Ooops: " + error);
                resolve();
            });
    });
}

async function runtest() {
    cec.addEventListener("receive", onRxEvent);
    await cecVersion();
}
```
----
developers\developers\player-apis\javascript-apis\compositor.md
# compositor

The *compositor* object allows you to perform actions related to the video compositor.

**compositor IDL**

```
interface Compositor {
    void pause(int timeout_ms);
    void resume();
    int getCrc();
};
```

## Object Creation

To create a *compositor* object, first load the `brightsign/compositor` module using the `require()` method. Then create an instance of the *screenshot* class.

```
var CompositorClass = require("@brightsign/compositor");
var compositor = new CompositorClass();
```

## Compositor

##### pause()

```
void pause(int timeout_ms) 
```

Suspends graphics compositor updates for the specified number of milliseconds (or until the `resume()` method is called), up to a maximum interval of 10 seconds. While the graphics compositor is paused, no visual elements will be updated (except for [HWZ video](../../../developers/html-development/html-video.md), [scrolling tickers](../../../developers/brightscript/object-reference/presentation-and-widget-objects/rotextwidget.md), and off-screen Chromium textures). Use this method to combine intensive graphics and layout operations into a single v-sync update.

##### resume()

```
void resume()
```

Resumes the graphics compositor if it has been paused with the `pause()` method.

##### getCrc()

```
int getCrc()
```

Returns the CRC of the Y and Cb signals as a single integer. This method allows the script to compare two moments in the graphics output: If the return values differ, then the output is not identical.
----
developers\developers\player-apis\javascript-apis\configurednetworks.md
# configurednetworks

The *configurednetworks* object provides an array of persistent configuration names, even if they are not active at present. The configurations may be accessed using *@brightsign/networkconfiguration* objects.

**configurednetworks IDL**

```
interface ConfiguredNetworks {
    Promise<Array<String>> getConfigurationNames();
};
```

## Object Creation

To create a *configurednetworks* object, load the *@brightsign/configurednetworks* module using the `require()` method:

```
var configurednetworksClass = require("@brightsign/configurednetworks");
var configurednetworks = new configurednetworksClass();
```

## ConfiguredNetworks

##### getConfigurationNames()

```
Promise<Array<String>> getConfigurationNames()
```

This method returns an array of persistent configuration names, even if they are not active at present.
----
developers\developers\player-apis\javascript-apis\controlport.md
# controlport

This *controlport* object is used to configure output levels on the I/O connector and monitor inputs and provides support for the BP200/BP900 USB button boards and GPIO ports. Typically, LEDs and buttons are attached to the GPIO connector on the BrightSign player or the BrightSign Expansion Module.

**controlport IDL**

```
    Constructor(String port)
] interface ControlPort {
    bool SetOutputValue(unsigned param);
    bool SetOutputValues(unsigned p1, unsigned p2, unsigned p3, unsigned p4);
    bool SetPinValue(unsigned pin, unsigned param);
    bool GetPinValue(unsigned pin);
    bool ConfigureAsInput(unsigned pin);
    bool ConfigureAsOutput(unsigned pin);
    void Close()
};
```

## Object Creation

To create an *controlport* object, use the `require()` method:

```
let control_port_class = require("@brightsign/legacy/controlport")
let control_port = new control_port_class("TouchBoard-0-GPIO");
```

The c*ontrolport* object is created with a parameter that specifies the port being used (`TouchBoard-0-GPIO` in the example above). The port parameter can be one of the following:

*   `BrightSign`: Specifies the onboard GPIO connector (including the SVC (GPIO12) button).
    
*   `Expander-GPIO`: Specifies the DB-25 connector on the BrightSign Expansion Module. If no BrightSign Expansion module is attached, then object creation will fail and Invalid will be returned.
    
*   `Expander-<n>-GPIO`: Specifies a [USB-to-GPIO device](https://www.brightsign.biz/digital-signage-products/accessories/USB-C-Cables) connected to the player. Multiple USB-to-GPIO devices can be controlled using separate *roControlPort* instances: The first device corresponds to `"Expander-0-GPIO"`, the second to `"Expander-1-GPIO"`, etc.
    
*   `Expander-DIP`: Specifies the eight DIP switches on the BrightSign Expansion Module. If no BrightSign Expansion module is attached, then object creation will fail and Invalid will be returned. Note that hot plugging the BrightSign Expansion Module is not supported.
    
*   `Touchboard-<n>-GPIO`: Retrieves events from the specified BP200/BP900 button board. Events are handled in the same manner as events from the BrightSign port.
    
*   `Touchboard-<n>-LED-SETUP`: Sets various LED output options for the specified BP200/BP900 button board.
    
*   `Touchboard-<n>-LED`: Sets the bits for each button on the specified BP200/BP900 button board. The bits indicate whether the associated LED should be on or off.
    

> [!NOTE]
> Since multiple BP200/BP900 button boards can be connected to a player simultaneously, the <n> value specifies the port enumeration of each board. The ordering of multiple attached boards is dependent on the order they appear in the data structure returned by [*roDeviceInfo.GetUSBTopology()*](../../../developers/brightscript/object-reference/system-objects/rodeviceinfo.md). An unspecified enumeration value is synonymous with a button board with an enumeration value of 0 (e.g. Touchboard-GPIO and Touchboard-0-GPIO are identical).

## ControlPort

##### SetOutputValue()

```
bool SetOutputValue(unsigned param)
```

Specifies the desired state of all outputs attached to the control port as bits in an integer. 

##### SetOutputValues()

```
bool SetOutputValues(unsigned p1, unsigned p2, unsigned p3, unsigned p4)
```

Configures buttons on a BP200/BP900 button board. This method can only be used when the c*ontrolport* object is instantiated with the `Touchboard-<n>-LED-SETUP` or `Touchboard-<n>-LED` parameter. See [BP200/BP900 Setup](https://docs.brightsign.biz/display/DOC/roControlPort#roControlPort-bp_setup) for more details.

The parameters are integer values.

##### SetPinValue()

```
bool SetPinValue(unsigned pin, unsigned param)
```

Returns a bool and configures either:

*   The output of the specified GPIO button and the value (either 0 or 1). If the button is not configured as an output, the resulting level is undefined. For example, `SetPinValue(0,1), SetPinValue(1,1), SetPinValue(2,1), SetPinValue(3,1) ... etc ...`
    
*   The LED output behavior on [BP200/B900 button boards](https://docs.brightsign.biz/display/DOC/roControlPort#roControlPort-bp_setup). In this case, the offset is the pin value and the bit-mask is the unsigned parameter.
    

##### bool GetPinValue()

Returns `true` if the specified input pin is active (low). Returns `false` if the pin is inactive (not connected or high).

##### bool ConfigureAsInput()

```
bool ConfigureAsInput(unsigned pin)
```

Marks the specified button as an input. If an invalid button number is passed, `false` will be returned. If successful, the function returns `true`. Input buttons are tri-stated and can be driven high or low externally.

##### bool ConfigureAsOutput()

```
bool ConfigureAsOutput(unsigned pin)
```

Marks the specified button as an output. If an invalid button number is passed, `false` will be returned. If successful, the function returns `true`. The output will be driven high or low depending on the current output state of the pin. See [this page](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370676258/XTx43+Hardware+Interfaces#XTx43HardwareInterfaces-gpio_table) for a table of pins and corresponding buttons for the onboard GPIO connector.

##### Close()

```
void Close()
```

Shuts down the c*ontrolport* instance

## Events

Use [addEventListener](../javascript-apis/javascript-event-handling.md) to listen for controldown, controlup, and controlevent.

## Example

This example script sets a BP900 to “twinkle” by turning off each button LED at a different point in the cycle:

```
const control_port_class = require('@brightsign/legacy/controlport');
const led = new control_port_class("TouchBoard-0-LED");
const led_setup = new control_port_class("TouchBoard-0-LED-SETUP");

led_setup.SetPinValue(0, 0x000B00A0);

led.SetPinValue(0, 0x07fe);
led.SetPinValue(1, 0x07fd);
led.SetPinValue(2, 0x07fb);
led.SetPinValue(3, 0x07f7);
led.SetPinValue(4, 0x07ef);
led.SetPinValue(5, 0x07df);
led.SetPinValue(6, 0x07bf);
led.SetPinValue(7, 0x077f);
led.SetPinValue(8, 0x06ff);
led.SetPinValue(9, 0x05ff);
led.SetPinValue(10, 0x03ff);
```
----
developers\developers\player-apis\javascript-apis\cookiestore.md
# cookiestore

The *cookiestore* object retrieves a list of cookies from the containing browser (which implies that this class is only available for code running inside a browser instance, not from roNodeJs).

**cookiestore IDL**

```
interface Cookie {
    attribute String domain;
    attribute String path;
    attribute String name;
    attribute String value;
};
 
interface cookiestore {
    Array<Cookie> getCookies();
}
```

## Object Creation

```
let CookieStoreClass = require("@brightsign/cookiestore");
let cookieStore = new CookieStoreClass();
```

## Cookie

##### getCookies()

```
    Array<Cookie> getCookies()
```

Gets cookies from the containing browser.

*   `domain` string:  Specifies the hosts that are allowed to receive the cookie, including subdomains.
    
*   `path` string: To send the Cookie header, this URL path must exist in the URL request. 
    
*   `name` string: The name of the cookie
    
*   `value` string: The value of the cookie
    

## Example

To list the cookies saved on a browser instance on a console:

```
let CookieStoreClass = require("@brightsign/cookiestore");
let cookieStore = new CookieStoreClass();

let cookies = cookieStore.getCookies();

cookies.forEach((cookie) => {console.log("Cookie domain: " + cookie.domain + " Cookie path:" + cookie.path + " Cookie name:" + cookie.name + " Cookie value:" + cookie.value)});
```
----
developers\developers\player-apis\javascript-apis\decoderconfiguration.md
# decoderconfiguration

The *decoderconfiguration* object allows you to configure video decoders for Mosaic Mode.

**decoderconfiguration IDL**

```
interface DecoderConfiguration {
    Promise<DecoderConfigRead> getConfig();
    Promise<void> applyConfig(DecoderConfig config);
};

interface DecoderConfigWritable {
    attribute String name;
    attribute String friendlyName;
    attribute String configuredSize;
    attribute int zIndex;
    attribute bool mosaicDeinterlace;
};

interface DecoderConfig : DecoderConfigWritable {
    attribute String maxSize;
    attribute String mode;
    attribute int usageCount;
    attribute int maxUsage;
};
```

## Object Creation

To create a *decoderconfiguration* object, first load the `brightsign/decoderconfiguration` module using the `require()` method. Then create an instance of the *decoderconfiguration* class.

```
var DecoderConfigurationClass = require("@brightsign/decoderconfiguration");
var decoderConfig = new DecoderConfigurationClass();
```

## DecoderConfiguration

Use this interface to retrieve and modify video decoder data.

##### getConfig()

```
Promise <DecoderConfigArray> getConfig() 
```

Returns an array of *DecoderConfig* interfaces. Each interface describes a video decoder.

##### applyConfig()

```
Promise <void> applyConfig(DecoderConfigArray config) 
```

Configures video decoder(s) for either standard mode or Mosaic mode. In standard mode, a single decoder is used to play a single video; in Mosaic mode, the decoder can be used to decode multiple videos from different local or remote sources. This method accepts an array of *DecoderConfig* interfaces–attributes that are read-only (e.g. `maxSize`) will be ignored.

The system software selects which video decoder to use based on the resolution probed from the video file. In standard mode, it will attempt to select the decoder that has the closest maximum supported resolution (i.e. 1920x1080 for the HD decoder and 3840x2160 for the 4K decoder), without exceeding that maximum resolution. If a decoder has been configured for Mosaic mode, it will match the video resolution against the specified `configuredSize` instead. If two decoders support the same maximum resolution, you can select a decoder manually using the `friendlyName` attribute.

To select a decoder for an HTML video, include the `decoder:[Friendlyname]` property with the  [hwz attribute](../../../developers/html-development/html-video.md):

```
<video hwz= "decoder:main-video;" > </video>
<video hwz= "decoder:sd-video;" > </video> 
```

The `maxUsage` value of a decoder determines how many video players can be assigned to the decoder using the system software algorithm described above—video players beyond the  `max_usage` limit may be assigned to another decoder or not displayed at all. On the other hand, if you manually assign video players using the `friendly_name` of the decoder, you can assign more video players to the decoder than the `max_usage` limit, but this may cause unpredictable video-display behavior.

## DecoderConfig

This interface contains the settings of a video decoder. It contains both editable and read-only attributes.

### Editable

*   `name` string: The system name of the video decoder (decoder availability differs by model):
    
    *   "4K1": The primary 4K decoder (XTx44 models only)
        
    *   "4K2": The secondary 4K decoder (XTx44 models only)
        
    *   "4K": The sole 4K decoder (HDx24, XTx43, 4Kx42, XDx34, and XDx33 models only)
        
    *   "HD1": The first HD decoder
        
    *   "HD2": The second HD decoder
        
*   `friendlyName` string: A name for referencing the decoder in HTML or BrightScript
    
*   `configuredSize` string: The maximum resolution that the decoder will accept (at framerates up to 60p). If this resolution is the same as the decoder's maximum resolution limit, the decoder will use standard mode; otherwise, it will use Mosaic mode.
    
    *   "4K": 3840x2160
        
    *   "HD": 1920x1080
        
    *   "SD": 720x576
        
    *   "CIF": 352x288
        
    *   "QCIF": 176x144
        

> [!CAUTION]
> **Important**
> Upscaling videos in Mosaic mode currently causes severe performance degradation.

*   `zIndex` int: The z-index of the video window (in standard mode) or group of video windows (in Mosaic mode) relative to the graphics plane:
    
    *   1: The video window (or group of windows) is positioned in front of the graphics plane.
        
    *   \-1: The video window (or group of windows) is positioned behind the graphics plane.
        
*   `mosaicDeinterlace` bool: A flag indicating whether Mosaic-mode videos can be interlaced or not. Enabling the deinterlacer will allow playback of interlaced videos in Mosaic mode, but will reduce the number of Mosaic-mode videos that can be decoded simultaneously as well.
    

### Read-Only

*   `maxSize` string: The maximum resolution of the decoder, as set by system software. This value can be either "4K" or "HD"
    
*   `mode` string: The current mode of the decoder, which can be either `"regular"` or `"mosaic"`
    
*   `usageCount` int:  The number of videos currently being decoded by the decoder
    
*   `maxUsage` int: The maximum number of videos that can be decoded simultaneously by the decoder (this value is always 1 in `"regular"` mode). The optimum `max_usage` limits are described below; the limit may be lower depending on a number of factors, including interlacing and frame rate.
    
    *   4K decoder:
        
        *   1 4K video
            
        *   2 HD videos
            
        *   4 SD videos
            
        *   8 CIF videos
            
        *   10 QCIF videos
            
    *   HD decoder:
        
        *   0 4K videos
            
        *   1 HD video
            
        *   3 SD videos
            
        *   4 CIF videos
            
        *   5 QCIF videos
            

## Example

This script retrieves the current video decoder configuration and modifies it so that the 4K decoder can be used to decode 2 HD videos.

```
var DecoderConfigurationClass = require("@brightsign/decoderconfiguration");
var decoderConfig = new DecoderConfigurationClass();

function findDecoder(element) {
    return element.name === "4K";
};

function setDecoder(decoderList) {
    decoder = decoderList.find(findDecoder);
    decoder.friendlyName = "main-video";
    decoder.configuredSize = "HD";
    decoder.zIndex = 1;
    decoderConfig.applyConfig(decoderList).then()
        .catch(
            function(data) {
                console.log(JSON.stringify(data));
            });
};

decoderConfig.getConfig().then(
        function(data) {
            setDecoder(data);
        })
    .catch(
        function(data) {
            console.log(JSON.stringify(data));
        });
```
----
developers\developers\player-apis\javascript-apis\devicecustomization.md
# devicecustomization

This object provides a method to encrypt storage and is released in BOS version 9.0.146.

**devicecustomization IDL**

```
interface DeviceCustomization {
    Promise<void> encryptStorage(String device, StorageEncryptionOptions params);
};

interface StorageEncryptionOptions {
attribute String method;
attribute String passphrase;
attribute Boolean format;
};
```

## Object Creation

```
let DeviceCustomizationClass = require("@brightsign/devicecustomization");
let devicecustomization = new DeviceCustomizationClass();
```

## DeviceCustomization

##### encryptStorage()

```
Promise<void> encryptStorage(String device, StorageEncryptionOptions params)
```

Encrypts the contents of a storage device using an encryption key stored in the private section of the player registry. This prevents other devices from reading the names or contents of files on the storage device (though file metadata will still be readable). The storage device can still be mounted on other devices, which can list, delete, and copy files (even though they cannot read them).

The device parameter specifies which storage drive to encrypt (for example, `/storage/sd`, `/storage/usb1` or `/storage/ssd`), and the process is configured with the passed *StorageEncryptionOptions* parameters.

## StorageEncryptionOptions

##### Attributes

*   `method` string: The encryption method, which can be one of the following:
    
    *   `"none"`: Encryption is disabled and any encryption keys for the storage device are deleted from the registry. 
        
    *   `"passphrase"`: The storage device is encrypted using an un-obfuscated passphrase.
        
    *   `"obfuscated_passphrase"`: The storage device is encrypted using an obfuscated passphrase. Contact [support@brightsign.biz](mailto:support@brightsign.biz) to learn more about generating a key for obfuscation and storing it on the player. 
        
    *   `"brightsign_key"`: The storage device is encrypted using an encryption key that is common to all BrightSign players, but is not shared with outside parties. 
        
    *   `"generate_key"`: The storage device is encrypted using an encryption key that is generated on-demand using a secure random generator. The private registry of the player contains the only copy of the key; if the value in the registry is erased or becomes corrupted, there will be no way to recover data from that storage device. The private registry does not distinguish between different physical volumes of the same drive. For example, if you encrypt two SD cards, the key for the first SD card will be overwritten when the second SD card is encrypted; in the case of a randomly generated key, the data from the first SD card will be irretrievable.
        
*   `passphrase` string: The passphrase for encrypting the storage device. This parameter must be included if the method is specified as `"passphrase"` or `"obfuscated_passphrase"`. 
    
*   `format` boolean: Setting this parameter to `true` will cause the specified storage device to be reformatted–all existing files will be deleted (but are not guaranteed to be securely erased) before the device is encrypted; however, if the device cannot be reformatted, the operation will fail. If this parameter is set to `false`, the storage device will be mounted as if it has been previously encrypted using the supplied key.
    
    *   If the storage device hasn't been previously encrypted, it will be encrypted while leaving any preexisting files unencrypted. If the storage device has been encrypted using a different key, the operation will fail.
        
    *   If the `format` parameter is not specified, the storage device will be mounted as if it has been previously encrypted using the supplied key. If the storage device hasn't been previously encrypted, the operation will fail.
----
developers\developers\player-apis\javascript-apis\deviceinfo.md
# deviceinfo

The *deviceinfo* object lets you identify device hardware, firmware, and features.

**deviceinfo IDL**

```
interface DeviceInfo {
    attribute String model;
    attribute String osVersion;
    attribute String bootVersion;
    attribute String serialNumber;
    attribute String family;
    
    int osVersionCompare(String version);
    int bootVersionCompare(String bootVersion);
    bool osVersionIsAtLeast(String version);
    bool bootVersionIsAtLeast(String bootVersion);
    bool hasFeature(String feature);
    Promise <String> getLoadStatistics(String item);
    Promise <TemperatureLocation> getTemperature();
    Promise <UsbTopologyInterface> getUsbTopology();
};

dictionary TemperatureLocation {
    float celsius;
};

interface UsbTopologyInterface {
    attribute String vid;
    attribute String pid;
    attribute String raw;
    attribute String fid;
    [optional] attribute String category;
    [optional] attribute String ident;
    attribute Array<UsbTopologyInterface> children;
};

```

## Object Creation

To create a *deviceinfo* object, load the `@brightsign/deviceinfo` module using the `require()` method. 

```
diClass = require("@brightsign/deviceinfo");
di = new diClass(); 

```

## DeviceInfo

##### getLoadStatistics()

```
Promise <String> getLoadStatistics(String item)
```

Provides current performance information related to the Linux kernel. The `item` can be any of the following:

*   `loadavg`: Provides information about system performance. The first three columns measure CPU and I/O utilization over the past 1, 5, and 10 minutes, respectively. The fourth column displays the number of currently running processes and the total number of processes. The last column displays the ID of the most recently used process.
    
*   `meminfo`: Displays physical and swap memory usage
    
*   `slabinfo`: Provides information about memory usage at the slab level
    
*   `stat`: Provides overall statistics about the system (for example, the number of page faults since the system booted)
    
*   `vmstat`: Displays detailed virtual memory statistics from the kernel
    
*   `zoneinfo`: Provides overall statistics about the system, broken down by system Node
    
*   `interrupts`: Displays which interrupts are in use and how many of each type there have been
    
*   `version`: Provides the kernel version
    

##### getTemperature()

```
<TemperatureLocation> getTemperature()
```

Returns:

*   `key` string:  A dynamic string location key
    
*   `value` float: The device temperature as a floating point value
    

##### getUsbTopology()

```
<UsbTopologyInterface> getUsbTopology()
```

Gets the USB topology of the player.

These attributes return information about the BrightSign player:

*   `model` string: Returns the model name for the BrightSign device running the script, as a string (for example, "HD1020" or "XD230").
    
*   `osVersion` string: Returns the OS version number for the BrightSign device running the script.
    
*   `bootVersion` string: Returns the version number of the BrightSign boot firmware, also known as "safe mode", as a string (for example, "1.0.4").
    
*   `serialNumber` string: Returns the device serial number which, if not an empty string, is unique to the unit running the script.
    
*   `family` string: Returns a single string that indicates the family to which the device belongs. A device family is a set of models that are all capable of running the same firmware.
    

##### osVersionCompare()

```
int osVersionCompare(String version)
```

This function returns an integer greater than zero if the current OS version is greater than the parameter, 0 if it is exactly equal, or less than zero if lesser. For example:

```
if (di.osVersionCompare("8.2") > 0) { console.log("Firmware version is greater than 8.2") }
```

or:

```
if (di.osVersionCompare("8.4") < 0) { console.log("Firmware version is less than 8.4") }
```

##### bootVersionCompare()

```
int bootVersionCompare(String bootVersion)
```

This function returns an integer greater than zero if the current boot loader version is greater than the parameter, 0 if it is exactly equal, or less than zero if lesser (see the examples for `osVersionCompare()`). 

##### osVersionIsAtLeast()

```
bool osVersionIsAtLeast(String version)
```

Returns `True` if the BrightSign OS version on the device is greater than or equal to the version number represented by the passed string (for example, "4.0.13").

##### bootVersionIsAtLeast()

```
bool bootVersionIsAtLeast(String bootVersion)
```

Returns `True` if the BrightSign boot OS version on the device is greater than or equal to the version number represented by the passed string (for example, "4.4.22").

##### hasFeature()

```
bool hasFeature(String feature)
```

Returns `True` if the player feature in the passed string (which is passed as a case-insensitive string parameter) is present on the current device and firmware. The possible features that can be queried from the script are listed below:

> [!CAUTION]
> **Important**
> If you pass a parameter other than one of those listed below, it may return False even if the feature is available on the hardware and firmware.

`"5v serial"`: A 5V serial port

`"audio1"`: The first audio output

`"audio2"`: A second audio output

`"audio3"`: A third audio output

`"brightscript1"`: BrightScript Version 1

`"brightscript2"`: BrightScript Version 2

`"component video"`: A component video output

`"ethernet"`: An Ethernet interface

`"gpio connector"`: A DA15 or Pheonix-style GPIO port 

`"hdmi"`: An HDMI**®** output

`"hdmi input"`: An HDMI input

`"hevc_decode"`: An H.265 video decoder

`"media_decryption"`: The ability to decrypt AES-encrypted media, including video, image, and audio files.

`"nand storage"`: NAND storage for the boot loader and firmware

`"networking"`: Any form of networking capability. A False return may indicate that no network is currently available.

`"reset button"`: A reset button

`"registry"`: On-board persistent storage

`"rtc"`: A real-time clock (RTC)

`"sd"`: SD- or SDHC-compatible storage

`"sdhc"`: SDHC-compatible storage only

`"serial port 0"`: The first serial port

`"serial port 1"`: A second serial port

`"serial port 2"`: A third serial port

`"svc button"`: A service ("SVC") button. Passing the legacy term `"gpio12 button"` will yield the same result.

`"usb"`: One or more USB interfaces

`"vga"`: A VGA output

`"video_encoder"`: A video encoder/transcoder

## TemperatureLocation

*   `celsius` float: Returns the temperature of the device in celsius, as a floating point number.
    

## UsbTopologyInterface

These attributes return the USB topology of the player, which can be used to determine whether certain USB devices are connected to certain ports. 

*   `vid` string:  Four character strings encoding the Vendor ID and Product ID in hexadecimal.  Leading zeros are present and alpha characters are lower case (for example, vid = "0b95").
    
*   `pid` string: Four character strings encoding the Vendor ID and Product ID in hexadecimal.  Leading zeros are present and alpha characters are lower case (for example, pid = "0b95").
    
*   `raw` string:  This is an internal (Linux) USB device node ID.
    
*   `fid` string:Ports that have USB devices connected to them will include a `fid` (friendly ID) value, which can be used to determine which physical port the USB device is connected to on the player. See [roDeviceInfo](https://docs.brightsign.biz/display/DOC/roDeviceInfo) for more information. 
    
*   `category`  string optional: This optional string describes the device type (for example, "HUB", "SERIAL", "NET", "HID", "AUDIO", or "OTHER").
    
*   `ident` string optional: This is an additional identifier. For devices of category "NET", the `ident` is the system network interface name (for example, "usb0").
    
*   `children` Array<<UsbTopologyInterface> optional: Children are present for devices of category "HUB". Child devices have the same structure, so nested hubs will produce nested child data.
    

## Example

This example returns the USB topology for the device:

```
diClass = require("@brightsign/deviceinfo");
di = new diClass();
 
usbTopology = await di.getUsbTopology();
 
parseTopology = function(usbT) {
  for(i in usbT) {
    let device = usbT[i];
    if (device.category === "HUB")
        parseTopology(device.children);   
    if (device.category === "NET")
        console.log("Found " + device.fid + " interface " + device.ident);
  }
};
 
parseTopology(usbTopology);
```

To replace BSDeviceInfo with the *deviceinfo* object:

```
if (typeof(BSDeviceInfo) === typeof undefined) 
{
  global.BSDeviceInfo = class BSDeviceInfo {
    constructor() {
      let fs = require('fs');
      let DeviceInfoClass = require('@brightsign/deviceinfo');
      let deviceInfo = new DeviceInfoClass();

      // Map properties and getters
      this.model = deviceInfo.model;
      this.version = deviceInfo.osVersion;
      this.bootVersion = deviceInfo.bootVersion;
      this.deviceUniqueId = deviceInfo.serialNumber;
      this.family = deviceInfo.family;
      Object.defineProperty(this, 'deviceUptime', {
          get: Object.getOwnPropertyDescriptor(deviceInfo, 'deviceUptime').get,
          enumerable: true,
      });
      // And methods
      this.VersionCompare = deviceInfo.osVersionCompare;
      this.BootVersionCompare = deviceInfo.bootVersionCompare;
      this.FirmwareIsAtLeast = deviceInfo.osVersionIsAtLeast;
      this.BootFirmwareIsAtLeast = deviceInfo.bootVersionIsAtLeast;
      this.HasFeature = deviceInfo.hasFeature;
      this.GetLoadStatistics = function(s) {
        let stats = new Set([ 'zoneinfo', 'loadavg', 'meminfo', 'stat', 'vmstat', 'interrupts', 'version', 'boardid' ]);
        var result  = 'n/a';
        if (stats.has(s)) {
          result = fs.readFileSync('/proc/' + s).toString();
        }
        return result;
      };
      // GetTemperature and GetUsbTopology are not present in the BSDeviceInfo class
    };
  };
}
```
----
developers\developers\player-apis\javascript-apis\devicestatus.md
# devicestatus

This object provides information about the device hardware, firmware, and features.

**devicestatus IDL**

```
interface devicestatus {
    Promise<BVNinformationList> getBVNPipelines();
    Promise<BVNinformationList> getBVNComponents();
    Promise<Powerinformation> getPowerStatus();
    Promise<ExtensionsinformationList> getExtensions();
    Promise<POEinformation> getPOEStatus();
};

interface Powerinformation {
    attribute String source;
    attribute String switch_mode;
    attribute String battery;
    attribute int soc_percent;
};

interface BVNinformation {
    attribute String name;
    attribute int index;
    attribute BVNRegisterList registers;
    attribute BVNPipelineList items;                //@Optional
};

interface BVNRegister {
    attribute String name;
    attribute int offset;
};

interface BVNPipeline {
    attribute String name;
};

interface Extensionsinformation {
    attribute String name;
    attribute int size;            //@Optional
    attribute String id;
};

interface POEpowerinformation {
    attribute float value;
    attribute String units;
};

interface POEinformation {
    attribute String status;
    attribute POEpowerinformation power;     //@Optional
};                                                                                                  
```

## Object Creation

To create a *devicestatus* object, load the *@brightsign/status* module using the `require()` method. 

```
var DeviceStatusClass = require("@brightsign/devicestatus");
var devicestatus = new DeviceStatusClass();
```

## devicestatus

##### getPowerStatus()

```
Promise<Powerinformation> getPowerStatus()
```

Returns the device battery status as "charging", "discharging", "complete", "absent", or "fault".

##### getExtensions()

```
Promise<ExtensionsinformationList> getExtensions()
```

Returns a promise which yields an object containing an `extensions` array with each element containing at least a `name` field. Other fields may also be present, but should not be relied on.

##### getPOEStatus()

```
Promise<POEinformation> getPOEStatus()
```

Returns information about whether PoE (Power over Ethernet) network is supported, available, and/or active on a device.

## Powerinformation

*   `source` string:  Possible values are "battery", "Ethernet", or "AC"
    
*   `switch_mode` string: Returns "soft" or "hard"
    
*   `battery` string: Possible values are "charging", "discharging", "complete", "absent", or "fault"
    
*   `soc_percent` int: The state of charge of the battery in percent from 0 (empty) to 100 (full)
    

## Extensionsinformation

*   `name` string: The name of the extension
    
*   `size` int: Some extensions return a size and others do not. Players that have AC3 or E-AC3 licenses installed will report those as extensions but no size will be included.
    

## POEpowerinformation

*   `value` float: Returns the "Power value"
    
*   `units` string: returns the "Power value" units ("W")
    

## POEinformation

*   `status` string:  The status string can be "active", "standby", or "inactive"
    
*   `power` POEpowerinformation: See `POEpowerinformation` above for details.
    

## Example

To get the power status of a device:

```
var DeviceStatusClass = require("@brightsign/devicestatus");
var devicestatus = new DeviceStatusClass();

devicestatus.getPowerStatus().then(
        function(data){
                console.log(JSON.stringify(data));
        })
    .catch(
        function(data){
                console.log("Error: " + data);
        })
```
----
developers\developers\player-apis\javascript-apis\dwsconfiguration.md
# dwsconfiguration

The *dwsconfiguration* object allows you to configure the [Diagnostic Web Server](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370673541/Diagnostic+Web+Server) (DWS) on the player. By default, the Diagnostic Web Server is enabled on port 80, with the player serial number as password. The username is always "admin".

**dwsconfiguration IDL**

```
[
   GarbageCollected,
] interface DWS {
    DWSConfig defaultConfig();
    Promise<DWSConfig> getConfig();
    Promise<DWSResult> applyConfig(DWSConfigWritable config);
};

interface DWSConfig {
    attribute int port;
    attribute Password password;
    attribute Array<String> authenticationList;
};

interface DWSConfigWritable : DWSConfig {
    attribute Password password;
};

interface Password {
    attribute String value;
    attribute bool obfuscated;
};

interface DWSResult {
    attribute bool restartRequired;
};
```

## Object Creation

To create a *dwsconfiguration* object, first load the `brightsign/dwsconfiguration` module using the `require()` method. Then create an instance of the *dwsconfiguration* class.

```
var DWSConfigurationClass = require("@brightsign/dwsconfiguration");
var dwsConfig = new DWSConfigurationClass();
```

## DWS

Use this interface to retrieve and modify the DWS configuration.

##### getConfig()

```
Promise <DWSConfig> getConfig() 
```

Returns a `DWSConfig` interface containing current DWS-configuration information. If there is a set password, `getConfig()` will return True for the `password` parameter. If there isn't a set password, If there is a set password, `getConfig()` will return False for the `password` parameter.

##### applyConfig()

```
Promise <DWSResult> applyConfig(DWSConfigWritable config) 
```

Applies DWS-configuration settings to the player. This method accepts a `DWSConfig` interface. It returns a `DWSResult` interface that indicates whether or not a reboot is required for the changes to take effect (the caller is responsible for requesting the reboot). The `restartRequired` property of the `DWSResult` indicates whether the reboot is required.

The `config` parameter should contain the complete desired configuration. Any previous configuration is overwritten. If you wish to change one item while keeping the rest of the configuration the same, then call `getConfig` and modify the returned object (see the example in the Examples section).

## DWSConfig

This interface contains DWS configuration parameters:

*   `port` int: The port number of the DWS, located at the IP address of the player. The default for the DWS is port 80. Setting this value to 0 will disable the DWS. 
    
*   `password` Password: A `Password` interface containing password settings for the DWS. To enable the DWS without password protection, set `value` to an empty string and `obfuscated` to false.
    
*   `authenticationList` Array<String>: The authentication scheme for the DWS password. This entry currently accepts a single value only. The following are accepted values:
    
    *   `"basic"`: The password will be validated using basic authentication.
        
    *   `"digest"`: The password will be validated using digest access authentication.
        

> [!NOTE]
> **Note**
> To enable the DWS without password authentication, set the `password.value` to be an empty string and `password.obfuscated` to be false, when calling the `applyConfig()` method.

## DWSConfigWritable

*   `password` Password: A `Password` interface containing password settings for the DWS
    

## Password

This interface contains password settings for the DWS:

*   `value` String: The DWS password
    
*   `obfuscated` bool: A flag indicating whether the password string is obfuscated. Contact [support@brightsign.biz](mailto:support@brightsign.biz) to learn more about generating a key for obfuscation and storing it on the player.
    

## DWSResult

This interface contains results from an `applyConfig()` operation.

*   `restartRequired` bool: A flag indicating whether a reboot is required for changes to go into effect (the script must perform the reboot)
    

## Examples

```
var DWSConfigurationClass = require("@brightsign/dwsconfiguration");
var dwsConfig = new DWSConfigurationClass();

var configData = {};
var pw = {};

configData.port = 1010;
configData.password = pw;
configData.authenticationList = ["basic"];

pw.value = "password";
pw.obfuscated = false;

dwsConfig.applyConfig(configData).then(
        function(data) {
            console.log(JSON.stringify(data));
        })
    .catch(
        function(data) {
            console.log(JSON.stringify(data));
        });
dwsConfig.getConfig().then(
        function(data) {
            console.log(JSON.stringify(data));
        })
    .catch(
        function(data) {
            console.log(JSON.stringify(data));
        });
```

To change one item while keeping the rest of the configuration the same, then call `getConfig` and modify the returned object:

```
  var DWSConfigurationClass = require("@brightsign/dwsconfiguration");
  var dwsConfig = new DWSConfigurationClass();
  var pw = {};
  dwsConfig.getConfig()
  .then(function(config) {
    pw.value = "password";
    pw.obfuscated = false;
    config.password = pw;
    dwsConfig.applyConfig(config);
  })
  .then(function() {
    console.log("Success");
  })
  .catch(function(error) {
    console.log(JSON.stringify(error));
  });
```
----
developers\developers\player-apis\javascript-apis\filesysteminfile.md
# filesysteminfile

The *filesysteminfile* allows you to create and update filesystems for use as storage devices. 

**filesysteminfile IDL**

```
interface FileSystemInFile {
    constructor(String path);
    Promise<String> getFilename();
    Promise<long long> getSize();
    Promise<void> format(String fileSystem);
    Promise<void> mount();
    Promise<void> unmount();
};                                                                                                                  
```

## Object Creation

To create a *filesysteminfile* object, load the *@brightsign/filesysteminfile* module using the Node.js® require() method:

```
var FileSystemInFile = require('@brightsign/filesysteminfile');
var fsif = new FileSystemInFile("/storage/sd/usbstore.img"); // Node's native 'fs' can create an .img file                                                                                 
```

## filesysteminfile

Use this interface to configure a *filesysteminfile*.

##### getFilename()

```
Promise<String> getFilename()                                                                                                   
```

Gets the name of the file that was used to create *FileSystemInFile.*

##### getSize()

```
Promise<long long> getSize()                                                                                           
```

Retrieves the size (in bytes) of the filesystem file used to create the *FileSystemInFile* class.

##### format()

```
Promise<void> format(String fileSystem)                                                                                            
```

Creates the specified filesystem in a file that already exists. The supported filesystem types are "fat" and "exfat".

##### mount()

```
Promise<String> mount()                                                                                                 
```

Mounts the filesystem. There is no need to format the filesystem if it already exists and is formatted.

The return string is *filepath* and the return value is the path to where the filesystem has been mounted. It cannot be mounted more than once.

##### unmount()

```
Promise<void> unmount()                                                                                                 
```

Unmounts the filesystem.

## Example

The example below creates a file system, formats, mounts, and unmounts it using the npm package *fs*, 

```
const fs = require('fs');
const FileSystemInFile = require('@brightsign/filesysteminfile');

var fsif;
var fd;

open()
.then(function(fileDescriptor) {
	fd = fileDescriptor;
	return write(fd);
})
.then(function(bytes) {
	console.log(`${bytes} written to new file`);
	return close(fd);
})
.then(function() {
	// Create FileSystemInFile using the backing file
	fsif = new FileSystemInFile('/storage/sd/usbstore');

	return format();
})
.then(function() {
	return mount();
})
.then(function() {
	/* This is where you can actually do stuff with the mounted filesystem. */

	// Unmount the mounted file after 10 seconds
	setTimeout(function() {
		return unmount();
	}, 10000);
})
.catch(function(error) {
	console.log(JSON.stringify(error));
});


// Create a writable file for the file system
function open() {
	return new Promise(function(resolve, reject) {
		fs.open('/storage/sd/usbstore', 'w', function(error, fd) {
			if (error) reject(error);
			resolve(fd);
		});	
	});
};

// Write a buffer allocating 1GB of disk space for the file
function write(fd) {
	return new Promise(function(resolve, reject) {
		fs.write(fd, Buffer.alloc(1), 0, 1, (1024*1024*1024) - 1, function(error, bytesWritten) {
			if (error) reject(error);
			resolve(bytesWritten);
		});
	});
};

// Close the created file
function close(fd) {
	return new Promise(function(resolve, reject) {
		fs.close(fd, function(error) {
			if (error) reject(error);
			resolve();
		});
	});
};

// Format the file system
function format() {
	return new Promise(function(resolve, reject) {
		fsif.format("exfat")
		.then(function() {
		  console.log('Filesystem formatted');
		  resolve();
		})
		.catch(function(error) {
		  reject(error);
		});		
	});
};


// Mount the filesystem internally
function mount() {
	return new Promise(function(resolve, reject) {
		fsif.mount()
		.then(function(mount_point) {
		  console.log('Filesystem mounted' + mount_point);
		  resolve();
		})
		.catch(function(error) {
		  reject(error);
		});
	});
};

// Unmount filesystem from internal mount point. Only can unmount a mounted file
function unmount() {
	return new Promise(function(resolve, reject) {
		fsif.unmount()
		.then(function() {
		  console.log('Filesystem unmounted');
		  resolve();
		})
		.catch(function(error) {
		  reject(error);
		});
	});
};                                                                                    
```

You can also reference our public [github example](https://github.com/brightsign/usb-filesystem) which uses a BrightSign device as a filesystem over USB.
----
developers\developers\player-apis\javascript-apis\filesysteminfo.md
# filesysteminfo

The *filesysteminfo* object provides information about the file system of a storage device connected to the player. To retrieve information about the storage device itself, use the *storageinfo* object.

**filesysteminfo IDL**

```
[
    constructor(String path, String type);
] interface FilesystemInfo {
    Promise<bool> isReadOnly();
    Promise<String> getFilesystemType();
    Promise<FilesystemStats> getStatistics();
};

interface FilesystemStats {
    attribute Number blockSize;
    attribute Number sizeBytes;
    attribute Number bytesFree;
    attribute Number filesUsed;
    attribute Number filesFree;
    attribute bool isReadOnly;
};
```

## Object Creation

To create a *filesysteminfo* object, first load the `brightsign/filesysteminfo` module using the `require()` method. Then create an instance of the *filesysteminfo* class with a string value specifying the storage path.

```
var FileSystemInfoClass = require("@brightsign/filesysteminfo");
var fileSystemInfo = new FileSystemInfoClass("/storage/sd");
```

Use the following string values to specify different storage drives:

*   `"/storage/usb1"` – The drive for USB storage devices connected to the player
    
*   `"/storage/sd"` – The primary SD or microSD drive on the player.
    
*   `"/storage/sd2"` – The internal microSD drive on the player (4Kx42, XDx32 models only)
    
*   `"/storage/ssd"` – The internal SSD on the player (XTx44, XTx43, XDx34, and XDx33 models only)
    

## FilesystemInfo

Use this interface to retrieve information about the file system.

##### isReadOnly()

```
Promise<bool> isReadOnly()
```

Returns a Boolean value indicating whether the filesystem is read-only. 

##### getFilesystemType()

```
Promise <DOMString> getFilesystemType()
```

Returns the filesystem type or whether it is encrypted (“+ecryptfs”). The following are potential values:

*   "exfat"
    
*   "ext3"
    
*   "ext4"
    
*   "fat12"
    
*   "fat16"
    
*   "fat32"
    
*   "hfs"
    
*   "hfsplus"
    
*   "ntfs"
    
*   “+ecryptfs” (as of BOS version 9.0.145.1)
    

##### getStatistics()

```
Promise<FilesystemStats> getStatistics()
```

Returns a `FilesystemStats` interface containing information about the filesystem. This method can take a significant amount of time to return its promise.

## FilesystemStats

This interface contains information about the filesystem:

*   `blockSize` Number: The size of a native block
    
*   `sizeBytes` Number: The amount of total space
    
*   `bytesFree` Number: The amount of free space
    
*   `filesUsed` Number: The number of used inodes
    
*   `filesFree` Number: The number of free inodes
    
*   `isReadOnly` bool: A flag indicating whether the filesystem is read-only.
    

## Example

```
var FileSystemInfoClass = require("@brightsign/filesysteminfo");
var fileSystemInfo = new FileSystemInfoClass("/storage/sd");

fileSystemInfo.getFilesystemType().then(
        function(data) {
            console.log(JSON.stringify(data));
        })
    .catch(
        function(data) {
            console.log(JSON.stringify(data));
        });

fileSystemInfo.getStatistics().then(
        function(data) {
            console.log(JSON.stringify(data));
        })
    .catch(
        function(data) {
            console.log(JSON.stringify(data));
        });
```
----
developers\developers\player-apis\javascript-apis\hostconfiguration.md
# hostconfiguration

The *hostconfiguration* object allows you to retrieve information about network interfaces and Internet connectivity.

**hostconfiguration IDL**

```
interface NetworkHost {
    HostConfig defaultConfig();
    Promise<HostConfig> getConfig();
    Promise<void> applyConfig(HostConfigWritable config);
};

interface HostConfig {
    [optional] attribute String proxy;
    [optional] attribute Array<String> proxyBypassList;
    [optional] attribute Array<String> timeServerList;
    [optional] attribute String timeServerInterval;
    [optional] attribute String hostName;
	[optional] attribute bool loginPassword;
    [optional] attribute bool forwardingEnabled;
    [optional] attribute bool masqueradingEnabled;
	[optional] attribute Array<NatRule> natList;
};

interface HostConfigWritable : HostConfig {
    [optional] attribute String[or bool] loginPassword;
    [optional] attribute String[or bool] obfuscatedLoginPassword;
};

interface NatRule {
    attribute NatRuleMatch match;
    attribute NatRuleReplacement replace;
};

interface NatRuleMatch {
    attribute String protocol;
    [optional] attribute String sourceAddressRange;
    attribute String destinationAddressRange;
    attribute unsigned short destinationPort;
};

interface NatRuleReplacement {
    attribute String destinationAddress;
    attribute unsigned short destinationPort;
};
```

## Object Creation

To create a *hostconfiguration* object, first load the `brightsign/hostconfiguration` module using the `require()` method. Then create an instance of the *hostconfiguration* class.

```
var HostConfigurationClass = require("@brightsign/hostconfiguration");
var hc = new HostConfigurationClass();
```

## NetworkHost

Use this interface to retrieve and modify host configuration.

##### getConfig()

```
Promise<HostConfig> getConfig() 
```

Returns a `HostConfig` interface containing current host-configuration information.

##### applyConfig()

```
Promise<void> applyConfig(HostConfigWritable config)
```

Applies host-configuration settings to the player. This method accepts a `HostConfigWritable` interface.

The `config` parameter should contain the complete desired configuration. Any previous configuration is overwritten. If you wish to change one item while keeping the rest of the configuration the same, then call `getConfig` and modify the returned object (see the example in the Examples section).

## HostConfig

This interface contains host configuration parameters:

*   `proxy` String:  The name or address of the proxy server used for HTTP and FTP requests. The proxy string should be formatted as "[http://user:password@hostname:port](http://user:password@hostnameport)". The hostname can contain up to four "\*" characters; each "\*" character can be used to replace one octet from the current IP address. For example, if the IP address is currently 192.168.1.2, and the proxy is set to "proxy-\*-\*", then the player will attempt to use a proxy named "proxy-192-168".
    
*   `proxyBypassList` Array<String>: A list of hostnames exempted from the proxy setting. The player will attempt to reach the specified hosts directly rather than using the proxy specified in the `proxy` attribute. For example, the hostname "[example.com](http://example.com)" would exempt "[example.com](http://example.com)", "[example.com](http://example.com):80", and "[www.example.com](http://www.example.com)" from the proxy setting.
    
*   `timeServerList` Array<String>: An array containing zero or one time servers to be used by the player. An empty array disables automatic setting of the player's clock. A single entry indicates the time server and protocol that should be used as a URL. Supported protocols are HTTP, HTTPS and NTP. For backward-compatibility the use of just a host name is supported and indicates that NTP should be used. Note that when using HTTPS, host and peer verification are disabled since the player clock may not be correct. The following are valid time server addresses:
    
    *   [http://time.brightsignnetwork.com/](http://time.brightsignnetwork.com/)
        
    *   [https://time.brightsignnetwork.com/](https://time.brightsignnetwork.com/)
        
    *   [ntp://time.brightsignnetwork.com/](#)
        
    *   [time.brightsignnetwork.com](http://time.brightsignnetwork.com/)
        
*   `timeServerInterval` String: A value specifying how often (in seconds) the player should communicate with the time server to adjust its clock. The default interval is 12 hours. The minimum interval allowed is 120 seconds.
    
*   `hostName` String: The player host name. If no host name has been explicitly set, then a host name is automatically generated based on the device serial number. Passing an empty string to this method resets the device host name to its automatically generated value.
    
*   `loginPassword` bool: A value of true means that the password exists, false means that there is no password.
    
*   `forwardingEnabled`  bool: A flag that enables or disables IP forwarding. IP forwarding is disabled (false) by default.
    
*   `masqueradingEnabled` bool: A flag that enables or disables source address translation with IP forwarding. If `forwardingEnabled` is true, `masqueradingEnabled` must be specified as true or false:
    
    *   If `masqueradingEnabled` is false, IP datagrams are forwarded between all interfaces and no address translation is done. 
        
    *   If `masqueradingEnabled` is true, IP datagrams are forwarded between all interfaces, but [SNAT](https://ipwithease.com/snat-vs-dnat/) is applied to any datagrams which are sent out of an "upstream" interface (any interface or interfaces on which a default route is set). Datagrams destined for an interface that has no default route are forwarded without [NAT](https://ipwithease.com/snat-vs-dnat/). 
        
*   `natList` Array<NatRule>:  A list of [DNAT](https://ipwithease.com/snat-vs-dnat/) rules which lets users change the destination address and port of a packet.
    

## HostConfigWritable

This interface contains password settings for SSH. When writing settings using the `applyConfig()` method, some members of the `HostConfig` interface have special behavior.

*   `loginPassword` String or bool :
    
    *   If a string is supplied, sets a plain-text login password for the SSH connection (note that SSH must also be enabled separately in the registry for this to be useful).
        
    *   If boolean `True` is supplied, the existing password (if any) is left unchanged.
        
    *   if boolean `False` is supplied, any existing password is removed.
        
*   `obfuscatedLoginPassword` String or bool :
    
    *   As above, except that the password should previously have been obfuscated using a shared secret. Contact [support@brightsign.biz](mailto:support@brightsign.biz)![](https://jira.brightsign.biz/images/icons/mail_small.gif)
        
         to learn more about generating a key for obfuscation and storing it on the player.
        

This behavior ensures that code such as `getConfig().then((c) => { applyConfig(c); })` preserves any existing password, even though the password itself is not returned by `getConfig()`.

## NatRuleMatch

The rules in this interface are compared to destinations in the TCP or UDP packets that enter the player. If the packet fields match the properties established in `NatRuleMatch`, the destination IP and port will be overwritten with the desired values in the `NatRulesReplacement` interface.

*   `protocol` String: Filter for "udp" or "tcp" (the entry must be lower case).
    
*   `sourceAddressRange` String optional:  Filter for this range of source IP addresses (in [CIDR](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#:~:text=CIDR%20introduced%20a%20new%20method,db8%3A%3A%2F32%20for%20IPv6.) format). Traffic from all source IP addresses will be included if this optional attribute is not specified. 
    
*   `destinationAddressRange` String: The range of destination IP addresses (in [CIDR](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#:~:text=CIDR%20introduced%20a%20new%20method,db8%3A%3A%2F32%20for%20IPv6.) format) to be overwritten.
    
*   `destinationPort` unsigned short: The destination port to be overwritten.
    

## NatRuleReplacement

The address and port properties specified in `NatRuleReplacement` are written to the packet to replace selected IP address and port properties. 

*   `destinationAddress` String : The IP address that will replace the previous IP address in the destination.
    
*   `destinationPort` unsigned short:  The port that will replace the previous port in the destination.
    

## Examples

The following script uses the `applyConfig()` method to set the hostname, time server, and time-server refresh interval:

```
var HostConfigurationClass = require("@brightsign/hostconfiguration");
var hc = new HostConfigurationClass();

var configData = {};
configData.hostName = "myplayer";
configData.proxy = "";
configData.proxyBypassList = [];
configData.timeServerInterval = 1200;
configData.timeServerList = ["time.brightsignnetwork.com"];

console.log("***Configuring Host***")
hc.applyConfig(configData).then(
        function() {
            console.log("Success");
        })
    .catch(
        function(data) {
            console.log(JSON.stringify(data));
        }); 
```

To change one item while keeping the rest of the configuration the same, call `getConfig` and modify the returned object:

```
  var HostConfiguration = require('@brightsign/hostconfiguration');
  var hostConfiguration = new HostConfiguration;
  hostConfiguration.getConfig()
  .then(function(config) {
    config.hostName = "host-brightsign";
    hostConfiguration.applyConfig(config);
  })
  .then(function() {
    console.log("Success");
  })
  .catch(function(error) {
    console.log(`${JSON.stringify(error)}`);
  });
```
----
developers\developers\player-apis\javascript-apis\htmlwidget.md
# htmlwidget

The *htmlwidget object* allows you to instantiate additional HTML browsers. 

**htmlwidget IDL**

```
[
    Constructor(HtmlWidgetParams params)
] interface HtmlWidget {
    void postMessage(Object data);
    void close();
};
  
interface HtmlWidgetParams {
    attribute HtmlWidgetRect rect;
    attribute String url;
    [optional] attribute NodeParams node;
    [optional] attribute JavascriptInjection javascriptInjection;
    [optional] attribute bool bsObjects;
    [optional] attribute Storage storage;
    [optional] attribute String inspectorServer;
    [optional] attribute bool inputEnabled;
    [optional] attribute Security security;
    [optional] attribute String transform;
    [optional] attribute String hwzDefault;
    [optional] attribute bool interceptReloads;
};
  
interface HtmlWidgetRect {
    attribute long x;
    attribute long y;
    attribute long width;
    attribute long height;
};
  
interface NodeParams {
    attribute bool enabled;
    [optional] attribute Array<String> arguments;
};
  
interface JavascriptInjection {
    [optional] attribute JavascriptInjectionDetailList documentCreation;
    [optional] attribute JavascriptInjectionDetailList documentReady;
    [optional] attribute JavascriptInjectionDetailList deferred;
};
  
interface JavascriptInjectionDetail {
    [optional] attribute String world;
    [optional] attribute String source;
    [optional] attribute String uri;
    [optional] attribute String code;
};
  
interface Storage {
    attribute String path;
    attribute long quota;
    attribute bool forceSharedStorage;
    attribute bool forceUnsharedStorage;
};
  
interface Security {
    [optional] attribute bool insecureOriginEnabled;
    [optional] attribute bool cameraEnabled;
    [optional] attribute bool desktopCaptureEnabled;
    [optional] attribute bool audioCaptureEnabled;
    [optional] attribute bool insecureHttpsEnabled;
};
```

## Object Creation

To create a *htmlwidget* object first load the `brightsign/htmlwidget` module using the `require()` method. Then create an instance of the *htmlwidget* class. 

```
var HtmlWidgetClass = require("@brightsign/htmlwidget");
var htmlwidget = new HtmlWidgetClass({ rect:{x: 0, y:0, w: 640, h: 480 }, url: "https://brightsign.biz" });
```

## HtmlWidget

##### postMessage()

```
void postMessage(Object data)
```

Sends an asynchronous message to the child browser process. If the child process has an @brightsign/messageport object open, this message will generate a "bsmessage" event on that object. The payload can be any JavaScript object but must be only one level deep (that is, it cannot include other nested objects).

##### close()

```
void close()
```

Shuts down the child browser process. This is equivalent to calling *window.close()* from inside the child browser.  Node.js® parent processes won't exit automatically and the HTML widget can't be garbage collected until the widget is closed.

## HtmlWidgetParams

This interface contains the HTML widget parameters.

*   `rect` HtmlWidgetRect: Contains the set parameters of the size and positioning of the widget. 
    
*   `url` String: The URL to use for display. 
    
*   `node` NodeParams optional: Contains the parameters used to specify added Node.js functionality. 
    
*   `javascriptInjection` JavascriptInjection optional: Contains the parameters that specify JavaScript code to inject at different initialization points.
    
*   `bsObjects` bool optional: Enables or disables [BrightScript-Javascript Objects](https://docs.brightsign.biz/display/DOC/BrightScript-JavaScript+Objects). This value is disabled by default. 
    
*   `storage` Storage optional:  Used to configure HTML storage.
    
*   `inspectorServer` String optional: Enables the [Chromium Inspector](https://docs.brightsign.biz/display/DOC/HTML+Best+Practices#HTMLBestPractices-debugging_webpages), which allows you to debug JavaScript applications while a webpage is running. Starting in BOS 8.5.31 you will need to also set the enable\_web\_inspector registry key (in the "html" section) to enable the JavaScript console. 
    
    *   To access the console, navigate to the player IP address at the specified port number. See [this page](https://trac.webkit.org/wiki/WebInspector) for documentation relating to the JavaScript console.
        
    *   In “enable\_web\_inspector”, "1" will allow the inspector and "0" or not present will disable it.  A reboot will be needed for these changes to take effect (if you enable/disable this through the LDWS UI, it may trigger a reboot to apply the change)
        

> [!CAUTION]
> For security reasons, **enable\_web\_inspector** should only be used in non-production presentations. Make sure to disable JavaScript console before publishing to a production environment. In the Chromium version found in BOS 8.5.31 and beyond, the JavaScript console will log information in memory even when you are not connected to the inspector. This will consume memory until the player runs out, which will result in a crash.

*   `inputEnabled` bool optional: Enables mouse/touchscreen events. This value is false by default.
    
*   `security` Security optional:  Override Chromium security checks.
    
*   `transform` String optional: Sets the screen orientation of content in the widget (note that the coordinates and dimensions of the *roRectangle* containing the widget are not affected by rotation). The following values are accepted:
    
    *   `"identity"`: There is no transform (i.e. the widget content is oriented as landscape). This is the default setting.
        
    *   `"rot90"`: The widget content is rotated to portrait at 90 degrees (clockwise).
        
    *   `"rot180"`: The widget content is rotated to portrait at 180 degrees (clockwise).
        
    *   `"rot270"`: The widget content is rotated to portrait at 270 degrees (clockwise).
        
*   `hwzDefault` String optional: Specifies the default [HWZ](https://docs.brightsign.biz/space/DOC/370672326#HTMLVideo-hwz_video) behavior. This value is `off` by default. To enable it, set it to `on`.
    
*   `interceptReloads` bool optional: Prevents `window.location.reload()` or similar constructs from taking effect in the browser. Instead the parent will receive a `reloadRequested` event.
    

## HtmlWidgetRect

This interface allows you to set the size and positioning of the widget rectangle. 

*   `x` long: Specifies the x coordinate for the widget.
    
*   `y` long: Specifies the y coordinate for the widget. 
    
*   `width` long: Sets the width of the widget in pixels.
    
*   `height` long: Sets the height of the widget in pixels. 
    

## NodeParams

This interface allows you to enable Node.js and define the parameters of the Node.js command-line arguments. 

*   `enabled` bool: Enables [Node.js](../../../developers/html-development/nodejs.md) on the widget. The value is `false` by default. 
    
*   `arguments` Array<String> optional:  An array specifying command-line arguments. 
    

##   
JavascriptInjection 

Use this interface to inject user scripts into the JavaScript engine. 

*   `documentCreation` JavascriptInjectionDetailList optional: The script will run as soon as the document is created. This behavior is not suitable for any DOM operation. 
    
*   `documentReady` JavascriptInjectionDetailList optional: The script will run as soon as the DOM is ready. This behavior is equivalent to the `DOMContentLoaded` event firing in JavaScript. 
    
*   `deferred` JavascriptInjectionDetailList optional: The script will run when the page load finishes. 
    

## JavascriptInjectionDetail

This interface defines the user scripts that are used by the JavascriptInjection interface. Exactly one of the `source`, `uri`, or `code` fields must be defined.

*   `world` String optional: Isolates user scripts into different worlds. This string can be assigned one of the following values: `application`, `user`, or `main` (see [this page](https://doc.qt.io/archives/qt-5.6/qwebenginescript.html#ScriptWorldId-enum) for more details); if the `world` parameter is not included in the array, "`application`" is selected by default. 
    
*   `source` String optional: Deprecated. Use `uri` or `code` instead.  
    
*   `uri` String optional: If defined, this must contain either a "file" URI, or a "data" URI with one of the following supported formats:
    
    *   "data:text/javascript;charset=utf-8;"
        
    *   "data:text/javascript;charset=utf-8;base64,"
        
    *   "data:text/javascript;charset=us-ascii;"
        
    *   "data:text/javascript;charset=us-ascii;base64,"
        
*   `code` String optional: If defined, the content will be executed as JavaScript code.
    

## Storage

This interface allows you to define the following HTML storage parameters:

*   `path` String: The folder used by local storage applications such as the JavaScript storage class. 
    
*   `quota` long:  The size (in bytes) allotted to all local storage applications (including IndexedDB). If the storage path is specified without a storage quota, Chromium defaults to reserving 1GB plus 10% of the total size of the storage device.
    
*   `forceSharedStorage` bool:  Allows HTTP/HTTPS loaded URLs to share local storage if they are loaded from the same domain. 
    
*   `forceUnsharedStorage` bool:  Prevents file loaded URLs from sharing storage.
    

> [!NOTE]
> Data can be corrupted if two HTML widgets access the database at the same time, but some applications rely on this type of access. Use the `force_unshared_storage` flag to avoid sharing on local URLs if you experience data problems, or use the `force_shared_storage` flag to allow sharing on HTTP/HTTPS sites.
> (If both flags are set, file storage is separated and HTTP storage is not.)

## Security 

Overrides Chromium security checks for these parameters:

*   `insecureOriginEnabled`  bool optional: Ignore insecure origins and treat them as enabled.
    
*   `cameraEnabled` bool optional: Enables webpage access to USB cameras connected to the player (access is disabled by default). This allows support for WebRTC applications. 
    
*   `desktopCaptureEnabled` bool optional: Enables desktop capture.
    
*   `audioCaptureEnabled` bool optional: Enables audio capture.
    
*   `insecureHttpsEnabled` bool optional: Ignore security errors when connecting to insecure HTTPS hosts (insecure HTTPS is disabled by default). Enabling this feature makes the player insecure; it is not suitable for production environments and should only be used for testing.
    

With BOS 8.2 and later (Chromium69 and later), several new CORS checks have been added. `security_params.websecurity` or `enableSecurity(false)` do not disable all these checks. Use the following registry setting instead:

`registry write html disable-web-security 1`

This flag will take effect on all `htmlwidget` instances, as opposed to previous flags which are only effective on the instance they are called on.

To write this to the registry using [roRegistrySection](../../../developers/brightscript/object-reference/hashing-and-storage-objects/roregistrysection.md):

```
RegHtml = CreateObject("roRegistrySection", "html")
RegHtml.Write("disable-web-security", "1")
RegHtml.Flush()
```
----
developers\developers\player-apis\javascript-apis\javascript-event-handling.md
# JavaScript Event Handling

## AddEventListener

`addEventListener()` is a common BrightSign method that is used to listen for an event.

#### Syntax:

```
target.addEventListener(type, listener);
```

*   `type` string: Specifies the type of event to listen for
    
*   `listener` function: The object to be notified when the event (of the specified `type`) happens 
    

## RemoveEventListener

`removeEventListener()`is a common BrightSign method that is used to remove an event listener.

#### Syntax:

```
target.removeEventListener(type, listener);
```

*   `type` string: Specifies the type of event to listen for
    
*   `listener` function:  The object to be notified when the event (of the specified `type`) happens 
    

## Example

```
function GPIOcontrolDown(msg){

    console.log(JSON.stringify(msg)); 
    console.log(" GPIO : " + msg.detail)
}

// to add an event listener for the "controldown" GPIO event

control_port.addEventListener("controldown", GPIOcontrolDown);

// to remove the "controldown" GPIO event listener

control_port.removeEventListener("controldown", GPIOcontrolDown);
```
----
developers\developers\player-apis\javascript-apis\keyboard.md
# keyboard

The *keyboard* object allows you to configure the input for a USB keyboard connected to the player.

**keyboard IDL**

```
interface Keyboard {
    Promise<bool> isAttached();
    Promise<void> setLayout(String layoutName);
    Promise<void> setNumLock(bool on_off);
};
```

## Object Creation

To create a *keyboard* object, first load the `brightsign/keyboard` module using the `require()` method. Then create an instance of the *keyboard* class.

```
var keyboardClass = require("@brightsign/keyboard");
var keyboard = new keyboardClass();
```

## Keyboard

This interface allows for detection and configuration of a USB keyboard.

##### isAttached()

```
Promise<bool> isAttached()
```

Returns `true` if a USB keyboard is connected to the player. This method counts a connected device as a keyboard if it reports having the following keys: "A", "Z", "0", "9", ".", and Enter.

##### setLayout()

```
Promise<void> setLayout(String layoutName)
```

Specifies the localized layout for the attached USB keyboard. This setting takes effect immediately and persists in the registry after a reboot. See [this table](../../../developers/brightscript/object-reference/inputoutput-objects/rokeyboard.md) for valid keymap parameters (players are set to "us" by default).

##### setNumLock()

```
Promise<void> setNumLock(bool on_off)
```

Sets the numlock state for the attached USB keyboard if passed true. Reset the state if passed false.

## Example

```
var KeyboardClass = require("@brightsign/keyboard");
var keyboard = new KeyboardClass();
keyboard.isAttached().then(
        function(data) {
            console.log("***Is Attached***");
            console.log(JSON.stringify(data));
        })
    .catch(
        function(data) {
            console.log(JSON.stringify(data));
        });
keyboard.setLayout("gb").then(
        function(data) {
            console.log("***Layout set***");
        })
    .catch(
        function(data) {
            console.log(JSON.stringify(data));
        }); 
```
----
developers\developers\player-apis\javascript-apis\keystore.md
# keystore

The *keystore* object allows you to register client certificates with the player.

While CA packages (added using the `AddCAPackage()` method) are persistent, individual certificates (added using the `AddCACertificate()` and `AddClientCertificate()` methods) are not; individual certificates must be registered with the certificate database after each reboot.

**keystore IDL**

```
interface KeyStore {
    Promise<void> addCaCertificate(String filename);
    Promise<void> addCaPackage(String filename);
    Promise<void> removeCaPackage(String filename);
    Promise<PackageList> getCaPackagesInstalled();
    Promise<void> addClientCertificate(ClientCertificateObject object);
};

interface ClientCertificateObject {
    attribute String certificateFile;
    attribute String passphrase;
    attribute String obfuscatedPassphrase;
};

```

## Object Creation

To create a *keystore* object, first load the `brightsign/keystore` module using the `require()` method. Then create an instance of the *keystore* class.

```
var keystoreClass = require("@brightsign/keystore");
var keystore = new keystoreClass();
```

## KeyStore

Use this interface to add certificates to the certificate database.

##### addCaCertificate()

```
Promise<> addCaCertificate(DOMString filename)
```

Registers the specified CA certificate with the certificate database. Client certificates can be either self-signed or signed using a 3rd-party certificate issuer (Versign, DigiCert, etc.). 

> [!WARNING]
> Chromium version 69 or later will refuse SHA-1 certificates. See [this page](https://www.chromium.org/Home/chromium-security/education/tls/sha-1/) for more information.

##### addCaPackage()

```
Promise<> addCaPackage(DOMString filename)
```

Adds the specified CA package file to the certificate database. The package name resides in the file and does not need to be the same as the filename. See the [*roKeyStore*](../../../developers/brightscript/object-reference/networking-objects/rokeystore.md) page for more information on generating CA packages.

> [!NOTE]
> Attempting to modify a CA package file that has been added to the database will invalidate it. If a package is invalidated, it will need to be removed from the database (using the r`emoveCaPackage()` method) and added again.

##### removeCaPackage()

```
Promise<> removeCaPackage(DOMString filename)
```

Removes the specified CA package from the certificate database. Use the g`etCaPackagesInstalled()` method to retrieve a list of package names in the database.

##### getCaPackagesInstalled()

```
Promise<PackageList> getCaPackagesInstalled()
```

Returns a list of names of CA packages contained in the certificate database.

##### addClientCertificate()

```
Promise<> addClientCertificate(ClientCertificateObject object)
```

Registers a .p12 client certificate with the certificate database. 

## ClientCertificateObject

This interface represents a .p12 certificate file.

*   `certificateFile` String: The file name and path of the .p12 client certificate
    
*   `passphrase` String:  A passphrase for the .p12 client certificate
    
*   `obfuscatedPassphrase` String: An obfuscated passphrase for the .p12 client certificate
    

> [!CAUTION]
> **Important**
> Only one of `obfuscatedPassphrase` and `passphrase` is required, and `obfuscatedPassphrase` takes priority if both are present. We recommend using `obfuscated_passphrase` in production environments, while `passphrase` should be used for testing purposes only. Contact [support@brightsign.biz](mailto:support@brightsign.biz) to learn more about generating a key for obfuscation and storing it on the player.

## Example

```
ksf = require('@brightsign/keystore');
k = new ksf()
k.addCaPackage("/storage/sd/example.bsca").then(() => console.log('ok'), () => console.log('failed'))
k.getCaPackagesInstalled().then((pkgs) => console.log(pkgs))
k.removeCaPackage('example').then(() => console.log('ok'), () => console.log('failed'))
```
----
developers\developers\player-apis\javascript-apis.md
# JavaScript APIs

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Table of Contents

*   [JavaScript APIs Replace Previous “BrightScript-JavaScript Objects”](#javascript-apis-replace-previous-brightscript-javascript-objects)
*   [Enabling the JavaScript API](#enabling-the-javascript-api)
*   [Loading BrightSign Modules](#loading-brightsign-modules)
*   [Synchronous and Asynchronous Methods](#synchronous-and-asynchronous-methods)

The BrightSign API for JavaScript allows you to interface with the BrightSign player firmware to configure the player, retrieve system data, and interface with peripheral devices. This API allows for operation of a digital signage platform–including playback, scheduling, diagnostics, and network configuration–using HTML/JavaScript, without the need for extensive coding in BrightScript.

## JavaScript APIs Replace Previous “BrightScript-JavaScript Objects”

This API replaces the [BrightScript-JavaScript objects](../player-apis/brightscript-javascript-objects.md). Those older JavaScript objects are still offered for backwards-compatibility purposes. See the [BrightScript-JavaScript Migration Guide](../player-apis/brightscript-javascript-migration-guide.md) for the mapping between BrightScript and JavaScript APIs.

JavaScript objects are embedded into the browser runtime. They only exist in the global JavaScript namespace, and can only be used with *roHtmlWidget*.

Thus JavaScript API uses node modules. It works seamlessly with [*roHtmlWidget*](../../developers/brightscript/object-reference/presentation-and-widget-objects/rohtmlwidget.md), [*roNodeJs*](../../developers/brightscript/object-reference/presentation-and-widget-objects/ronodejs.md)*,* and on *roElectron*. It is a superset of legacy JavaScript objects.

BrightSign has not added new features to the legacy BrightScript-JavaScript objects for several years, and all of our current development efforts go into JavaScript APIs. The legacy BrightScript-Javascript objects exist to support customers who use them in deployed software, and to maintain that support during OS upgrades. 

Unlike the legacy BrightScript-JavaScript objects, there is no one-to-one relationship between BrightScript objects and objects in the new JavaScript API. Many BrightScript functions (e.g. HTTP server and file storage capabilities) are not exposed in the new API because JavaScript and Node.js® expose standardized, popular equivalents.

## Enabling the JavaScript API

The BrightSign API for JavaScript is implemented with the Node.js module, which is included with the Chromium engine on the player. To use the BrightSign API with an *roHtmlWidget* instance, you must enable Node.js when creating the widget:

##### **Example**

```
r=createobject("rorectangle",0,0,1920,1080)
aa=createobject("roassociativearray")

aa.url="http://test-server/index.html"
aa.nodejs_enabled=true

bb=createobject("roassociativearray")
bb.port=3000
aa.inspector_server=bb

h=createobject("rohtmlwidget",r,aa)
h.show()
```

In the above example, Node.js is enabled by including the `nodejs_enabled:true` entry in the associative array that is passed during creation of the *roHtmlWidget* instance.

## Loading BrightSign Modules

The BrightSign API does not exist in the global (window) namespace of the JavaScript runtime. Instead, like Node.js objects, BrightSign modules are loaded using the `require()` function (i.e. `require("@brightsign/<module_name>")`). BrightSign modules are actually part of the firmware, but in terms of usage, they are identical to other Node.js modules.

##### **Example**

```
var NetworkConfigClass = require("@brightsign/networkconfiguration");   // Call the class constructor for the networkconfiguration object.
var wifi = new NetworkConfigClass("ethernet"); 							// Create an instance of the networkconfiguration class.
```

## Synchronous and Asynchronous Methods

BrightSign modules contain both synchronous and asynchronous methods. Synchronous methods return an object that can be used immediately, while asynchronous methods return a Promise object, which will itself return the object data when the operation is resolved. Scripts must handle these delayed returns (typically using the `.then()` and `.catch()` methods available on the Promise object).

##### **Example**

```
var NetworkConfigClass = require("@brightsign/networkconfiguration");
var wifi = new NetworkConfigClass("wlan0"); 
wifi.scan().then(											 // Call the Scan() method, which returns a promise.
		function(data){console.log(JSON.stringify(data));}) // The resolve/success case, which prints the scan results 
	.catch(
		function(data){console.log(JSON.stringify(data));}) // The reject/failure case, which prints the failure reason
```
----
developers\developers\player-apis.md
# Player APIs


----
developers\developers.md
# Developers

BrightSign developer resources include the documentation in this section as well as:

## GitHub

The [BrightSign GitHub Repository](https://github.com/brightsign) contains additional resources for developers including plugins and custom scripts.

## BrightScript

The [BrightScript Language](https://marketplace.visualstudio.com/items?itemName=RokuCommunity.brightscript) extension in Visual Studio Code facilitates BrightScript coding and is used by thousands of developers around the world.

## MRSS Feed Generator

This [MRSS Feed Generator](https://brightsign.box.com/s/u4eefjhgdllocv7uhbsrf6hpu5qxrbbt) batch file for Windows will generate MRSS manifest (.xml) files for a set of audio/video/image files. Note that:

*   The MRSS feed file will be written to the folder you run it from. 
    
*   You must edit the batch file in a text editor to set configuration parameters.
    
*   After the configuration parameters are set, the file can be run in interactive or automated mode. If you run it interactively it will provide diagnostic/usage information.
    

## Media List Feed Generator

This [Media List Feed Generator](https://brightsign.box.com/s/e8ybprvnjim8h26dtpwdvf1kmu1rbcxg) batch file for Windows will generate a Media List feed, which is a specially formatted RSS feed that can be used as a feed source for these states:

*   Audio List
    
*   Image List
    
*   Video List
    
*   Media List
    
*   Audio Play File (BrightAuthor only)
    
*   Image Play File (BrightAuthor only)
    
*   Video Play File (BrightAuthor only)
    
*   On Demand (BrightAuthor:connected only)
    

Note that:

*   It will contain the audio/video/image files in the folder it is run from.
    
*   You must edit the batch file in a text editor to set configuration parameters.
    
*   After the configuration parameters are set, the file can be run in interactive or automated mode. If you run it interactively it will provide diagnostic/usage information.
----
partners\partners\brightsign-partner-packet\autorun-files.md
# Autorun Files

As was covered, player provisioning consists of applying a Setup to the player which includes the installation of a Player App. The Player App must contain an *autorun.brs* file which, as an example, may instruct the player to display a specific .html file, either local on the player or on an external website. Alternatively, the autorun may instruct the player to check a particular URL for updated presentations and/or content and, if new files are available, download them and play them.

There are three autorun-related files:

*   autorun.brs (may also be referred to as “the autorun” or “autorun file”)
    
*   autorun.zip
    
*   autozip.brs
    

These have similar-sounding names, but each term has a different function so it’s important to not conflate the terms.

Upon bootup, the player searches for certain files. The player’s search follows a prescribed sequence as shown below.

![](./attachments/image-20230413-155338.png)

Players will search for storage devices in a [predefined order](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/1967783990/Player+Storage#Storage-Device-Priority).

1.  The player first looks for an *autorun.brs* file in the root directory of the first storage device it encounters.
    
    1.  If found, *autorun.brs* is executed.
        
2.  If an *autorun.brs* file is not found, the player looks for an *autorun.zip* file in the same root directory.
    
    1.  If an *autorun.zip* file is found and it also contains within it an *autozip.brs* file, the player will unzip the *autorun.zip* file, in the process overwriting any existing files on the storage device.
        
    2.  The player will then reboot.
        
3.  If these files are not found on the first storage device, the player will repeat these steps on the next storage device, if available.
    

If an *autorun.zip* is not found on any of the storage devices, the player will query the BSN.cloud provisioning service to see if the player has previously been provisioned with BSN.cloud.

Both *autorun.brs* and *autozip.brs* must be written in BrightScript and be given the specific filenames indicated.

Additional information about these files can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370673002/roBrightPackage#Using-roBrightPackage-for-Content-Updates).

Below are sample *autorun.brs* and *autozip.brs* files for reference.

## Sample autorun.brs

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

This autorun.brs file instructs the player to display a local HTML file, specifically, index.html:

```
Sub Main()
    'Create the BrightSign event handler.
    msgPort = CreateObject("roMessagePort")
    
    'Define the screen viewing area.
    r = CreateObject("roRectangle", 0, 0, 1920, 1080)
  
    'Set the URL where the presentation resides. This can be either local or external.
    config = {
      url: "file:///index.html",
    }

    'Create an HTML event since our presentation is an HTML file.
    h = CreateObject("roHtmlWidget", r, config)
    h.SetPort(msgPort)
    sleep(10000)
    h.Show()

    'Event loop to ensure that the script runs indefinitely
    while true
        msg = wait(0, msgPort)
        print "type(msg)=";type(msg)
        if type(msg) = "roHtmlWidgetEvent" then
            eventData = msg.GetData()
            if type(eventData) = "roAssociativeArray" and type(eventData.reason) = "roString" then
                print "reason = ";eventData.reason
                if eventData.reason = "load-error" then
                    print "message = ";eventData.message
                endif
            endif
        endif
    end while

End Sub
```

## Sample autozip.brs

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

This autozip.brs file instructs the player to unzip the autorun.zip file:

```
'name file autorun.zip
' Content update application

Sub Main()
    path$= FindDestPath()
    source$= FindSourcePath()
    package = CreateObject("roBrightPackage", source$+"autorun.zip")
    package.SetPassword("test")
    package.Unpack(path$)
    package = 0
    CreateDirectory(path$+"brightsign-dumps")
    CreateDirectory(path$+"pool")
    CreateDirectory(path$+"feed_cache")
    CreateDirectory(path$+"feedPool")

    DeleteFile(path$+"autozip.brs")
    DeleteFile(source$+"autorun.zip")
    a=RebootSystem()
End Sub

Function FindDestPath()
    if not IsFirmwareValid() then
        return "SD:/"
    end if

    destinationPaths = ["SSD:", "SD:", "USB1:"]
    for each destination in destinationPaths
        if IsMounted(destination) then
            return destination+"/"
        end if
    next
    return "unknown"
End Function

Function FindSourcePath()
    if not IsFirmwareValid() then
        return "SD:/"
    end if

    sourcePaths = ["USB1:", "SD:", "SSD:"]
    for each source in sourcePaths
        if IsMounted(source) and CheckFile(source+"/autorun.zip") then
            return source+"/"
        end if
    next
    return "unknown"
End Function

Function IsMounted(path as String)
    if CreateObject("roStorageHotplug").GetStorageStatus(path).mounted then
        return true
    end if

    return false
End Function

Function IsFirmwareValid()
    di = CreateObject("roDeviceInfo")
    return di.FirmwareIsAtLeast("7.0.60")
End Function

Function CheckFile(path as String)
    file = CreateObject("roReadFile", path)
    if type(file) = "roReadFile" then
        return true
    end if

    return false
End Function
```

[Next - Content Sources >](../brightsign-partner-packet/content-sources.md)
----
partners\partners\brightsign-partner-packet\brightsign-partner-responsibilities.md
# BrightSign / Partner Responsibilities

The high-level responsibilities expected of BrightSign and its partners are as follows:

## BrightSign Expectations

*   The BrightSignOS is under continuous development and although we try to provide advance notice and roadmap guidance, the OS may be updated with minimal notice. It is the responsibility of the individual partners to manage player upgrades to ensure OS stability in their environment.
    
*   BrightSign will share code examples to provide guidance to partners, but BrightSign does not write partner-oriented production code.
    
*   BrightSign does not provide quality assurance for partner products.
    

## Partner Expectations

*   Partners are responsible for writing the software that integrates their systems with BrightSign players.
    
*   Partners are responsible for qualifying BrightSignOS updates (see [Update the Player OS](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/1932492801/Update+the+Player+OS)).
    
*   Partners should have a public web page listing supported BrightSign players.
    
*   Refer to the earlier sections in this document on technical and operational best practices to optimize your BrightSign partner experience.
    

[Next - Support >](../brightsign-partner-packet/support.md)
----
partners\partners\brightsign-partner-packet\brightsign-players.md
# BrightSign Players

BrightSign players run on a highly efficient, embedded system specifically designed for connectivity and the processing of media files. Our players are purpose-built from the ground up for digital signage!

## Software

The BrightSign operating system (BrightSignOS or BOS) is an open-source Linux-based OS based on the Yocto and OpenEmbedded projects. It includes substantial BrightSign modifications that include a read-only root filesystem in flash memory, a Chromium rendering engine, and additional components for audio/video processing and security.

![](./attachments/image-20230626-152212.png)

Thanks to the built-in Chromium engine, BrightSign players are able to run any HTML/JavaScript application.

BrightSign players are highly specialized and although they are based on a Linux OS, they are *not* general-purpose Linux PCs. They cannot run Linux apps nor are they capable of running apps for Android, iOS, or Windows. However, if you have a native Android, iOS, or Windows app, we may be able to help you leverage your existing code to run natively on our players.

![](./attachments/image-20230224-203455.png)

Some of BrightSign’s software components are open source, and the open source code is freely available on BrightSign’s website. See [BrightSign Open Source Resources](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/2378039297/BrightSign+Open+Source+Resources) for more information.

> [!INFO]
> Note that the term “firmware” is occasionally used in BrightSign’s documentation. “Firmware” refers to BrightSignOS.

## Hardware

BrightSign players are compact, highly-efficient, and, because they’re fan-less, virtually silent. Performance is maximized by running all video decoding and encoding through dedicated hardware.

With an efficient heat-dissipating enclosure and no moving parts that can break down, BrightSign players are extremely reliable even when they're running 24 hours a day, 7 days a week. Indeed, the reliability and longevity of BrightSign players are widely viewed as unmatched in the industry.

You can learn more about the current BrightSign hardware lineup [here](https://www.brightsign.biz/digital-signage-products).

[Next - Player Setup / Provisioning >](../brightsign-partner-packet/player-setup-provisioning.md)
----
partners\partners\brightsign-partner-packet\content-sources.md
# Content Sources

Thanks to the built-in Chromium engine, BrightSign players can generally display any HTML web page that is capable of being displayed in the Chrome browser. Typically, HTML presentations will consist of an HTML file that resides locally on the player’s storage device. Content displayed by the HTML file can be broadly categorized as follows:

1.  **Local**
    
    1.  Content resides on the player’s storage device.
        
    2.  Since the content is local, it can begin playing immediately.
        
2.  **Web**
    
    1.  Content is retrieved from an external web URL.
        
    2.  Unless the content has been previously cached, it must first be downloaded before it can be displayed.
        
3.  **Streamed**
    
    1.  Content is streamed, either locally or from an external server.
        
    2.  Streamed content relies on dedicated streaming servers and various streaming protocols like HLS, UDP/RTP/RTSP, and HTTP.
        
    3.  Video and audio data are transported as a continuous flow that can be watched or listened to almost immediately without having to wait for the full download to complete.
        

These categories are not mutually exclusive, and as we will see, players can readily play content from a mixture of these content sources.

[Next - Example (Manual Setup) >](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/1450835982/Example+Manual+Setup)
----
partners\partners\brightsign-partner-packet\example-manual-setup\attachments\autorun\autorun.brs
Sub Main()

    msgPort = CreateObject("roMessagePort")
    r = CreateObject("roRectangle", 0, 0, 1920, 1080)
  
    config = {
      url: "file:///index.html",
    }

    h = CreateObject("roHtmlWidget", r, config)
    h.SetPort(msgPort)
    sleep(10000)
    h.Show()

    while true
        msg = wait(0, msgPort)
        print "type(msg)=";type(msg)
        if type(msg) = "roHtmlWidgetEvent" then
            eventData = msg.GetData()
            if type(eventData) = "roAssociativeArray" and type(eventData.reason) = "roString" then
                print "reason = ";eventData.reason
                if eventData.reason = "load-error" then
                    print "message = ";eventData.message
                endif
            endif
        endif
    end while

End Sub
----
partners\partners\brightsign-partner-packet\example-manual-setup\attachments\autorun\autozip.brs
'name file autorun.zip
' Content update application

Sub Main()
    path$= FindDestPath()
    source$= FindSourcePath()
    package = CreateObject("roBrightPackage", source$+"autorun.zip")
    package.SetPassword("test")
    package.Unpack(path$)
    package = 0
    CreateDirectory(path$+"feed_cache")
    CreateDirectory(path$+"feedPool")
    CreateDirectory(path$+"brightsign-dumps")

    DeleteFile(path$+"autozip.brs")
    DeleteFile(source$+"autorun.zip")
    a=RebootSystem()
End Sub

Function FindDestPath()
    if not IsFirmwareValid() then
        return "SD:/"
    end if

    destinationPaths = ["SSD:", "SD:", "USB1:"]
    for each destination in destinationPaths
        if IsMounted(destination) then
            return destination+"/"
        end if
    next
    return "unknown"
End Function

Function FindSourcePath()
    if not IsFirmwareValid() then
        return "SD:/"
    end if

    sourcePaths = ["USB1:", "SD:", "SSD:"]
    for each source in sourcePaths
        if IsMounted(source) and CheckFile(source+"/autorun.zip") then
            return source+"/"
        end if
    next
    return "unknown"
End Function

Function IsMounted(path as String)
    if CreateObject("roStorageHotplug").GetStorageStatus(path).mounted then
        return true
    end if

    return false
End Function

Function IsFirmwareValid()
    di = CreateObject("roDeviceInfo")
    return di.FirmwareIsAtLeast("7.0.60")
End Function

Function CheckFile(path as String)
    file = CreateObject("roReadFile", path)
    if type(file) = "roReadFile" then
        return true
    end if

    return false
End Function
----
partners\partners\brightsign-partner-packet\example-manual-setup\attachments\autorun\index.html
<!DOCTYPE html>
<html>
<head>
<style>
body {background-color: black;}
h3 {color: white; font-family: sans-serif;} 

* {
  box-sizing: border-box;
}

.row::after {
  content: "";
  clear: both;
  display: table;
}

.col {
  float: left;
  width: 50%;
  padding: 5px;
}

.video-container {
  position: relative;
  padding-bottom: 56.25%;
  padding-top: 0px;
  height: 0;
  overflow: hidden;
}

.video-container iframe,
.video-container object,
.video-container embed {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.slideshow-container {
    max-width: 100%;
    position: relative;
    margin-left:auto;
    margin-right:auto;
    margin-top:auto;
    margin-bottom:auto;
    overflow:hidden;
}

.mySlides {
    display:none
}

.mySlides img {
    width:100%;
    height:auto;
}

.youtube-container {
    position:relative;
    padding-bottom:56.25%;
    height:0;
    overflow:hidden;
}

.youtube-container iframe {
    position:absolute;
    top:0;left:0;width:100%;height:100%;
}

.weather-container {
    position:relative;
    padding-bottom:56.25%;

    height: auto;
    overflow: hidden;
}

</style>
</head>
<body>

<div class="row">
	<div class="col">
		<h3>Video File (local/on player)</h3>
		<div class="video-container">
			<video width="100%" autoplay loop muted>
				<source src="snowy_river.mp4" type="video/mp4">
			</video>
		</div>
	</div>

	<div class="col">
		<h3>Streaming Video (YouTube)</h3>
		<div class="youtube-container">
			<iframe width="560" height="315" src="https://www.youtube.com/embed/BHACKCNDMW8?start=0&autoplay=1&mute=1&loop=1&vq=hd1080p&playlist=BHACKCNDMW8&controls=0" frameborder="0" allowfullscreen></iframe>
		</div>
	</div>
</div>

<div class="row">
	<div class="col">
		<h3>Photos (remote web server)</h3>
		<div class="slideshow-container">

		<div class="mySlides fade">
			<img src="https://brightsign.biz/examples/img1.jpg" style="width:100%">
		</div>

		<div class="mySlides fade">
			<img src="https://brightsign.biz/examples/img2.jpg" style="width:100%">
		</div>

		<div class="mySlides fade">
			<img src="https://brightsign.biz/examples/img3.jpg" style="width:100%">
		</div>

		</div>
<br>

<script>
var slideIndex = 0;
showSlides();

function showSlides() {
  var i;
  var slides = document.getElementsByClassName("mySlides");
  for (i = 0; i < slides.length; i++) {
    slides[i].style.display = "none";
  }
  slideIndex++;
  if (slideIndex > slides.length) {slideIndex = 1}
  slides[slideIndex-1].style.display = "block";
  setTimeout(showSlides, 5000); // Change image every 5 seconds
}
</script>

	</div>


	<div class="col">
		<h3>Weather Widget (URL)</h3>
		<div class="weather-container">
			<div id="ww_9b69f46d0b38e" v='1.3' loc='auto' a='{"t":"responsive","lang":"en","sl_lpl":1,"ids":[],"font":"Arial","sl_ics":"one_a","sl_sot":"fahrenheit","cl_bkg":"rgba(0,0,0,1)","cl_font":"#FFFFFF","cl_cloud":"#FFFFFF","cl_persp":"#81D4FA","cl_sun":"#FFC107","cl_moon":"#FFC107","cl_thund":"#FF5722","cl_odd":"#FFFFFF17"}'><a href="https://weatherwidget.org/android-app/" id="ww_9b69f46d0b38e_u" target="_blank">Free weather app for android</a></div><script async src="https://app1.weatherwidget.org/js/?id=ww_9b69f46d0b38e"></script>
		</div>
	</div>
	
</div>

</body>
</html>
----
partners\partners\brightsign-partner-packet\example-manual-setup\considerations.md
# Considerations

While BrightSign players are highly versatile in the content sources they are able to utilize, there are some important factors that should be considered when making decisions about content sources.

Displaying web and streaming content hosted on an external website requires a persistent internet connection and performance is subject to the whims of network connectivity - if there are internet issues, the players will not be able to reliably display content.

Further, a common use case for digital signage is for players to loop the same content over and over. Having to repeatedly retrieve the same content from a server, particularly if there are multiple players where each player requires an individual stream, is a highly inefficient, and potentially expensive, use of bandwidth and server resources.

Content that resides locally on the player is much preferred. Quality of service can be much more tightly controlled as it is not dependent on a persistent network connection. BrightSign offers tools that enable remote content delivery directly to players as well as solutions for caching external web content (refer to the [Resources](https://brightsign-sandbox-694.atlassian.net/wiki/spaces/DOC/pages/6688342) section of this guide) on the player.

BrightSign players also have the capability of directly running Node.js applications, and if streaming content is desired, players have the ability to run a streaming server.

For most use cases, the preferred content source(s) will be Local Content, cached Web Content, or a mixture of both.

[Next - Integrating with BrightSign >](../../brightsign-partner-packet/integrating-with-brightsign.md)
----
partners\partners\brightsign-partner-packet\example-manual-setup\copy-to-player.md
# Copy to Player

In this example, we will maintain the player’s default Setup (the BrightSign Default Setup) and manually copy an *autorun.zip* file to the player’s storage device. The *autorun.zip* file will install the Player App.

## autorun.zip

At a minimum, the *autorun.zip* file should include the following files:

*   *autorun.brs*
    
*   *autozip.brs*
    

While not required, *autorun.zip* files can also include the presentation/content (e.g., an HTML file and associated media files that the player will display) that the *autorun.brs* file invokes. In this way, everything the player needs is contained in a single package for delivery. We will utilize this approach in this example, and we will use an HTML file as our sample presentation.

![](./attachments/image-20230327-234103.png)

The *autorun.zip* file will include the following files:

*   *autorun.brs* (this is the script [shown](https://brightsign.atlassian.net/wiki/spaces/PID/pages/1490124837/Autorun#Sample-autorun.brs) in the previous section; recall that this file instructs the player to render *index.html*)
    
*   *autozip.brs* (this is the script [shown](https://brightsign.atlassian.net/wiki/spaces/PID/pages/1490124837/Autorun#Sample-autozip.brs) in the previous section which instructs the player to unzip the *autorun.zip* file)
    
*   *index.html* (this is our HTML presentation)
    
*   *snowy\_river.mp4* (this is a sample video that is displayed by the index.html presentation)
    

You can create your own versions of the files above and compress them into an *autorun.zip* file, or you can use the *autorun.zip* file attached here:

[autorun.zip](./attachments/autorun.zip)

## Local + Remote Content

Although we are including a video file in the *autorun.zip* file, our presentation will also display the following:

*   A streaming video from YouTube.
    
*   A picture slideshow where the pictures are retrieved from an external web server.
    
*   The local weather displayed by a weather widget that retrieves data from an external URL.
    

BrightSign players are capable of displaying any combination of local and remote content.

## Copy to Card

Next, we will manually copy the *autorun.zip* to an empty microSD card and insert the card into a player.

![](./attachments/image-20230623-164334.png)

1.  Copy the *autorun.zip* file to the *root* directory of a blank, properly formatted microSD card.
    
2.  Insert the microSD card into the player.
    
3.  Power up the player.
    

Shortly after the player boots up, you should see something like this on your display:

![](./attachments/image-20230328-161412.png)

## Folders

![](./attachments/image-20230526-015203.png)

When the *autorun.zip* file is unpacked, the *autozip.brs* file instructs the player to create several folders in the root directory of the microSD card. These folders and their functions are as follows:

### brightsign-dumps

If a player crashes, dumps are created and stored in this folder. Dumps are numbered incrementally and can be useful for troubleshooting. They may be requested by BrightSign Support when diagnosing problems. Note that only the 10 most recent crash dumps are retained.

### pool

Media files, especially video files, can be quite large. To help players better manage such large files, players apply a cryptographic [hash function](https://en.wikipedia.org/wiki/Cryptographic_hash_function) to each media file. Hash functions are well beyond the scope of this document, but at a high-level, when a hash algorithm is applied to any file, a unique hash, or alphanumerical representation, of that file can be generated. If that file is changed in any way, the new file will result in a completely different hash.

Hashes are typically many times smaller in size compared with the original file. Whereas a large video file can easily run into the gigabytes, a hash of that video will only be at most a few dozen bytes (the exact size of the hash depends on the algorithm used).

Hashes are therefore much more manageable representations of the actual media files, and the pool (more formally, the Asset Pool) is where these hashes are stored. System efficiency is greatly improved through the use of hashes. The system can, for example, quickly determine if a file has changed simply based on whether the hash has changed instead of having to compare two large files. More detail about the Asset Pool can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/411436363/BrightSign+Asset+Pool).

### feedPool

The feedPool contains transient / non-static assets like RSS feeds and [dynamic playlists](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/384958989/Content#Dynamic-Playlists-%5BinlineExtension%5D), both of which can be used with BrightSign presentations.

### feed\_cache

The feed\_cache stores the metadata for the transient assets in the feedPool. For example, the feed\_cache would store the URL for an RSS feed, identifiers for particular items in the feed, and which items have been read and which ones are new.

[Next - Considerations >](../example-manual-setup/considerations.md)
----
partners\partners\brightsign-partner-packet\example-manual-setup\preparations.md
# Preparations

First, you will need to gather the necessary materials in order to follow along with this example.

## What You Will Need

*   BrightSign player and associated power supply
    
*   microSD (µSD) or other storage device (a microSD card will be assumed for this guide)
    
    *   microSD card adapter (computers with standard SD card readers typically require an adapter to access microSD cards)
        
*   Mac or PC
    
*   Display
    
*   HDMI cable (connects the player to the display)
    

## Storage Preparation

Make sure the card is properly formatted as described [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/1967783990/Player+Storage#microSD-Card-Formatting).

## Player Preparation

If your player is brand new, your player should be ready to proceed.

> [!WARNING]
> If you have previously set up your player, it may have some residual settings that need to be reset. In particular, if your player was previously configured for use with the bsn.Content (perhaps to evaluate the service using our free trial), the player will attempt to connect to and set itself up with bsn.Content. Refer [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/395313614/Device+Provisioning#Reprovisioning) for instructions on how to delete the player’s provisioning record and then return here to proceed.

[Next - Copy to Player >](../example-manual-setup/copy-to-player.md)
----
partners\partners\brightsign-partner-packet\example-manual-setup.md
# Example (Manual Setup)

In this section, you will be guided through a hands-on example that demonstrates how our players can be manually provisioned to simultaneously display local, web, and streaming content.

While many partners are likely to prefer remote provisioning over manual provisioning, this example is nevertheless useful because it introduces some important info while providing a fundamental demonstration of how our players function. As the example is straightforward to replicate, it enables users to easily follow along with their own player. Remote provisioning will be covered later in this packet.

As covered previously, provisioning a player involves applying a Setup and Player App to a player. Players that do not have a Setup explicitly applied will use the [BrightSign Default Setup](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/395313598/Setup#BrightSign-Default-Setup) which configures players to look for a network connection via Ethernet and, if a connection is found, obtain an IP address using DHCP. In this example, we will maintain the BrightSign Default Setup and copy a custom Player App to the player.

[Next - Preparations >](./example-manual-setup/preparations.md)
----
partners\partners\brightsign-partner-packet\integrating-with-brightsign\app-url.md
# App URL

In the hands-on example, a player was manually provisioned by physically copying a Player App to the player’s storage device. Since the BrightSign Default Setup was acceptable, provisioning of the player did not require a new Setup to be explicitly applied.

While manual provisioning is a very straightforward process, it poses challenges when multiple players are involved, players are in remote or hard-to-access locations, and/or the content needs to be updated frequently. Remote provisioning can therefore be highly beneficial in many scenarios.

The recommended method for partner provisioning of players, either manually or remotely, is through the use of Setups which can freely be created via bsn.Control at control.bsn.cloud.

## App URL

The [Publishing Mode](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/1968078934/Player+Setup+Provisioning#Publishing-Mode) is one of the important settings included in a Setup, and the App URL Publishing Mode is an effective way to remotely get content onto players. More details of this setup can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/2237005844/Publishing+Mode#App-URL), but a summary is as follows:

1.  The desired *autorun.brs* or *autorun.zip* file is uploaded to a player-accessible URL. The *autorun.zip* file includes the essentials (*autozip.brs* and *autorun.brs*) and, if desired, the presentation file and associated content files. The URL path to the *autorun.brs* or *autorun.zip* file is designated as the App URL (an example App URL is available at [https://www.brightsign.biz/examples/autorun.zip](https://www.brightsign.biz/examples/autorun.zip) which you may use).
    
2.  The player is configured with the App URL. There are several ways to do this:
    
    1.  An App URL can be applied directly to a player or group of players from the Provision screen, accessible from the Admin menu of the bsn.Control interface. You will be shown one way to do this in the next section.
        
    2.  Create an App URL Setup using the bsn.Control interface (more info about creating Setups can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/395313598/Setup)).
        
        1.  The Setup contains info about the App URL.
            
        2.  The Setup can be remotely applied to a player or group of internet-connected players.
            
        3.  Players download the *autorun.brs* or *autorun.zip* file from the App URL specified in the Setup.
            
3.  Player(s) configured for an App URL will, upon booting, download the [*autorun.br*](http://autorun.br)s or *autorun.zip* file from the specified App URL. If the file is an *autorun.zip* file containing an *autozip.brs* file, the player will unzip that file. The player will then reboot, and then run the *autorun.brs* file.
    

![image-20240801-165702.png](./attachments/image-20240801-165702.png)

Next, we will walk through another hands-on example in which we provision a player directly to use an App URL.

[Next - Example (App URL) >](../integrating-with-brightsign/example-app-url.md)
----
partners\partners\brightsign-partner-packet\integrating-with-brightsign\bsncontrol-integration.md
# bsn.Control Integration

Partners are highly encouraged to take advantage of the free, yet powerful, tools offered by bsn.Control. The two most common ways for partners to utilize bsn.Control are:

*   The “Swivel” approach
    
*   API integration between the partner CMS and the bsn.Control
    

## “Swivel” Approach

One of the easiest ways for a partner to get up and running is with the “Swivel Chair” approach. With this method, end users utilize bsn.Control *alongside* the partner CMS.

![image-20240801-164748.png](./attachments/image-20240801-164748.png)

With this approach, end users have full access to the capabilities of the bsn.Control via the unbranded web interface at control.bsn.cloud. By having one browser tab for the CMS and another browser tab for bsn.Control, users can quickly “swivel” back and forth between the CMS and bsn.Control.

![image-20230215-213716-20240404-194936.png](./attachments/image-20230215-213716-20240404-194936.png)

## API Integration

Using BrightSign’s APIs, partners are able to design their own custom user interfaces to access the underlying functions of the bsn.Control. End users will then interact with a single UI for authoring, publishing, content management, and player management.

![image-20240801-165212.png](./attachments/image-20240801-165212.png)

Next, let’s take a look at one of the ways the bsn.Control can used to remotely provision players.

[Next - App URL >](../integrating-with-brightsign/app-url.md)
----
partners\partners\brightsign-partner-packet\integrating-with-brightsign\developer-setup.md
# Developer Setup

As a new developer in the BrightSign ecosystem, there are several items that will help get you up and running as efficiently as possible. Mandatory items include everything listed in the earlier hands-on examples, listed again here for convenience:

*   BrightSign player and associated power supply
    
*   microSD or other storage device
    
    *   If using a microSD card as the storage device, you will also likely need microSD card adapter (computers with standard SD card readers typically require an adapter to access microSD cards)
        
*   Mac or PC
    
*   Display
    
*   HDMI cable (connects the player to the display)
    

In addition, it is very useful to connect the player to the local network via an Ethernet cable or, if the player has the appropriate hardware, WiFi.

## BrightSign Shell and BrightScript Debugger

Partners may also find the BrightSign Shell and BrightScript Debugger to be very useful for development purposes. The BrightSign Shell is a command-line interface (CLI) that enables interaction with the BrightSignOS (BOS), the operating system that powers all BrightSign players. The BrightScript Debugger is a CLI which enables interaction with the BrightScript Interpreter.

The [BrightSign Shell page](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/1988100153/BrightSign+Shell) contains info about the various ways to access the Shell, specifics on the type of cable to use if you prefer a physical connection to the player, commands, troubleshooting, and more.

The [BrightSign Debugger page](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/2171994116/BrightScript+Debugger) contains info about how to enable and access the Debugger, commands, troubleshooting, and more.

## Local DWS

The Diagnostic Web Server (DWS) is a powerful tool that enables inspection of various player settings and diagnostic details. Both a Local Diagnostic Web Server (LDWS, accessible over the local network via the player’s IP address) and Remote Diagnostic Web Server (RDWS, accessible via either bsn.Control or bsn.Content at bsn.cloud) are available. General info about the DWS can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370673541/Diagnostic+Web+Server) and more specific info about the RDWS can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/404620688/Remote+Diagnostic+Web+Server).

[Local DWS APIs](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/1172734089/Local+DWS+APIs) also exist to enable direct access to DWS functionality.

## VSCode

Visual Studio Code is a popular coding environment for BrightSign development. The [BrightScript Language](https://marketplace.visualstudio.com/items?itemName=RokuCommunity.brightscript) extension facilitates coding in BrightScript and is used by thousands of developers around the world.

[Next - Partner Resources >](https://brightsign.atlassian.net/wiki/spaces/PID/pages/1516175379)
----
partners\partners\brightsign-partner-packet\integrating-with-brightsign\developer-tools.md
# Developer Tools

BrightSign offers an extensive array of developer tools. These are listed here in alphabetical order.

## BrightSign Shell & BrightScript Debugger

The BrightSign Shell is the CLI (command-line interface) that enables interaction with the BrightSignOS through a serial cable or Telnet/SSH. The BrightScript Debugger is a tool that facilitates debugging of BrightScript code. More info about these tools can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/1988100153/BrightSign+Shell).

## Crash Dumps

If a player encounters a non-deliberate shutdown (aka a crash), “crash dumps” are generated upon reboot. These files contain useful information that BrightSign Support can analyze and use for troubleshooting. These files can be found in the *brightsign-dumps* folder located in the root folder of the player’s storage device.

## Diagnostic Web Server

The Diagnostic Web Server (DWS) is a powerful tool that enables inspection of various player settings and diagnostic details. Both a Local Diagnostic Web Server (LDWS, accessible over the local network via the player’s IP address or by typing `http://BrightSign-NNNNNNNNNN.local` into a browser where `NNNNNNNNNN` is the serial number) and Remote Diagnostic Web Server (RDWS, accessible via either the bsn.Control or bsn.Content at bsn.cloud) are available. General info about the DWS can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370673541/Diagnostic+Web+Server) and more specific info about the RDWS can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/404620688/Remote+Diagnostic+Web+Server).

### Media Analyzer

The DWS includes a useful tool that can analyze media files for playability. More info can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/404620688/Remote+Diagnostic+Web+Server#SD%2FMicroSD%2FMSATA%2FUSB).

## HTML

HTML is a common format for displaying presentations on BrightSign players. The [HTML Best Practices](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370672286/HTML+Best+Practices) document will likely be very useful to developers. Specific sub-sections from that document worth noting individually are listed below.

### Web Inspector

Web pages can be debugged over the local network using the [Web Inspector](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370672286/HTML+Best+Practices#Web-Inspector).

### Chromium Version

The Chromium version that BrightSign players use is likely several versions behind that version that most users are using in their web browsers. Find the Chromium version for the specific firmware version of your player [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/2303000608/Chromium+Downloads+for+Current+Older+OS+Versions).

During development and testing, it is useful to have the correct version of Chromium on your Mac or PC. More information about this can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/2303000608/Chromium+Downloads+for+Current+Older+OS+Versions).

## Logs / Diagnostics

Logs contain important diagnostic information about players. System logs (sometimes referred to as player logs) from the player are available and can be gathered via a syslog server, telnet or SSH, or a serial cable. More info about accessing logs via these means can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/1988100153/BrightSign+Shell#Accessing-Logs).

Refer to [this article](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/2350972929/Get+Player+and+DWS+Logs) on obtaining player logs and [this one](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/2216034305/Interpret+Player+Logs) for interpreting player logs. Logs can easily be accessed via the RDWS as described [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/404620688/Remote+Diagnostic+Web+Server#Log).

## Node

The node prompt is a command-line interface (CLI) that allows you to interact with Node.js. It is used to run JavaScript code and execute Node.js commands. Information about the Node prompt as well as the Node Inspector/Debugger can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370672286/HTML+Best+Practices#Web-Inspector).

## Registry

The *registry* object allows you to read from and write to the player registry (the player’s persistent memory). More info about the registry can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370678545/registry).

## Serial Ports

Brightsign players have serial ports for diagnostic purposes as well as to provide interactive capabilities. More info about the hardware details of player serial ports can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/388434643/Serial+Port+Configuration) and how to use the serial port to access the BrightSign Shell and BrightScript Debugger can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/1988100153/BrightSign+Shell).

## Telnet and SSH

Telnet and SSH can be used to communicate with BrightSign players. More info can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/1988100153/BrightSign+Shell#Telnet).

## VSCode Extension for BrightScript

The popular [BrightScript Language Extension](https://marketplace.visualstudio.com/items?itemName=RokuCommunity.brightscript) for [VSCode](https://code.visualstudio.com/) facilitates writing BrightScript and is used by thousands of developers around the world. Note that Brightsign’s BrightScript is a fork of Roku’s BrightScript. The forks have diverged and while they are similar, they are technically not the same. The value add is mainly the BrightScript syntax highlighting.

Next, we provide a recommended developer setup to help maximize efficiency in developing for the BrightSign platform.

[Next - Developer Setup >](../integrating-with-brightsign/developer-setup.md)
----
partners\partners\brightsign-partner-packet\integrating-with-brightsign\example-app-url.md
# Example (App URL)

In this example, we will be provisioning a player to use the App URL Publishing Mode.

## Player Preparation

To better reflect the most likely experience of a real-world user, we will proceed as if the player is brand new.

If you had previously used the player to follow along with the Manual Setup Example, you can simply erase/reformat the storage device and reinsert into the player. Since the player was not explicitly provisioned with BSN.cloud (the BrightSign Default Setup was used), the player does not need to be reprovisioned.

If you had previously activated the player for use with BSN.cloud, however, refer to the directions [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/395313614/Provision#Reprovisioning) on how to delete the player’s provisioning record and then return here.

> [!WARNING]
> In this example, we will be provisioning the player *prior* to booting up the player for the first time. If a new player does not already have a provisioning record with BSN.cloud, powering up the player will take the user to the [Activation](https://brightsign-sandbox-694.atlassian.net/wiki/spaces/DOC/pages/6560502) screen. Activation provisions the player with the current Default Setup. Unless another default Setup has been created, the player will be provisioned with the BrightSign Default Setup which uses the bsn.Content as the Publishing Mode. Reprovisioning the player would then be required to apply a different Setup. Provisioning the player prior to activating the player thus saves the step of having to reprovision the player.

## Provision Player

1.  Do *not* power up the player.
    
2.  Write down the player’s Serial Number. The Serial Number can be found on the label on the bottom of the player itself or on a label on the box that the player was packaged in.
    
3.  Go to **Admin** > **Provision** > **Add Player**. Enter the Serial Number you wrote down. If desired, you can also enter an optional Player Name and Player Description.
    
4.  Select **Add Player**.
    

![](./attachments/image-20230914-201123.png)

The player should now appear in the list of players. Note that it has been assigned the Default Setup. If you have not explicitly created a new Default Setup, this Default Setup will be the BrightSign Default Setup.

Next:

1.  Select the player you wish to provision. This should be the player with the serial number you just added above.
    
2.  Select **Apply App URL** from the drop-down menu.
    
3.  In the pop-up window, select **App URL** and enter the URL where the desired *autorun.zip* file resides. If you like, you can use the example URL here: [https://www.brightsign.biz/examples/autorun.zip](https://brightsign.biz/examples/autorun.zip)
    
4.  Select **Apply**.
    

![](./attachments/image-20230914-201639.png)

The player is now provisioned for the App URL publishing mode. All of the other player settings, since they have not been explicitly changed, remain per the BrightSign Default Setup.

## Power Up Player

Power up the player. Once the player has booted, it will search for a provisioning record on BSN.cloud. If a record is found, the player will apply the settings according to its provisioning record. Since we created a provisioning record for this player in the previous steps, the player will apply those settings. In this case, the provisioning record instructs the player to go to the designated URL, download the *autorun.zip* file there, unzip that file, and then reboot to run the *autorun.brs* within the *autorun.zip* file. The *autorun.brs* file has been configured to display the HTML presentation contained in the *autorun.zip* file.

The same presentation that was previously displayed with the manual copy example should now be shown on the screen. Whereas with the previous example, the *autorun.zip* file was manually copied to the player’s storage device, the player now has been remotely provisioned to retrieve the *autorun.zip* file from a URL.

[Next - Developer Tools >](../integrating-with-brightsign/developer-tools.md)
----
partners\partners\brightsign-partner-packet\integrating-with-brightsign\onboarding.md
# Onboarding

Every partner has different needs and perspectives, so meeting with our Partner Integration and Engineering team can help us put you on a path best suited for your needs. Connect with the team at [integrations@brightsign.biz](mailto:integrations@brightsign.biz) to get started creating an integration plan.

New partners typically follow this process to integrate with BrightSign:

1.  Sign NDAs.
    
2.  BrightSign shares relevant documentation.
    
3.  After the documentation has been read, a technical call can be set up to discuss the technical details of the integration.
    
4.  The partner develops their integration for BrightSign players.
    
5.  If technical issues arise during development, BrightSign can provide support through our ticketing system.
    
6.  The partner tests and approves their code.
    
7.  When the technical integration is complete, the partner fills out the self-certification form which is required for any co-marketing activities with BrightSign.
    
8.  The integration is packaged and handed over to the go-to-market teams.
    

To maximize the chances for a successful integration, we recommend that you adhere to our guidelines for Technical Best Practices.

[Next - Technical Best Practices >](../../brightsign-partner-packet/technical-best-practices.md)
----
partners\partners\brightsign-partner-packet\integrating-with-brightsign\partner-resources.md
# Partner Resources

## Caching

Details on HTML caching can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/388435136/HTML+Caching).

## JavaScript

Information about our JavaScript API can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370678188/JavaScript+APIs).

## Node.js

Details on how to use Node.js with BrightSign players can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370677153/Node.js).

## REST APIs

BrightSign offers REST APIs that enable partners to interface with players. Details [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/1490092192/BrightSign+REST+API+Overview).

## Extensions

In most cases, any desired functionalities can be accomplished through the various tools and resources available. While extensions may be useful in certain circumstances, they are generally discouraged for long-term support reasons. If you feel an extension is necessary for your application, please inquire with [integrations@brightsign.biz](mailto:integrations@brightsign.biz) for assistance regarding your specific situation.

Next, we will cover the partner onboarding process.

[Next - Onboarding >](../integrating-with-brightsign/onboarding.md)
----
partners\partners\brightsign-partner-packet\integrating-with-brightsign.md
# Integrating with BrightSign

As was shown in the hands-on example, BrightSign players can be provisioned by manually copying the necessary files to each player’s storage device. While this approach may be feasible for small numbers of easily accessible players requiring infrequent content updates, the manual approach quickly becomes untenable with larger networks of players that may be difficult to access and/or situations in which regular content updates are desired.

To fully take advantage of BrightSign offerings, partners are encouraged to utilize the many powerful tools BrightSign offers that help streamline the deployment and management of players.

[Next - bsn.Control Integration >](#)
----
partners\partners\brightsign-partner-packet\operational-best-practices.md
# Operational Best Practices

Based on our experience, partners that follow these practices have the most successful BrightSign integrations:

*   We encourage you to report any issues so that we can help you resolve them. Contact [integrations@brightsign.biz](mailto:integrations@brightsign.biz) for support.
    
*   If integration issues arise, the partner should be the one that communicates with our support team, not the partner’s customers.
    
*   To ensure ongoing alignment between BrightSign’s technologies and partners' goals, we encourage partners to be proactive and talk to us before making major changes to their existing integration(s).
    
*   Partners should be aware that BrightSign may not fully test experimental features in components such as Chromium. If experimental features are used as part of the integration, stability may be adversely affected.
    

Next, we will cover the responsibilities expected of BrightSign and our partners.

[Next - BrightSign / Partner Responsibilities >](https://brightsign.atlassian.net/wiki/spaces/PID/pages/1531379758/BrightSign+Partner+Responsibilities)
----
partners\partners\brightsign-partner-packet\partner-glossary.md
# Partner Glossary

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Table of Contents

*   [autorun.brs](#autorunbrs)
*   [autorun.zip and autozip.brs](#autorunzip-and-autozipbrs)

*   [BrightAuthor:connected](#PartnerGlossary-BrightAuthor:connected)
*   [BrightScript Debug Console](#PartnerGlossary-BrightScriptDebugConsole)
*   [BrightSign Shell / Console](#PartnerGlossary-BrightSignShell/Console)
*   [BSN.cloud](#PartnerGlossary-BSN.cloud)
    *   [bsn.Control](#bsncontrol)
    *   [bsn.Content](#bsncontent)
*   [Chromium](#PartnerGlossary-Chromium)
*   [Console](#PartnerGlossary-Console)
*   [CMS](#PartnerGlossary-CMS)
*   [Content Delivery](#PartnerGlossary-ContentDelivery)
*   [Content / Presentation](#PartnerGlossary-Content/Presentation)
*   [Crash Dumps](#PartnerGlossary-CrashDumps)
*   [Diagnostic Web Server](#PartnerGlossary-DiagnosticWebServer)
    *   [Media Analyzer](#media-analyzer)
*   [HTML](#PartnerGlossary-HTML)
    *   [Web Inspector](#web-inspector)
    *   [Chromium Version](#chromium-version)
*   [Logs / Diagnostics](#PartnerGlossary-Logs/Diagnostics)
*   [Node](#PartnerGlossary-Node)
*   [Partner App](#PartnerGlossary-PartnerApp)
*   [Player](#PartnerGlossary-Player)
*   [Provisioning](#PartnerGlossary-Provisioning)
*   [Registry](#PartnerGlossary-Registry)
*   [Serial Ports](#PartnerGlossary-SerialPorts)
*   [Setup](#PartnerGlossary-Setup)
*   [Storage Device](#PartnerGlossary-StorageDevice)
*   [Swivel](#PartnerGlossary-Swivel)
*   [Telnet and SSH](#PartnerGlossary-TelnetandSSH)
*   [Visual Studio Code](#PartnerGlossary-VisualStudioCode)
*   [VS Code Extension for BrightScript](#PartnerGlossary-VSCodeExtensionforBrightScript)

## autorun.brs

Upon bootup, players look for an *autorun.brs* file which instructs the player what to do upon startup. This file is required for all players.

## autorun.zip and autozip.brs

Players also look for *autorun.zip* files that contain the script *autozip.brs*. If found, the player will execute *autozip.brs* which unpacks the contents of the *autorun.zip* file to the root directory of the storage device and reboots the player.

# BrightAuthor:connected

This software, available for Mac and PC, provides an easy-to-use interface for creating presentations, create and assign player schedules, and monitor player status and health of players. The software also enables users to setup, activate, and provision new players as well as manage user roles and permissions.

# BrightScript Debug Console

The BrightScript Debug Console is a tool that facilitates debugging of BrightScript code. It is available through the BrightSign Shell (see below). To turn the BrightScript Debug Console on, type `script debug on` at the console. More info can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370672795/BrightScript+Debug+Console).

# BrightSign Shell / Console

The BrightSign Shell, also referred to as the BrightSign Console, is the command line interface that enables interaction with the BrightSign OS through a serial cable or telnet/SSH.

From the BrightSign Shell, the `script` command can be used to access the BrightScript Debug Console, and the `node` command can be used to access Node related functions.

Commands for the BrightSign Shell can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/404621543/BrightSign+Shell+Commands).

# BSN.cloud

BrightSign’s robust cloud-based platform that provides a myriad of tools and services to help customers and partners easily use a single player or manage an expansive network of players. BSN.cloud consists of two different options: the free bsn.Control and the paid bsn.Content.

## bsn.Control

Free solution the enables viewing of player information, player provisioning, remote diagnostics, and access to REST APIs.

## bsn.Content

Paid solution that includes all the features of bsn.Control plus content hosting; the ability to create, schedule, and publish content; advanced network management tools; and user groups, roles, and privileges.

# Chromium

Chromium is the free and open-source web browser project primarily developed and maintained by Google. It is the underlying engine for the ubiquitous Chrome browser. BrightSign players use the same Chromium software to render and display web content.

# Console

The informal name for BrightSign’s command line interface.

# CMS

As might be surmised, a Content Management System, or CMS, is used to manage content. CMSs are also often used to manage player setup, activation, provisioning, scheduling, and diagnostics.

While separate apps may be used to author and publish presentations, this guide will use the term CMS as a catch-all term to refer to software that enables authoring, publishing, and management of presentations, content, and players.

# Content Delivery

This term is used to describe the process of getting content onto the player’s storage device.

# Content / Presentation

Strictly speaking, a presentation refers to the file that controls the layout and behavior of the items that the player will display.

Content refers to the visual item(s) being displayed by the presentation. Content thus refers to media files associated with the presentation such as videos, images, and audio files.

Since the presentation and content depend on each other to render properly (one cannot be displayed without the other), the term “content” is generally be used to represent *both* the presentation *and* its content.

# Crash Dumps

When a player encounters a non-deliberate shutdown (aka a crash), “crash dumps” are generated upon reboot. These files contain useful information that BrightSign Support can analyze and use to help troubleshoot. These files can be found in the *brightsign-dumps* folder located in the root folder of the player’s storage device.

Further details about crash reports can be found [https://brightsign.atlassian.net/wiki/spaces/IKB/pages/519144363](https://brightsign.atlassian.net/wiki/spaces/IKB/pages/519144363).

# Diagnostic Web Server

The Diagnostic Web Server (DWS) is a powerful tool that enables inspection of various player settings and diagnostic details. Both a Local Diagnostic Web Server (LDWS, accessible over the local network via the player’s IP address) and Remote Diagnostic Web Server (RDWS, accessible via either the Control Cloud or Content Cloud at bsn.cloud) are available. General info about the DWS can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370673541/Diagnostic+Web+Server) and more specific info about the RDWS can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/404620688/Remote+Diagnostic+Web+Server).

## Media Analyzer

The DWS includes a useful tool that can analyze media files for playability. More info can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/404620688/Remote+Diagnostic+Web+Server#SD%2FMicroSD%2FMSATA%2FUSB).

# HTML

HTML stands for HyperText Markup Language. It is a standard markup language for web page creation and is also a common format for displaying presentations on BrightSign players. The [HTML Best Practices](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370672286/HTML+Best+Practices) document will likely be very useful to developers. Specific sub-sections from that document worth noting individually are listed below.

## Web Inspector

Web pages can be debugged over the local network using the [Web Inspector](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370672286/HTML+Best+Practices#Web-Inspector).

## Chromium Version

The Chromium version that BrightSign players use is likely several versions behind that version that most users are using in their web browsers. Find the Chromium version for the specific firmware version of your player [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370672286/HTML+Best+Practices#Renderer-Versions-and-Support).

During development and testing, it is useful to have the correct version of Chromium on your Mac or PC. More information about this can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/2303000608/Chromium+Downloads+for+Current+Older+OS+Versions).

# Logs / Diagnostics

Logs contain important diagnostic information about players. System logs (sometimes referred to as player logs) from the player are available and can be gathered via a syslog server, telnet or SSH, or an RS-232 serial cable. More info can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370673311/roSystemLog).

Refer to [this article](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/2350972929/Get+Player+and+DWS+Logs) on obtaining player logs and [this one](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/2216034305/Interpret+Player+Logs) for interpreting player logs. Logs can easily be accessed via the RDWS as described [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/404620688/Remote+Diagnostic+Web+Server#SD/MicroSD/MSATA/USB).

# Node

The node prompt is a command-line interface (CLI) that allows you to interact with Node.js. It is used to run JavaScript code and execute Node.js commands.

# Partner App

A “partner application” or “partner app” refers to the partner software that resides on the player’s storage device. In most cases, the partner app consists of the presentation that the partner wishes the player to display. Upon bootup, the player runs the *autorun.brs* file which can be configured to invoke the partner app.

# Player

BrightSign’s extensive line of hardware devices specifically designed for digital signage.

# Provisioning

This term generally refers to the process of activating a player and getting an *autorun.brs* file onto the player’s storage device.

# Registry

The *registry* object allows you to read from and write to the player registry (the player’s persistent memory). More info about the registry can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370678545/registry).

# Serial Ports

Brightsign players have serial ports for diagnostic purposes as well as to provide interactive capabilities. More info about serial ports can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/388434643/Serial+Port+Configuration).

# Setup

Setups are files containing information such as the intended publishing configuration and various player settings. Setups can be applied to one or many players and different Setups can be saved to the Setup Library.

# Storage Device

BrightSign players lack onboard storage and require a separate storage device. Storage devices include microSD (µSD) cards as well as USB drives such as thumb drives, external hard drives, and external solid-state drives (SSDs). Many BrightSign players also support internal SSDs in the common M.2 form factor.

# Swivel

While not an official term, the word “swivel” is sometimes used to describe a partner integration in which users interact with the partner’s CMS using one browser tab while interacting with the Control Cloud interface in another browser tab.

# Telnet and SSH

Telnet and SSH are both network protocols that allow you to connect to remote computers over the internet. Telnet is an older protocol that is used for remote access to servers and networking devices. It sends data in plain text without any encryption or authentication, which makes it insecure. SSH (Secure Shell) is a newer protocol that provides secure remote access to servers and networking devices. It encrypts all data sent between the client and server, making it much more secure than Telnet. [SSH also uses public key authentication for added security](https://infraexam.com/how-is-ssh-different-from-telnet/).

Telnet and SSH can be used to communicate with BrightSign players. More info can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370673607/Telnet+and+SSH).

# Visual Studio Code

Visual Studio Code (VS Code) is a source-code editor made by Microsoft with the Electron Framework, for Windows, Linux and macOS. It is used for editing text and managing your entire codebase like an integrated development environment (IDE). [It supports debugging, syntax highlighting, intelligent code completion, snippets, code refactoring, and embedded Git](https://opensource.com/article/20/6/open-source-alternatives-vs-code).

# VS Code Extension for BrightScript

The popular [BrightScript Language](https://marketplace.visualstudio.com/items?itemName=RokuCommunity.brightscript) extension for [VSCode](https://code.visualstudio.com/) facilitates coding in BrightScript and is used by thousands of developers around the world. Note that Brightsign’s BrightScript is a fork of Roku’s BrightScript. The forks have diverged and while they are similar, they are technically not the same. Nevertheless, developers may find value in this extension.
----
partners\partners\brightsign-partner-packet\player-setup-provisioning.md
# Player Setup / Provisioning

> [!INFO]
> bsn.Control and bsn.Content were formerly named Control Cloud and Content Cloud, respectively.

## Player Setup

As covered in the [Start Here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/1968472149/Start+Here) section, new players must first be set up before they can do much of anything. This process involves applying a **Setup** to the player. The Setup applies various settings to the player (network settings, Publishing Mode, logging, etc.) and includes a **Player App** which provides instructions for what the player should do upon startup.

![image-20240404-165839.png](./attachments/image-20240404-165839.png)

## Player Provisioning

As was also mentioned in the [Start Here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/1968472149/Start+Here) section*,* the term *provisioning* refers to using BSN.cloud to set up a player, and given that BSN.cloud (either the bsn.Control or bsn.Content tiers) is used the vast majority of time to set up players, the term provision is often used when referring to player setup.

The primary cases where a player can be properly set up instead of provisioned (i.e., BSN.cloud is not used to apply the Setup to the player) are:

*   Standalone player configurations where the Setup is manually copied to a storage device and then the storage device is connected to a player.
    
*   Uncommon situations where a partner chooses to set up players without using BSN.cloud.
    

With BSN.cloud, provisioning a new player can be nearly automatic - if things are properly set up beforehand, new players can be automatically provisioned just by plugging them in! For customers who can’t or don’t want to connect their players to the internet, offline provisioning options are also available.

> [!INFO]
> Provisioning of players can be done for free using either BrightAuthor:connected or the unbranded bsn.Control interface at control.bsn.cloud. However, since control.bsn.cloud is the interface preferred by most partners, this guide will largely focus on using control.bsn.cloud.

## Setup

Setups can be created using the free and unbranded bsn.Control interface at control.bsn.cloud. Setups can be saved to the [Setup Library](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/395313604/Setup+Library) to be used or modified in the future.

Once created, Setups can be applied to a player or group of players using control.bsn.cloud. Alternatively, the information contained in a Setup can be directly incorporated into the Player App (described below) and manually copied to the player’s storage device.

### Player Settings

The Setup establishes various player settings which include things like [Publishing Mode](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/1968078934/Player+Setup+Provisioning#Publishing-Mode), network settings (Ethernet, WiFi, etc.), player identification (name and description), logging, and more.

### Player App

The set of files and folders that instruct the player what to do upon boot up is collectively known as the Player App. At a minimum, the Player App must contain an *autorun.brs* file (the .brs extension denotes a BrightScript file) which instructs the player what to do upon startup.

When a Setup is applied to a player via BSN.cloud, an autorun.brs file is automatically created on the player.

Partners can write custom Player Apps according to their specific needs. For example, the Player App may be designed to connect to the partner CMS to download content from the CMS for the player to display.

> [!INFO]
> The term Partner App may sometimes be used when referring to the partner’s Player App.

More info about Setups can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/395313598/Setup) and more info about provisioning can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/395313614/Provision).

[Next - Player Provisioning and Recovery System Requirements >](./player-setup-provisioning/player-provisioning-and-recovery-system-requirements.md)
----
partners\partners\brightsign-partner-packet\support.md
# Support

As you dive into the details of your integration, technical questions will inevitably arise. Many questions can be answered on our [support site](https://support.brightsign.biz/hc/en-us).

If more assistance is needed, we are here to help and have created a ticketing system to help manage and track issues. The ticketing system ensures efficient routing of issues directly to the relevant teams within BrightSign and makes it easier for all parties involved to stay updated on issue status.

New issues and questions should be emailed to [integrations@brightsign.biz](http://support@brightsign.biz/) which will trigger a new ticket to be created. A few important things to keep in mind:

*   Each new issue or question you or your team has should be generated as a new ticket. To create a new ticket, email [integrations@brightsign.biz](http://support@brightsign.biz/). Any messages coming from your email domain gets automatically routed to a priority queue for partners.
    
    *   Please refer to the next section for tips on [how to create a good support ticket](./support/writing-a-good-support-ticket.md). Providing the necessary details on your ticket from the outset will help get your ticket resolved as efficiently as possible.
        
*   To reply to tickets, simply reply to the email sent by the ticketing system.
    
*   The ticketing system can also be accessed via a web UI. Generally speaking, the primary benefit of the web UI is to view all open items. In most cases, it is easiest to just reply to the emails from the ticketing system.
    

We are always excited to hear from our customers. Feature requests and other feedback can be made on the [BrightSign Product and Feature Request Discussion forum](https://brightsign.zendesk.com/hc/en-us/community/topics/115000001633-BrightSign-Product-and-Feature-Request-Discussion). Our Product Management team uses this community/forum to track requests from our users. While you're there, make sure to upvote any other features you think would be useful in future releases.

When requesting technical support, it is important to include all relevant information. Next, we provide some guidelines for writing a good support ticket.

[Next - Writing a Good Support Ticket >](./support/writing-a-good-support-ticket.md)
----
partners\partners\brightsign-partner-packet\technical-best-practices.md
# Technical Best Practices

To assist partners in getting up and running as efficiently as possible, we’ve compiled a list of technical best practices to maximize your chances of success.

## brightsign-dumps Folder

When developing your own autoruns, do not forget to include instructions for the autorun to create a *brightsign-dumps* folder on the player. The *brightsign-dumps* folder is used to store crash information and is very useful to BrightSign support when troubleshooting.

## Free Tools

BrightSign offers a plethora of free tools and services that greatly ease provisioning and diagnostics. These include the powerful tools available via bsn.Control for player provisioning as well as the many tools described in the [Developer Tools](../brightsign-partner-packet/integrating-with-brightsign/developer-tools.md) section of this guide. Partners are highly encouraged to take as much advantage of these tools as possible as it accelerates development and also makes support and troubleshooting much easier.

## Memory Management

BrightSign players are purpose-built for digital signage. Players are not general-purpose devices and they do not have, nor do they require, as much memory as a typical Mac or PC. When developing for the BrightSign platform, developers should be cognizant of potential memory limitations that they may not be accustomed to.

## OS Updates

Partners should try to use the latest BrightSignOS builds in order to take advantage of the latest bug fixes and newest features. Keeping up to date with the latest OS build also enables partners to more easily expand their deployments with our latest hardware.

We are continuously improving the firmware on our players, but as is often the case with software, problems are sometimes inadvertently introduced. A stable player is paramount to any BrightSign integration, so we strongly encourage partners to thoroughly test any BrightSign firmware releases prior to upgrading any players being used in a production environment.

## HTML <video> Elements & Memory

It is fairly common for a presentation to include switching from one video to another. In many BrightSign players, including the Series 4 line, if a video element is not explicitly released, that element will continue to use memory even if it is no longer actively displaying. It is therefore important to reset the source to blank prior to switching videos. If this is not done, the first video(s) will continue to use memory while subsequent videos are playing, potentially resulting in the following log message:

`Failed to find a video decoder`

To release the video element, the `src` attribute of the `<video>` should be set to blank:

`video.src = "";`

Additional detail on this topic can be found [here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370672326/HTML+Video#Multiple-Video-Elements).

## Smooth Video Transitions

If multiple videos are being displayed sequentially, it is generally desired for one video to transition smoothly into the other one. To help ensure this, make sure that both the first and last frames of the videos do not consist of a blank frame. The presence of even one blank frame between videos can result in a noticeably jarring transition between videos.

## Upgradeability

Change is inevitable so partners are recommended to design their apps with the ability to push updates to players remotely. This applies not only to the partner app itself, but also to diagnostic scripts which can be very useful for troubleshooting.

[Next - Operational Best Practices >](../brightsign-partner-packet/operational-best-practices.md)
----
partners\partners\brightsign-partner-packet.md
# BrightSign Partner Packet

![](./attachments/BrightSign%20Partner%20Packet-20230120-182258.png)

Welcome to the BrightSign Partner Packet! This document serves as an introductory guide for the integration of partner Content Management Systems (CMS) with the BrightSign ecosystem which includes BrightSign’s extensive array of digital signage players as well as a rich set of player management services.

CMS partners are able to build applications that allow their customers to set up, publish to, and manage BrightSign players. BrightSign’s development technologies, including our open APIs, enable seamless partner integrations.

We offer services and support from multiple worldwide locations, and our Partner Integration, Business Development, and Marketing teams are dedicated to helping our partners every step of the way from initial inquiries and on-boarding to market launch.

> [!WARNING]
> ## Attention New Partners
> BrightSign’s products and services are highly differentiated and function in unique ways. If you are new to BrightSign, it is *highly recommended* that you go through the [Start Here](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/1968472149/Start+Here) section which provides a quick, high-level overview of how our products and services work.

For partners who already have a good understanding of how our players and services function, let’s get started!

Each page will have a “Next >” link at the bottom which takes you to the next page in the packet. Alternatively, you can skip to any page/section in the packet using the collapsible page tree on the left.

[Next - BrightSign Players >](./brightsign-partner-packet/brightsign-players.md)
----
partners\partners\bsncloud-for-partners\adding-partner-cms-players-to-a-bsncloud-network.md
# Adding Partner CMS Players to a BSN.cloud Network

Players that are configured for a partner CMS application can also use a BSN.cloud network connection to access players for configuration and maintenance. To do this, temporary replace the partner CMS autorun with an *autorun*.*brs* that can make the changes needed to connect to BSN.cloud. This process is described below.

## Prerequisites

1.  You must be able to access the player on the local DWS through a browser.
    
2.  You must know the name of the target BSN.cloud network.
    
3.  You will need a registration token. See the Appendix for instructions.
    
4.  After getting the token, you must download the *cloudParameters.json* file from the Appendix and customize it:
    
    1.  Edit line 9 to add the registration token.
        
    2.  Edit line 10 to add the target network name, then save the file.
        

## Replace the Autorun and Reboot the Player

1.  Open the local DWS for the player you are adding to BSN.cloud and go to the **SD** tab.
    
    1.  Upload the *cloudParameters.json* file to the SD card.
        
    2.  Download and open the *standalone-autorun.brs* file in the Appendix. If you saved the *cloudParameters.json* file under a different name on the SD card, make sure that line 4 of *standalone-autorun.brs* references the correct name.
        
    3.  Upload the *standalone-autorun.brs* to the SD card.
        
2.  Go to the **SD** tab in the local DWS and locate the *autorun.brs* file.  
    
3.  Select the cogs icon, shown in Image 1, to go to the **Rename** section:
    
    1.  Rename *autorun.brs* to *autorun.backup*
        
    2.  Rename *standalone-autorun.brs* to *autorun.brs.*
        
4.  Go to the **Control** tab in the local DWS and reboot the player.
    
5.  The player will appear in the BrightAuthor:connected **Network** tab when it has rebooted, and the *autorun.brs* will again reference the partner CMS application.
    

![image-20240305-163734.png](./attachments/image-20240305-163734.png)

## Appendix

### BRS and JSON Files

[cloudParameters.json](./attachments/cloudParameters.json)
[standalone-autorun.brs](./attachments/standalone-autorun.brs)

### Getting a Registration Token through BSN.cloud

1.  Create a new setup package with BSN.cloud.
    
2.  Select **Save Setup** and choose a location to save the package on your computer.
    
3.  Open the folder where you saved the package and open the *current-sync.json* file.
    
    1.  At the top of the file you will find similar script to Image 2. The long string after `"bsnRegistrationToken"`, is your registration token. The string after “account” should match your target network name inserted in step 4c.
        

![Screenshot 2024-03-05 at 8.28.20 AM.png](./attachments/Screenshot%202024-03-05%20at%208.28.20%20AM.png)

### Getting a Registration Token through an API

First get your OAuth token correctly issued for the target network, then see [Token Entity (v3)](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/1427013681/Token+Entity+v3).
----
partners\partners\bsncloud-for-partners\applying-settings-in-the-properties-panel.md
# Applying Settings in the Properties Panel

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Table of Contents

*   [Prerequisites](#prerequisites)
*   [Implementing the Settings Handler / Disabling Property Lock](#implementing-the-settings-handler-disabling-property-lock)
*   [API Specification](#api-specification)
    *   [POST /api/v1/system/supervisor/capabilities](#post-apiv1systemsupervisorcapabilities)
        *   [Request Body](#request-body)
        *   [Response Body](#response-body)
*   [Example Script](#example-script)
*   [Caveats](#caveats)

BrightSign’s OS version 8.2.72 and BrightAuthor:connected version 1.6.29 contain a new feature that lets users see and modify settings using the BSN.cloud Properties Panel or through the BSN.cloud API. To avoid backwards compatibility issues, the supervisor won't honor these settings unless it is first enabled in a custom presentation or custom application/plugin.

This feature is natively supported and enabled in BrightAuthor:connected presentations using version 1.6.29 or later, but you must enable it if you are running custom scripts. The steps required to enable this feature are described below.

## Prerequisites

*   You must be using BSN.cloud
    
*   Minimum BrightAuthor:connected version: 1.6.29
    
*   Minimum OS version: OS 8.2.72
    

## Implementing the Settings Handler / Disabling Property Lock

A player under the control of BSN.cloud will, by default, disallow updates pushed from the cloud to the player if it is using a partner application. To allow the player to accept property updates from BSN.cloud, implement the Settings Handler which allows you to disable [Property Lock](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/404623943/Presentation+Settings#Property-Lock). Partners can do this using the Example Script on this page.

To enable the Settings Handler:

1.  Include the code snippet from the Example Script section in your custom presentation or custom application/plugin.
    
2.  In BrightAuthor:connected, navigate to the player’s network (under the [Network](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/384958995/Network) tab on the top right). In this section, the player settings are available in the Properties panel.
    

Once the device-side API is turned on, the player settings will be accessible in the Properties panel of BrightAuthor:connected (under the [Network](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/384958995/Network) tab).

## API Specification

This API specification is used by custom presentations or plugins, either invoked by BrightScript or JavaScript, to enable the “Settings Panel” (Settings Handler).

The base URL or player’s IPv4 IP address (the default port server is hosted on 80) is [http://localhost](http://localhost)

> [!NOTE]
> This is an internal endpoint and will only respond to a Node or JavaScript application running on the player (it is not part of the local DWS).

### POST /api/v1/system/supervisor/capabilities

#### Request Body

```
{
	"script": {
	“type”: “Custom”
	“version”: “10.0.60” // Can be any version in a x.x.x format. Used to communicate script version to BSN.cloud,
	displayed in “Settings Panel” }
}
```

#### Response Body

*   Success: {"success":true}
    
*   Error: {"status”: <error status code>, “message”: <error message>}
    

## Example Script

Partners who want to upgrade to use this feature must include the following code snippet in their BrightSign presentation or plugin. 

Note that this example is a simple autorun which can be run as is. However the `EnableSettingsHandler`() subroutine should either be copied and called in an appropriate location relative to the other logic in the script, or the code within `EnableSettingsHandler()` can be copied and pasted into a valid location in script to be run within the existing logic. This assumes the developer has basic knowledge of BrightScript.

```
Sub main()
  EnableSettingsHandler()
end sub
 
Sub EnableSettingsHandler()
  localBaseUrl = "http://localhost"
  supervisorApiV1Route = "/api/v1"
   
  supervisorCapabilitiesUrlXfer = CreateObject("roUrlTransfer")
  supervisorCapabilitiesUrlXfer$ = localBaseUrl + supervisorApiV1Route + "/system/supervisor/capabilities"
  supervisorCapabilitiesUrlXfer.SetUrl(supervisorCapabilitiesUrlXfer$)
  supervisorCapabilitiesUrlXfer.SetTimeout(15000)
  supervisorCapabilitiesUrlXfer.SetProxyBypass(["127.0.0.1", "localhost"])
  supervisorCapabilitiesUrlXfer.addHeader("Content-type", "application/json")
   
  msgPort = CreateObject("roMessagePort")
  supervisorCapabilitiesUrlXfer.SetPort(msgPort)
  initiatorIdentity = supervisorCapabilitiesUrlXfer.GetIdentity()
   
  script = CreateObject("roAssociativeArray")
  scriptType$ = "Custom"
  version$ = "10.0.60" ' current autorun script version
     
  script.AddReplace("type", scriptType$)
  script.AddReplace("version", version$)
   
  body = {}
  body.AddReplace("script", script)
     
  stringifiedJson = FormatJson(body)
     
  ok = supervisorCapabilitiesUrlXfer.AsyncPostFromString(stringifiedJson)
   
  if not ok then
    print "=== Failed to send POST Request"
  else
    print "=== Settings Handler request sent"
  end if
   
  while true
    msg = Wait(0, msgPort)
    if (type(msg) = "roUrlEvent")
      receivedIdentity = msg.GetSourceIdentity()
      if (initiatorIdentity = receivedIdentity) then
        print "=== " + supervisorCapabilitiesUrlXfer$ + ", Response Code: " + strI(msg.GetResponseCode())
      end if
    end if
  end while
end sub

```

## Caveats

*   The settings handler can override custom settings applied by the setup script.
    
*   Edits to the property sheet settings in the interface will not be applied on the device side unless the code snippet above is added to the runtime application or it is added as a plugin to the custom presentation.
----
partners\partners\bsncloud-for-partners\controlbsncloud.md
# Control.BSN.cloud

Control Cloud is a solution that allows partners to automate new player set up through Device Provisioning (also known as B-Deploy), monitor networks through BrightAuthor:connected, and examine problems through a remote diagnostic web server. This page will go over the basics on how to use these new features to manage BrightSign players in your network. The Control Cloud can be accessed through [control.bsn.cloud](http://control.bsn.cloud).

# Device Provisioning (B-Deploy)

Device Provisioning is a service that allows for automated provisioning of BrightSign players over the Internet. In order to use Device Provisioning, CMS partners need to provide and maintain an application URL on an accessible HTTP file server host. The package should be contained in an *autorun.zip* file containing presentation files along with an *autozip.brs* boilerplate script. In most cases, the script will not need to be modified.

Once the package has been hosted, device setups made through BrightAuthor:connected can point players directly to the application URL. Open BrightAuthor:connected and sign into BSN.cloud to select the cloud network desired. Under **Device Setup**, two options make use of externally hosted applications. The **Custom Application URL** option requires the link to be manually input into the field. The **Partner Application** option provides a drop down menu of applications that have been officially registered with Device Provisioning servers. To get an application URL added to the drop down, contact the Partner Integration team. Add the setup file to the library when done.

![](./attachments/SetupFigure.png)

Navigate through the **Admin** tab to **Device Provisioning**. From this page, select **Add Device** and enter the serial number of all players desired. This process will register the player to currently selected BSN.cloud network. From here, check mark the boxes of all players and apply the setup. Alternatively, clicking **Download Template** will download a Microsoft Excel file that contains columns for Serial Number, Device Name, Setup File, Application URL, and Description. The Excel sheet can be used to help expedite the process by adding multiple serial numbers simultaneously and automatically assigning them setup files and application URLs.

![](./attachments/ProvisioningFigure.png)

When everything is entered correctly, the player should automatically query the Device Provisioning servers when connected to the internet and powered on. The Device Provisioning servers will then assign the players the corresponding setup files and point to any application URLs entered, and the player will automatically configure itself and play any presentation files contained in the *autorun.zip*. For more information about Device Provisioning, please see [this page](#).

## Re-provisioning vs. Factory Resetting a Player

Cloud connected players should be re-provisioned rather than factory reset, if they must be refreshed.

> [!WARNING]
> ### Note
> If the player to be re-provisioned is currently configured on a network which requires a specification configuration (security, certificates, etc.) or is a Wifi player, chose **Use Current Device Settings** in **Device Setup > Network Configuration** on the bottom left to maintain your player's current network configuration.

Factory reset should only be used if you have local access to the player since it deletes all registry sections and clears network interfaces. The factory reset may leave a remote player in an inaccessible state (it would only be possible to factory reset a player and reconnect to BSN.cloud if the user has a "Device Provisioning" entry in BrightAuthor:connected, and their network allows a rogue device to retrieve an active ip address for a B-Deploy connection).

# Remote Diagnostic Web Server

Control Cloud also offers access to a remote diagnostic web server (DWS). Administrators can use the DWS to monitor the health of players on the network, as well as view and modify settings of any players over the Internet. To access the DWS, open BrightAuthor:connected through either the application or webtop service, or go to control.bsn.cloud and sign in. Select the **Network** tab to see all registered players on the network and their health status, then click the gear icon to the right of the desired player to enter the DWS.

From the **Info** tab, the DWS can provide basic info such as a snapshot of the time on the player, the model number, MAC address, IPv6 address, OS version, and up time.

![](./attachments/InfoFigure.png)

The **Log** tab provides a way to remotely download the player log for troubleshooting purposes

![](./attachments/LogFigure.png)

The **Control** tab allows admins to reboot the player with or without a crash report, factory reset the player, change the recovery URL, disable local DWS access, and reprovision the device remotely.

![](./attachments/ControlFigure.png)

The **SD** tab allows remote uploading of files directly to the SD card; however, the file size cannot exceed 10MB. 

![](./attachments/SDFigure.png)

The **Diagnostics** tab contains various diagnostic tools:

![](./attachments/DiagFigure.png)

1.  **Network Configuration** allows admins to view the network configuration selection of the player.
    
2.  **Network Neighborhood** allows admins to view information about the network neighborhood of the player.
    
3.  **Network Diagnostics** runs network diagnostics on the player.
    
4.  **Network Packet Capture** allows admins to set up a network packet capture. The packet capture can be over ethernet, WiFi, or 3G modem. File sizes exceeding 10MB cannot be downloaded.
    
5.  **DNS Lookup** allows admins to test name resolution on a DNS hostname.
    
6.  **Disable Autorun** disables the currently run script and reboots the player.
    
7.  **Ping** pings an IP address.
    
8.  **Storage Formatting** formats the SD inserted in the player.
    
9.  **Trace Route** performs route tracing on an IP address or hostname.
    

The **Snapshot** tab can pull a real-time snapshot of the content being displayed by the player.

![](./attachments/SnapshotFigure.png)

The **Video** tab displays the current video mode and allows manual adjustment if required, as well as toggle the **Power Save** option.

![](./attachments/VideoFigure.png)

The **Advanced** tab provides a registry dump and the ability to update the OS of the player.

![](./attachments/AdvancedFigure.png)
----
partners\partners\bsncloud-for-partners\partner-setup-and-recovery.md
# Partner Setup and Recovery

You can use the 1.6.52 or higher version of the BrightAuthor:connected / BSN.cloud autorun to download a partner setup to your local PC and place it on an SD card. This is useful for advanced network configurations that require the player to be able to reach the internet to download the partner application. You can also set up a recovery URL if, for example, your SD card was corrupted and needs either reformatting or replacement (the player is not automatically configured for recovery in this workflow, unlike the B-Deploy workflow). If you have a lot of players, you can use the [Download Template / Upload Provisioning File](#PartnerSetupandRecovery-Provision) workflow to do this.

> [!WARNING]
> You must disable the autorun before reformatting the SD card on your device.
> To disable the autorun, use the PUT API /v1/control/reboot with body parameter { “autorun”:”disable” }, as described in [this page](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/378831527/Remote+DWS+APIs#RemoteDWSAPIs-%2Fcontrol%2Freboot%2F). This can also be done in the local DWS Diagnostics tab.

To save your setup package to an SD card through BrightAuthor:connected:

1.  Choose the **Partner Application** setup type, and select any partner (see Image 1).
    
2.  Select **Save Setup Files** so that the package can be saved to the SD card
    
3.  Factory reset the player
    
4.  Install the SD card
    
5.  Reboot the player
    

Next, set up a recovery URL for your partner application: 

1.  In BrightAuthor:connected, go to **Admin > Device Provisioning > Add Device** 
    
2.  Add your device serial number and check the box next to your player in the list
    
3.  In the **Actions** dropdown, choose **Apply Application**
    
4.  Choose **Partner Applications** and add the partner you previously selected.
    
5.  Select **Apply**
    

![](./attachments/Screen%20Shot%202022-06-14%20at%203.55.12%20PM.png)
----
partners\partners\bsncloud-for-partners.md
# BSN.cloud for Partners

BSN.cloud is the next-generation cloud-based infrastructure for networked BrightSign players. This section includes documentation for BSN.cloud services, including the following:

            

See [Cloud APIs](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/1902542978/Cloud+APIs) for an overview of the BrightSign REST APIs.
----
partners\partners\power-bi-announcement.md
# Power BI Announcement

Microsoft [has announced](https://powerbi.microsoft.com/en-us/blog/power-bi-june-2024-feature-summary/) that Chromium 94 will be the minimum browser supported on Power BI. Because of this change, BrightSign will upgrade our current Chromium 87 browser version (for Series 4 and 5 players), to accommodate Power BI users.

## Series 5

The current BOS 9.0.145.1 release contains a Beta version of Chromium 110. This version, which exceeds the Power BI requirement for Series 5, can be set by using the `chromium110` registry key.

The next BOS 9.0 release, which should be available before the end of August, will upgrade the beta Chromium 110 version to version 120. This functionality, set through the registry, will be considered a beta, but will eventually move into a BOS 9.1 release which will contain Chromium 120 as the default. These versions offer significant performance improvements, enhanced security, and access to the latest web technologies.

See [this page](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370673541/Diagnostic+Web+Server#Registry) for more information about changing registry key settings in BrightAuthor:connected.

### Registry Key Example Settings

You must reboot after updating the registry to apply the changes.

#### DWS  

Don't forget to add authentication to the Curl command below:

```
curl --location --request PUT 'http://<player_ip>/api/v1/registry/html/widget_type' \
--header 'Content-Type: application/json' \
--digest -u '{username}:{password}' \
--data-raw '{"value": "chromium110"}'
```

#### BrightScript Console

See [this page](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/1988100153/BrightSign+Shell) for more information.

```
registry write html widget_type chromium110
```

#### BrightScript

See [this page](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370673018/roRegistrySection) for more information.

```
RegHtml = CreateObject("roRegistrySection", "html")
RegHtml.Write("widget_type", "chromium110")
RegHtml.Flush()
```

#### JavaScript

See [this page](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370678545/registry) for more information.

```
var registryClass = require("@brightsign/registry");
var registry = new registryClass();
registry.write("html", { widget_type: "chromium110" }).then(() => {
  console.log("Write Successful");
}).catch((error) => {
  console.error("Write Failed", error);
});
```

#### TypeScript

See [this page](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/370678545/registry) for more information.

```
import RegistryClass from "@brightsign/registry";
const registry = new RegistryClass();
registry.write("html", { widget_type: "chromium110" }).then(() => {
  console.log("Write Successful");
}).catch((error: Error) => {
  console.error("Write Failed", error);
});
```

#### Player CLI

See [@brightsign/bsc](https://www.npmjs.com/package/@brightsign/bsc) (CLI Tool) for more information.

```
bsc local registry --player PLAYER_NAME --set --value chromium110 --section html --key widget_type
```

## Series 4

BrightSign plans to release BOS 9.1 with a Chromium 120 beta before the end of August to help customers using Power BI. We are investigating if this version can unify the Series 4 and 5 BOS versions.

## Series 3

BrightSign is investigating the Series 3 product line hardware capabilities in order to provide a higher Chromium version.

> [!WARNING]
> Beta OS versions may contain functional differences with the production OS.
----
partners\partners\updating-bos-from-htmljavascript-applications.md
# Updating BOS from HTML/JavaScript Applications

![](https://brightsign.atlassian.net/wiki/images/icons/grey_arrow_down.png)

Table of Contents

*   [Accessing the BOS](#accessing-the-bos)
*   [Installing the Update](#installing-the-update)
    *   [Code Requirements](#code-requirements)
    *   [Selecting a Download Location](#selecting-a-download-location)
*   [Example](#example)
*   [Checking the BOS](#checking-the-bos)

BrightSign partners who use HTML/JavaScript applications (and do not use the BrightAuthor:connected interface) can follow the steps outlined below to update to the latest BOS. 

## Accessing the BOS

1.  Go to the [Downloads](http://www.brightsign.biz/downloads/overview/) section of our website or to [Previous-BOS-Releases](https://brightsign.atlassian.net/wiki/spaces/DOC/pages/2165178386/Previous+BOS+Releases) to download the BOS version you want. 
    
2.  Click the **Download** button on the download page that corresponds with the model number of your BrightSign player. Note that BOS versions for different model families are often designated with the same number, but they are different files. Make sure to use only the update file that corresponds to the model number of your BrightSign player.
    
3.  Unzip the downloaded file.
    
4.  Put the *.bsfw* file in your known URL location.
    

Contact [support@brightsign.biz](mailto:support@brightsign.biz) if you need help creating an URL for the correct BOS release.

## Installing the Update

To install the update, your code must download the BOS update into the root directory of an attached storage device (where the OS will look for it during a reboot) and reboot the player after the download. You may also want to add a check to see if the BOS has been downloaded correctly.

### Code Requirements

1.  Specify the correct OS version and *.bsfw*  from the downloaded URL.
    
2.  If you know where to download the update, specify that location in your code. If not, the code must "decide" where to write the BOS update file. See "Selecting a Download Location" for more guidance.
    
3.  Download the BOS. You can use the `downloadFile()` function and and the `node-fetch` module or your own preferred method.
    
4.  To call the reboot function after download, use the [*@brightsign/system*](https://docs.brightsign.biz/display/DOC/system) API.
    
5.  You can use the [*@brightsign/deviceinfo*](https://docs.brightsign.biz/display/DOC/deviceinfo) API to make sure the BOS was downloaded correctly on the device.
    

### Selecting a Download Location

You can use any writable storage device with sufficient space, but we recommend that you implement a search order which prefers a faster or more durable device (prioritize a plugged in USB stick over other storage, while the primary SD should take precedence over the secondary SD, and an SD card the user plugs in should take precedence over an SSD). For example:

1.  */storage/usb1* (the drive for USB storage devices connected to the player)
    
2.  */storage/sd* (the primary SD or microSD drive on the player)
    
3.  */storage/sd2* (the internal microSD drive on the player for 4Kx42, XDx32 models)
    
4.  */storage/ssd* (the internal SSD on the player for XTx44, XTx43, XDx34, and XDx33 models)
    

Have your script iterate over all the mountpoints in */storage* (skipping anything that's not a mountpoint, or is a tmpfs, or is read-only) looking for a drive with enough space.

## Example

This code is for illustration purposes only. A production implementation should also contain steps to handle errors, data overflow, write-protected storage devices, etc.

If you want to run it, you'll need to have Node.js enabled in your browser runtime. You should also edit it to point to the correct:

*   `osYouWant:` The correct OS version
    
*   `fwName:` The *.bsfw* filename of the OS
    
*   `URL:` The OS URL ([https://bsncloud.s3.amazonaws.com/public](https://bsncloud.s3.amazonaws.com/public/) is the public URL that stores BrightSign .bsfw files).
    
*   `devicePath:` Write the OS update to this storage device  
    

```
// Fetch the BOS url.
let fs = require("fs")
let path = require("path")
let fetch = require("node-fetch");

const systemClass = require("@brightsign/system");
let system = new systemClass();
const diClass = require("@brightsign/deviceinfo");
let di = new diClass();

// Use the information in the hardcoded URL to specify the osYouWant and fwName variables.
let osYouWant = '8.2.82'
let fwName = 'malibu-8.2.82-update.bsfw'
let url = 'https://bsncloud.s3.amazonaws.com/public/malibu-8.2.82-update.bsfw';
let devicePath = '/storage/sd/'+fwName;


const downloadFile = (async (url, path) => {
  const res = await fetch(url);
  const fileStream = fs.createWriteStream(path);
  await new Promise((resolve, reject) => {
      res.body.pipe(fileStream);
      res.body.on("error", (err) => {
        reject(err);
      });
      fileStream.on("finish", function() {
        resolve('success');
      });
    });
});

 
function main(){
  if (di.osVersionCompare(osYouWant) != 0) {
    downloadFile(url, devicePath).then(() => {
        console.log(`${osYouWant} has been downloaded successfully!`)
        system.reboot();
    })
    .catch((err) => {
        console.log(err)
    })
  }
  else{
    console.log(`You have gotten the right OS ${osYouWant} you want!`)
  }
}

main();
```

## Checking the BOS

After the player reboots, check the BrightSign BOS version in the [BrightAuthor:connected DWS](https://docs.brightsign.biz/display/DOC/Diagnostic+Web+Server#DiagnosticWebServer-Infoinfo) to make sure that it is updated to the correct version.
----
partners\partners.md
# Partners

Collapse all

[Expand all](#)   [Collapse all](#)
--END--